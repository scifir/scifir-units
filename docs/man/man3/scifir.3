.TH "scifir" 3 "Version 2.0.0" "scifir-units" \" -*- nroff -*-
.ad l
.nh
.SH NAME
scifir \- The namespace scifir contains all scifir-units, excepting the string literals, which are outside\&.  

.SH SYNOPSIS
.br
.PP
.SS "Classes"

.in +1c
.ti -1c
.RI "class \fBaid\fP"
.br
.ti -1c
.RI "class \fBangle\fP"
.br
.RI "Class that allows to work with angles\&. "
.ti -1c
.RI "class \fBcas_number\fP"
.br
.ti -1c
.RI "class \fBcolor\fP"
.br
.ti -1c
.RI "class \fBcomplex_number\fP"
.br
.ti -1c
.RI "class \fBconversion\fP"
.br
.ti -1c
.RI "class \fBcoordinates_1d\fP"
.br
.ti -1c
.RI "class \fBcoordinates_1d< float >\fP"
.br
.ti -1c
.RI "class \fBcoordinates_2d\fP"
.br
.ti -1c
.RI "class \fBcoordinates_2d< float >\fP"
.br
.ti -1c
.RI "class \fBcoordinates_2dr\fP"
.br
.ti -1c
.RI "class \fBcoordinates_2dr< float >\fP"
.br
.ti -1c
.RI "class \fBcoordinates_3d\fP"
.br
.ti -1c
.RI "class \fBcoordinates_3d< float >\fP"
.br
.ti -1c
.RI "class \fBcoordinates_3dr\fP"
.br
.ti -1c
.RI "class \fBcoordinates_3dr< float >\fP"
.br
.ti -1c
.RI "class \fBcoordinates_nd\fP"
.br
.ti -1c
.RI "class \fBcoordinates_nd< float >\fP"
.br
.ti -1c
.RI "class \fBcoordinates_ndr\fP"
.br
.ti -1c
.RI "class \fBcoordinates_ndr< float >\fP"
.br
.ti -1c
.RI "class \fBdimension\fP"
.br
.ti -1c
.RI "class \fBdirection\fP"
.br
.ti -1c
.RI "struct \fBis_integer_number\fP"
.br
.ti -1c
.RI "struct \fBis_number\fP"
.br
.ti -1c
.RI "class \fBlab_number\fP"
.br
.ti -1c
.RI "class \fBmaterial_vector_unit_2d\fP"
.br
.ti -1c
.RI "class \fBmatrix\fP"
.br
.ti -1c
.RI "class \fBpercentage\fP"
.br
.ti -1c
.RI "class \fBpH\fP"
.br
.ti -1c
.RI "class \fBpixel\fP"
.br
.ti -1c
.RI "class \fBpOH\fP"
.br
.ti -1c
.RI "class \fBpoint_1d\fP"
.br
.ti -1c
.RI "class \fBpoint_1d< float >\fP"
.br
.ti -1c
.RI "class \fBpoint_2d\fP"
.br
.ti -1c
.RI "class \fBpoint_2d< float >\fP"
.br
.ti -1c
.RI "class \fBpoint_3d\fP"
.br
.ti -1c
.RI "class \fBpoint_3d< float >\fP"
.br
.ti -1c
.RI "class \fBpoint_nd\fP"
.br
.ti -1c
.RI "class \fBpoint_nd< float >\fP"
.br
.ti -1c
.RI "class \fBprefix\fP"
.br
.ti -1c
.RI "class \fBscalar_unit\fP"
.br
.RI "Class that allows to create scalar units\&. "
.ti -1c
.RI "class \fBsize_2d\fP"
.br
.ti -1c
.RI "class \fBsize_2d< float >\fP"
.br
.ti -1c
.RI "class \fBsize_3d\fP"
.br
.ti -1c
.RI "class \fBsize_3d< float >\fP"
.br
.ti -1c
.RI "class \fBsize_nd\fP"
.br
.ti -1c
.RI "class \fBsize_nd< float >\fP"
.br
.ti -1c
.RI "class \fBtensor_unit\fP"
.br
.ti -1c
.RI "class \fBvector_unit_2d\fP"
.br
.ti -1c
.RI "class \fBvector_unit_3d\fP"
.br
.ti -1c
.RI "class \fBvector_unit_nd\fP"
.br
.ti -1c
.RI "class \fBzid\fP"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "\fBtypedef\fP \fBlength\fP \fBwavelength\fP"
.br
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum class \fBastronomical_body\fP : int8_t { \fBNONE\fP, \fBMILKY_WAY\fP, \fBANDROMEDA\fP, \fBSOLAR_SYSTEM\fP, \fBSUN\fP, \fBMOON\fP, \fBMERCURY\fP, \fBVENUS\fP, \fBEARTH\fP, \fBMARS\fP, \fBJUPITER\fP, \fBSATURN\fP, \fBURANUS\fP, \fBNEPTUNE\fP, \fBCERES\fP, \fBORCUS\fP, \fBPLUTO\fP, \fBHAUMEA\fP, \fBQUAOAR\fP, \fBMAKEMAKE\fP, \fBGONGGONG\fP, \fBERIS\fP, \fBSEDNA\fP, \fBIO\fP, \fBEUROPA\fP, \fBGANYMEDE\fP, \fBCALLISTO\fP, \fBMIMAS\fP, \fBENCELADUS\fP, \fBTETHYS\fP, \fBDIONE\fP, \fBRHEA\fP, \fBTITAN\fP, \fBIAPETUS\fP, \fBMIRANDA\fP, \fBARIEL\fP, \fBUMBRIEL\fP, \fBTITANIA\fP, \fBOBERON\fP, \fBTRITON\fP, \fBCHARON\fP, \fBDYSNOMIA\fP }"
.br
.ti -1c
.RI "enum class \fBmovement\fP { \fBSTILL\fP, \fBWALK\fP, \fBRUN\fP, \fBSWIM\fP, \fBCLIMB\fP, \fBFLY\fP }"
.br
.ti -1c
.RI "enum class \fBmovement_state\fP { \fBSTILL\fP, \fBACTIVE\fP }"
.br
.ti -1c
.RI "enum class \fBbody_health\fP { \fBHEALTHY\fP, \fBDAMAGED\fP, \fBSICK\fP, \fBSICK_AND_DAMAGED\fP }"
.br
.ti -1c
.RI "enum class \fBalert_state\fP { \fBVIGIL\fP, \fBSLEEP\fP, \fBMEDITATION\fP }"
.br
.ti -1c
.RI "enum class \fBfeeling\fP { \fBSADNESS\fP, \fBRANCOR\fP, \fBLOVE\fP }"
.br
.ti -1c
.RI "enum class \fBemotion\fP { \fBHAPPY\fP, \fBEXCITED\fP, \fBTENDER\fP, \fBSCARED\fP, \fBANGRY\fP, \fBSAD\fP }"
.br
.ti -1c
.RI "enum class \fBsensation\fP { \fBLIGHT\fP, \fBSOUND\fP, \fBACCELERATION\fP, \fBODOR\fP, \fBTASTE\fP, \fBTOUCH\fP, \fBTEMPERATURE\fP }"
.br
.ti -1c
.RI "enum class \fBconscience_state\fP { \fBNORMAL\fP, \fBALTERED\fP }"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBstring\fP \fBto_string\fP (\fBconst\fP \fBcoordinates_1d\fP< \fBfloat\fP > &x)"
.br
.ti -1c
.RI "\fBfloat\fP \fBdistance\fP (\fBconst\fP \fBcoordinates_1d\fP< \fBfloat\fP > &x, \fBconst\fP \fBcoordinates_1d\fP< \fBfloat\fP > &y)"
.br
.ti -1c
.RI "\fBfloat\fP \fBdistance\fP (\fBconst\fP \fBcoordinates_1d\fP< \fBfloat\fP > &x, \fBconst\fP \fBpoint_1d\fP< \fBfloat\fP > &y)"
.br
.ti -1c
.RI "\fBfloat\fP \fBdistance\fP (\fBconst\fP \fBpoint_1d\fP< \fBfloat\fP > &x, \fBconst\fP \fBcoordinates_1d\fP< \fBfloat\fP > &y)"
.br
.ti -1c
.RI "template<\fBtypename\fP T > \fBstring\fP \fBto_string\fP (\fBconst\fP \fBcoordinates_1d\fP< T > &x)"
.br
.ti -1c
.RI "template<\fBtypename\fP T , \fBtypename\fP \fBU\fP > T \fBdistance\fP (\fBconst\fP \fBcoordinates_1d\fP< T > &x, \fBconst\fP \fBcoordinates_1d\fP< \fBU\fP > &y)"
.br
.ti -1c
.RI "template<\fBtypename\fP T , \fBtypename\fP \fBU\fP > T \fBdistance\fP (\fBconst\fP \fBcoordinates_1d\fP< T > &x, \fBconst\fP \fBpoint_1d\fP< \fBU\fP > &y)"
.br
.ti -1c
.RI "template<\fBtypename\fP T , \fBtypename\fP \fBU\fP > T \fBdistance\fP (\fBconst\fP \fBpoint_1d\fP< T > &x, \fBconst\fP \fBcoordinates_1d\fP< \fBU\fP > &y)"
.br
.ti -1c
.RI "\fBstring\fP \fBto_string\fP (\fBconst\fP \fBcoordinates_2d\fP< \fBfloat\fP > &x)"
.br
.ti -1c
.RI "\fBfloat\fP \fBdistance\fP (\fBconst\fP \fBcoordinates_2d\fP< \fBfloat\fP > &x, \fBconst\fP \fBcoordinates_2d\fP< \fBfloat\fP > &y)"
.br
.ti -1c
.RI "\fBfloat\fP \fBdistance\fP (\fBconst\fP \fBcoordinates_2d\fP< \fBfloat\fP > &x, \fBconst\fP \fBpoint_2d\fP< \fBfloat\fP > &y)"
.br
.ti -1c
.RI "\fBfloat\fP \fBdistance\fP (\fBconst\fP \fBpoint_2d\fP< \fBfloat\fP > &x, \fBconst\fP \fBcoordinates_2d\fP< \fBfloat\fP > &y)"
.br
.ti -1c
.RI "template<\fBtypename\fP T > \fBstring\fP \fBto_string\fP (\fBconst\fP \fBcoordinates_2d\fP< T > &x)"
.br
.ti -1c
.RI "template<\fBtypename\fP T , \fBtypename\fP \fBU\fP > T \fBdistance\fP (\fBconst\fP \fBcoordinates_2d\fP< T > &x, \fBconst\fP \fBcoordinates_2d\fP< \fBU\fP > &y)"
.br
.ti -1c
.RI "template<\fBtypename\fP T , \fBtypename\fP \fBU\fP > T \fBdistance\fP (\fBconst\fP \fBcoordinates_2d\fP< T > &x, \fBconst\fP \fBpoint_2d\fP< \fBU\fP > &y)"
.br
.ti -1c
.RI "template<\fBtypename\fP T , \fBtypename\fP \fBU\fP > T \fBdistance\fP (\fBconst\fP \fBpoint_2d\fP< T > &x, \fBconst\fP \fBcoordinates_2d\fP< \fBU\fP > &y)"
.br
.ti -1c
.RI "\fBscalar_unit\fP \fBcartesian_2d_to_polar_p\fP (\fBconst\fP \fBscalar_unit\fP &x, \fBscalar_unit\fP y)"
.br
.ti -1c
.RI "\fBangle\fP \fBcartesian_2d_to_polar_theta\fP (\fBconst\fP \fBscalar_unit\fP &x, \fBscalar_unit\fP y)"
.br
.ti -1c
.RI "\fBscalar_unit\fP \fBpolar_to_cartesian_2d_x\fP (\fBconst\fP \fBscalar_unit\fP &p, \fBconst\fP \fBangle\fP &theta)"
.br
.ti -1c
.RI "\fBscalar_unit\fP \fBpolar_to_cartesian_2d_y\fP (\fBconst\fP \fBscalar_unit\fP &p, \fBconst\fP \fBangle\fP &theta)"
.br
.ti -1c
.RI "\fBfloat\fP \fBcartesian_2d_to_polar_p\fP (\fBfloat\fP x, \fBfloat\fP y)"
.br
.ti -1c
.RI "\fBangle\fP \fBcartesian_2d_to_polar_theta\fP (\fBfloat\fP x, \fBfloat\fP y)"
.br
.ti -1c
.RI "\fBfloat\fP \fBpolar_to_cartesian_2d_x\fP (\fBfloat\fP p, \fBconst\fP \fBangle\fP &theta)"
.br
.ti -1c
.RI "\fBfloat\fP \fBpolar_to_cartesian_2d_y\fP (\fBfloat\fP p, \fBconst\fP \fBangle\fP &theta)"
.br
.ti -1c
.RI "\fBstring\fP \fBto_string\fP (\fBconst\fP \fBcoordinates_2dr\fP< \fBfloat\fP > &x)"
.br
.ti -1c
.RI "\fBfloat\fP \fBdistance\fP (\fBconst\fP \fBcoordinates_2dr\fP< \fBfloat\fP > &x, \fBconst\fP \fBcoordinates_2dr\fP< \fBfloat\fP > &y)"
.br
.ti -1c
.RI "\fBfloat\fP \fBdistance\fP (\fBconst\fP \fBcoordinates_2dr\fP< \fBfloat\fP > &x, \fBconst\fP \fBcoordinates_2d\fP< \fBfloat\fP > &y)"
.br
.ti -1c
.RI "\fBfloat\fP \fBdistance\fP (\fBconst\fP \fBcoordinates_2d\fP< \fBfloat\fP > &x, \fBconst\fP \fBcoordinates_2dr\fP< \fBfloat\fP > &y)"
.br
.ti -1c
.RI "\fBfloat\fP \fBdistance\fP (\fBconst\fP \fBcoordinates_2dr\fP< \fBfloat\fP > &x, \fBconst\fP \fBpoint_2d\fP< \fBfloat\fP > &y)"
.br
.ti -1c
.RI "\fBfloat\fP \fBdistance\fP (\fBconst\fP \fBpoint_2d\fP< \fBfloat\fP > &x, \fBconst\fP \fBcoordinates_2dr\fP< \fBfloat\fP > &y)"
.br
.ti -1c
.RI "template<\fBtypename\fP T > \fBstring\fP \fBto_string\fP (\fBconst\fP \fBcoordinates_2dr\fP< T > &x)"
.br
.ti -1c
.RI "template<\fBtypename\fP T , \fBtypename\fP \fBU\fP > T \fBdistance\fP (\fBconst\fP \fBcoordinates_2dr\fP< T > &x, \fBconst\fP \fBcoordinates_2dr\fP< \fBU\fP > &y)"
.br
.ti -1c
.RI "template<\fBtypename\fP T , \fBtypename\fP \fBU\fP > T \fBdistance\fP (\fBconst\fP \fBcoordinates_2dr\fP< T > &x, \fBconst\fP \fBcoordinates_2d\fP< \fBU\fP > &y)"
.br
.ti -1c
.RI "template<\fBtypename\fP T , \fBtypename\fP \fBU\fP > T \fBdistance\fP (\fBconst\fP \fBcoordinates_2d\fP< T > &x, \fBconst\fP \fBcoordinates_2dr\fP< \fBU\fP > &y)"
.br
.ti -1c
.RI "template<\fBtypename\fP T , \fBtypename\fP \fBU\fP > T \fBdistance\fP (\fBconst\fP \fBcoordinates_2dr\fP< T > &x, \fBconst\fP \fBpoint_2d\fP< \fBU\fP > &y)"
.br
.ti -1c
.RI "template<\fBtypename\fP T , \fBtypename\fP \fBU\fP > T \fBdistance\fP (\fBconst\fP \fBpoint_2d\fP< T > &x, \fBconst\fP \fBcoordinates_2dr\fP< \fBU\fP > &y)"
.br
.ti -1c
.RI "\fBstring\fP \fBto_string\fP (\fBconst\fP \fBcoordinates_3d\fP< \fBfloat\fP > &x)"
.br
.ti -1c
.RI "\fBfloat\fP \fBdistance\fP (\fBconst\fP \fBcoordinates_3d\fP< \fBfloat\fP > &x, \fBconst\fP \fBcoordinates_3d\fP< \fBfloat\fP > &y)"
.br
.ti -1c
.RI "\fBfloat\fP \fBdistance\fP (\fBconst\fP \fBcoordinates_3d\fP< \fBfloat\fP > &x, \fBconst\fP \fBpoint_3d\fP< \fBfloat\fP > &y)"
.br
.ti -1c
.RI "\fBfloat\fP \fBdistance\fP (\fBconst\fP \fBpoint_3d\fP< \fBfloat\fP > &x, \fBconst\fP \fBcoordinates_3d\fP< \fBfloat\fP > &y)"
.br
.ti -1c
.RI "template<\fBtypename\fP T > \fBstring\fP \fBto_string\fP (\fBconst\fP \fBcoordinates_3d\fP< T > &x)"
.br
.ti -1c
.RI "template<\fBtypename\fP T , \fBtypename\fP \fBU\fP > T \fBdistance\fP (\fBconst\fP \fBcoordinates_3d\fP< T > &x, \fBconst\fP \fBcoordinates_3d\fP< \fBU\fP > &y)"
.br
.ti -1c
.RI "template<\fBtypename\fP T , \fBtypename\fP \fBU\fP > T \fBdistance\fP (\fBconst\fP \fBcoordinates_3d\fP< T > &x, \fBconst\fP \fBpoint_3d\fP< \fBU\fP > &y)"
.br
.ti -1c
.RI "template<\fBtypename\fP T , \fBtypename\fP \fBU\fP > T \fBdistance\fP (\fBconst\fP \fBpoint_3d\fP< T > &x, \fBconst\fP \fBcoordinates_3d\fP< \fBU\fP > &y)"
.br
.ti -1c
.RI "\fBscalar_unit\fP \fBcartesian_3d_to_cylindrical_p\fP (\fBconst\fP \fBscalar_unit\fP &x, \fBscalar_unit\fP y, \fBconst\fP \fBscalar_unit\fP &z)"
.br
.ti -1c
.RI "\fBangle\fP \fBcartesian_3d_to_cylindrical_theta\fP (\fBconst\fP \fBscalar_unit\fP &x, \fBscalar_unit\fP y, \fBconst\fP \fBscalar_unit\fP &z)"
.br
.ti -1c
.RI "\fBscalar_unit\fP \fBcartesian_3d_to_cylindrical_z\fP (\fBconst\fP \fBscalar_unit\fP &x, \fBconst\fP \fBscalar_unit\fP &y, \fBconst\fP \fBscalar_unit\fP &z)"
.br
.ti -1c
.RI "\fBscalar_unit\fP \fBcartesian_3d_to_spherical_r\fP (\fBconst\fP \fBscalar_unit\fP &x, \fBscalar_unit\fP y, \fBscalar_unit\fP z)"
.br
.ti -1c
.RI "\fBangle\fP \fBcartesian_3d_to_spherical_theta\fP (\fBconst\fP \fBscalar_unit\fP &x, \fBscalar_unit\fP y, \fBconst\fP \fBscalar_unit\fP &z)"
.br
.ti -1c
.RI "\fBangle\fP \fBcartesian_3d_to_spherical_phi\fP (\fBconst\fP \fBscalar_unit\fP &x, \fBscalar_unit\fP y, \fBscalar_unit\fP z)"
.br
.ti -1c
.RI "\fBscalar_unit\fP \fBspherical_to_cartesian_3d_x\fP (\fBconst\fP \fBscalar_unit\fP &\fBr\fP, \fBconst\fP \fBangle\fP &theta, \fBconst\fP \fBangle\fP &phi)"
.br
.ti -1c
.RI "\fBscalar_unit\fP \fBspherical_to_cartesian_3d_y\fP (\fBconst\fP \fBscalar_unit\fP &\fBr\fP, \fBconst\fP \fBangle\fP &theta, \fBconst\fP \fBangle\fP &phi)"
.br
.ti -1c
.RI "\fBscalar_unit\fP \fBspherical_to_cartesian_3d_z\fP (\fBconst\fP \fBscalar_unit\fP &\fBr\fP, \fBconst\fP \fBangle\fP &theta, \fBconst\fP \fBangle\fP &phi)"
.br
.ti -1c
.RI "\fBscalar_unit\fP \fBspherical_to_cylindrical_p\fP (\fBconst\fP \fBscalar_unit\fP &\fBr\fP, \fBconst\fP \fBangle\fP &theta, \fBconst\fP \fBangle\fP &phi)"
.br
.ti -1c
.RI "\fBangle\fP \fBspherical_to_cylindrical_theta\fP (\fBconst\fP \fBscalar_unit\fP &\fBr\fP, \fBconst\fP \fBangle\fP &theta, \fBconst\fP \fBangle\fP &phi)"
.br
.ti -1c
.RI "\fBscalar_unit\fP \fBspherical_to_cylindrical_z\fP (\fBconst\fP \fBscalar_unit\fP &\fBr\fP, \fBconst\fP \fBangle\fP &theta, \fBconst\fP \fBangle\fP &phi)"
.br
.ti -1c
.RI "\fBscalar_unit\fP \fBcylindrical_to_cartesian_3d_x\fP (\fBconst\fP \fBscalar_unit\fP &p, \fBconst\fP \fBangle\fP &theta, \fBconst\fP \fBscalar_unit\fP &z)"
.br
.ti -1c
.RI "\fBscalar_unit\fP \fBcylindrical_to_cartesian_3d_y\fP (\fBconst\fP \fBscalar_unit\fP &p, \fBconst\fP \fBangle\fP &theta, \fBconst\fP \fBscalar_unit\fP &z)"
.br
.ti -1c
.RI "\fBscalar_unit\fP \fBcylindrical_to_cartesian_3d_z\fP (\fBconst\fP \fBscalar_unit\fP &p, \fBconst\fP \fBangle\fP &theta, \fBconst\fP \fBscalar_unit\fP &z)"
.br
.ti -1c
.RI "\fBscalar_unit\fP \fBcylindrical_to_spherical_r\fP (\fBconst\fP \fBscalar_unit\fP &p, \fBconst\fP \fBangle\fP &theta, \fBscalar_unit\fP z)"
.br
.ti -1c
.RI "\fBangle\fP \fBcylindrical_to_spherical_theta\fP (\fBconst\fP \fBscalar_unit\fP &p, \fBconst\fP \fBangle\fP &theta, \fBconst\fP \fBscalar_unit\fP &z)"
.br
.ti -1c
.RI "\fBangle\fP \fBcylindrical_to_spherical_phi\fP (\fBconst\fP \fBscalar_unit\fP &p, \fBconst\fP \fBangle\fP &theta, \fBscalar_unit\fP z)"
.br
.ti -1c
.RI "\fBfloat\fP \fBcartesian_3d_to_cylindrical_p\fP (\fBfloat\fP x, \fBfloat\fP y, \fBfloat\fP z)"
.br
.ti -1c
.RI "\fBangle\fP \fBcartesian_3d_to_cylindrical_theta\fP (\fBfloat\fP x, \fBfloat\fP y, \fBfloat\fP z)"
.br
.ti -1c
.RI "\fBfloat\fP \fBcartesian_3d_to_cylindrical_z\fP (\fBfloat\fP x, \fBfloat\fP y, \fBfloat\fP z)"
.br
.ti -1c
.RI "\fBfloat\fP \fBcartesian_3d_to_spherical_r\fP (\fBfloat\fP x, \fBfloat\fP y, \fBfloat\fP z)"
.br
.ti -1c
.RI "\fBangle\fP \fBcartesian_3d_to_spherical_theta\fP (\fBfloat\fP x, \fBfloat\fP y, \fBfloat\fP z)"
.br
.ti -1c
.RI "\fBangle\fP \fBcartesian_3d_to_spherical_phi\fP (\fBfloat\fP x, \fBfloat\fP y, \fBfloat\fP z)"
.br
.ti -1c
.RI "\fBfloat\fP \fBspherical_to_cartesian_3d_x\fP (\fBfloat\fP \fBr\fP, \fBconst\fP \fBangle\fP &theta, \fBconst\fP \fBangle\fP &phi)"
.br
.ti -1c
.RI "\fBfloat\fP \fBspherical_to_cartesian_3d_y\fP (\fBfloat\fP \fBr\fP, \fBconst\fP \fBangle\fP &theta, \fBconst\fP \fBangle\fP &phi)"
.br
.ti -1c
.RI "\fBfloat\fP \fBspherical_to_cartesian_3d_z\fP (\fBfloat\fP \fBr\fP, \fBconst\fP \fBangle\fP &theta, \fBconst\fP \fBangle\fP &phi)"
.br
.ti -1c
.RI "\fBfloat\fP \fBspherical_to_cylindrical_p\fP (\fBfloat\fP \fBr\fP, \fBconst\fP \fBangle\fP &theta, \fBconst\fP \fBangle\fP &phi)"
.br
.ti -1c
.RI "\fBangle\fP \fBspherical_to_cylindrical_theta\fP (\fBfloat\fP \fBr\fP, \fBconst\fP \fBangle\fP &theta, \fBconst\fP \fBangle\fP &phi)"
.br
.ti -1c
.RI "\fBfloat\fP \fBspherical_to_cylindrical_z\fP (\fBfloat\fP \fBr\fP, \fBconst\fP \fBangle\fP &theta, \fBconst\fP \fBangle\fP &phi)"
.br
.ti -1c
.RI "\fBfloat\fP \fBcylindrical_to_cartesian_3d_x\fP (\fBfloat\fP p, \fBconst\fP \fBangle\fP &theta, \fBfloat\fP z)"
.br
.ti -1c
.RI "\fBfloat\fP \fBcylindrical_to_cartesian_3d_y\fP (\fBfloat\fP p, \fBconst\fP \fBangle\fP &theta, \fBfloat\fP z)"
.br
.ti -1c
.RI "\fBfloat\fP \fBcylindrical_to_cartesian_3d_z\fP (\fBfloat\fP p, \fBconst\fP \fBangle\fP &theta, \fBfloat\fP z)"
.br
.ti -1c
.RI "\fBfloat\fP \fBcylindrical_to_spherical_r\fP (\fBfloat\fP p, \fBconst\fP \fBangle\fP &theta, \fBfloat\fP z)"
.br
.ti -1c
.RI "\fBangle\fP \fBcylindrical_to_spherical_theta\fP (\fBfloat\fP p, \fBconst\fP \fBangle\fP &theta, \fBfloat\fP z)"
.br
.ti -1c
.RI "\fBangle\fP \fBcylindrical_to_spherical_phi\fP (\fBfloat\fP p, \fBconst\fP \fBangle\fP &theta, \fBfloat\fP z)"
.br
.ti -1c
.RI "\fBstring\fP \fBto_string\fP (\fBconst\fP \fBcoordinates_3dr\fP< \fBfloat\fP > &x)"
.br
.ti -1c
.RI "\fBfloat\fP \fBdistance\fP (\fBconst\fP \fBcoordinates_3dr\fP< \fBfloat\fP > &x, \fBconst\fP \fBcoordinates_3dr\fP< \fBfloat\fP > &y)"
.br
.ti -1c
.RI "\fBfloat\fP \fBdistance\fP (\fBconst\fP \fBcoordinates_3dr\fP< \fBfloat\fP > &x, \fBconst\fP \fBcoordinates_3d\fP< \fBfloat\fP > &y)"
.br
.ti -1c
.RI "\fBfloat\fP \fBdistance\fP (\fBconst\fP \fBcoordinates_3d\fP< \fBfloat\fP > &x, \fBconst\fP \fBcoordinates_3dr\fP< \fBfloat\fP > &y)"
.br
.ti -1c
.RI "\fBfloat\fP \fBdistance\fP (\fBconst\fP \fBcoordinates_3dr\fP< \fBfloat\fP > &x, \fBconst\fP \fBpoint_3d\fP< \fBfloat\fP > &y)"
.br
.ti -1c
.RI "\fBfloat\fP \fBdistance\fP (\fBconst\fP \fBpoint_3d\fP< \fBfloat\fP > &x, \fBconst\fP \fBcoordinates_3dr\fP< \fBfloat\fP > &y)"
.br
.ti -1c
.RI "template<\fBtypename\fP T > \fBstring\fP \fBto_string\fP (\fBconst\fP \fBcoordinates_3dr\fP< T > &x)"
.br
.ti -1c
.RI "template<\fBtypename\fP T , \fBtypename\fP \fBU\fP > T \fBdistance\fP (\fBconst\fP \fBcoordinates_3dr\fP< T > &x, \fBconst\fP \fBcoordinates_3dr\fP< \fBU\fP > &y)"
.br
.ti -1c
.RI "template<\fBtypename\fP T , \fBtypename\fP \fBU\fP > T \fBdistance\fP (\fBconst\fP \fBcoordinates_3dr\fP< T > &x, \fBconst\fP \fBcoordinates_3d\fP< \fBU\fP > &y)"
.br
.ti -1c
.RI "template<\fBtypename\fP T , \fBtypename\fP \fBU\fP > T \fBdistance\fP (\fBconst\fP \fBcoordinates_3d\fP< T > &x, \fBconst\fP \fBcoordinates_3dr\fP< \fBU\fP > &y)"
.br
.ti -1c
.RI "template<\fBtypename\fP T , \fBtypename\fP \fBU\fP > T \fBdistance\fP (\fBconst\fP \fBcoordinates_3dr\fP< T > &x, \fBconst\fP \fBpoint_3d\fP< \fBU\fP > &y)"
.br
.ti -1c
.RI "template<\fBtypename\fP T , \fBtypename\fP \fBU\fP > T \fBdistance\fP (\fBconst\fP \fBpoint_3d\fP< T > &x, \fBconst\fP \fBcoordinates_3dr\fP< \fBU\fP > &y)"
.br
.ti -1c
.RI "\fBstring\fP \fBto_string\fP (\fBconst\fP \fBcoordinates_nd\fP< \fBfloat\fP > &x)"
.br
.ti -1c
.RI "\fBfloat\fP \fBdistance\fP (\fBconst\fP \fBcoordinates_nd\fP< \fBfloat\fP > &x, \fBconst\fP \fBcoordinates_nd\fP< \fBfloat\fP > &y)"
.br
.ti -1c
.RI "\fBfloat\fP \fBdistance\fP (\fBconst\fP \fBcoordinates_nd\fP< \fBfloat\fP > &x, \fBconst\fP \fBpoint_nd\fP< \fBfloat\fP > &y)"
.br
.ti -1c
.RI "\fBfloat\fP \fBdistance\fP (\fBconst\fP \fBpoint_nd\fP< \fBfloat\fP > &x, \fBconst\fP \fBcoordinates_nd\fP< \fBfloat\fP > &y)"
.br
.ti -1c
.RI "template<\fBtypename\fP T > \fBstring\fP \fBto_string\fP (\fBconst\fP \fBcoordinates_nd\fP< T > &x)"
.br
.ti -1c
.RI "template<\fBtypename\fP T , \fBtypename\fP \fBU\fP > T \fBdistance\fP (\fBconst\fP \fBcoordinates_nd\fP< T > &x, \fBconst\fP \fBcoordinates_nd\fP< \fBU\fP > &y)"
.br
.ti -1c
.RI "template<\fBtypename\fP T , \fBtypename\fP \fBU\fP > T \fBdistance\fP (\fBconst\fP \fBcoordinates_nd\fP< T > &x, \fBconst\fP \fBpoint_nd\fP< \fBU\fP > &y)"
.br
.ti -1c
.RI "template<\fBtypename\fP T , \fBtypename\fP \fBU\fP > T \fBdistance\fP (\fBconst\fP \fBpoint_nd\fP< T > &x, \fBconst\fP \fBcoordinates_nd\fP< \fBU\fP > &y)"
.br
.ti -1c
.RI "\fBstring\fP \fBto_string\fP (\fBconst\fP \fBcoordinates_ndr\fP< \fBfloat\fP > &x)"
.br
.ti -1c
.RI "\fBfloat\fP \fBdistance\fP (\fBconst\fP \fBcoordinates_ndr\fP< \fBfloat\fP > &x, \fBconst\fP \fBcoordinates_ndr\fP< \fBfloat\fP > &y)"
.br
.ti -1c
.RI "\fBfloat\fP \fBdistance\fP (\fBconst\fP \fBcoordinates_ndr\fP< \fBfloat\fP > &x, \fBconst\fP \fBcoordinates_nd\fP< \fBfloat\fP > &y)"
.br
.ti -1c
.RI "\fBfloat\fP \fBdistance\fP (\fBconst\fP \fBcoordinates_nd\fP< \fBfloat\fP > &x, \fBconst\fP \fBcoordinates_ndr\fP< \fBfloat\fP > &y)"
.br
.ti -1c
.RI "\fBfloat\fP \fBdistance\fP (\fBconst\fP \fBcoordinates_ndr\fP< \fBfloat\fP > &x, \fBconst\fP \fBpoint_nd\fP< \fBfloat\fP > &y)"
.br
.ti -1c
.RI "\fBfloat\fP \fBdistance\fP (\fBconst\fP \fBpoint_nd\fP< \fBfloat\fP > &x, \fBconst\fP \fBcoordinates_ndr\fP< \fBfloat\fP > &y)"
.br
.ti -1c
.RI "template<\fBtypename\fP T > \fBstring\fP \fBto_string\fP (\fBconst\fP \fBcoordinates_ndr\fP< T > &x)"
.br
.ti -1c
.RI "template<\fBtypename\fP T , \fBtypename\fP \fBU\fP > T \fBdistance\fP (\fBconst\fP \fBcoordinates_ndr\fP< T > &x, \fBconst\fP \fBcoordinates_ndr\fP< \fBU\fP > &y)"
.br
.ti -1c
.RI "template<\fBtypename\fP T , \fBtypename\fP \fBU\fP > T \fBdistance\fP (\fBconst\fP \fBcoordinates_ndr\fP< T > &x, \fBconst\fP \fBcoordinates_nd\fP< \fBU\fP > &y)"
.br
.ti -1c
.RI "template<\fBtypename\fP T , \fBtypename\fP \fBU\fP > T \fBdistance\fP (\fBconst\fP \fBcoordinates_nd\fP< T > &x, \fBconst\fP \fBcoordinates_ndr\fP< \fBU\fP > &y)"
.br
.ti -1c
.RI "template<\fBtypename\fP T , \fBtypename\fP \fBU\fP > T \fBdistance\fP (\fBconst\fP \fBcoordinates_ndr\fP< T > &x, \fBconst\fP \fBpoint_nd\fP< \fBU\fP > &y)"
.br
.ti -1c
.RI "template<\fBtypename\fP T , \fBtypename\fP \fBU\fP > T \fBdistance\fP (\fBconst\fP \fBpoint_nd\fP< T > &x, \fBconst\fP \fBcoordinates_ndr\fP< \fBU\fP > &y)"
.br
.ti -1c
.RI "\fBstring\fP \fBto_string\fP (\fBconst\fP \fBangle\fP &x)"
.br
.ti -1c
.RI "\fBbool\fP \fBis_angle\fP (\fBconst\fP \fBstring\fP &\fBinit_angle\fP)"
.br
.ti -1c
.RI "\fBbool\fP \fBparallel\fP (\fBconst\fP \fBangle\fP &x, \fBconst\fP \fBangle\fP &y)"
.br
.ti -1c
.RI "\fBbool\fP \fBorthogonal\fP (\fBconst\fP \fBangle\fP &x, \fBconst\fP \fBangle\fP &y)"
.br
.ti -1c
.RI "\fBangle\fP \fBsqrt\fP (\fBconst\fP \fBangle\fP &x)"
.br
.ti -1c
.RI "\fBangle\fP \fBsqrt_nth\fP (\fBconst\fP \fBangle\fP &x, \fBint\fP index)"
.br
.ti -1c
.RI "\fBfloat\fP \fBsin\fP (\fBconst\fP \fBangle\fP &x)"
.br
.ti -1c
.RI "\fBfloat\fP \fBcos\fP (\fBconst\fP \fBangle\fP &x)"
.br
.ti -1c
.RI "\fBfloat\fP \fBtan\fP (\fBconst\fP \fBangle\fP &x)"
.br
.ti -1c
.RI "\fBangle\fP \fBasin\fP (\fBfloat\fP x)"
.br
.ti -1c
.RI "\fBangle\fP \fBacos\fP (\fBfloat\fP x)"
.br
.ti -1c
.RI "\fBangle\fP \fBatan\fP (\fBfloat\fP x)"
.br
.ti -1c
.RI "\fBfloat\fP \fBsinh\fP (\fBconst\fP \fBangle\fP &x)"
.br
.ti -1c
.RI "\fBfloat\fP \fBcosh\fP (\fBconst\fP \fBangle\fP &x)"
.br
.ti -1c
.RI "\fBfloat\fP \fBtanh\fP (\fBconst\fP \fBangle\fP &x)"
.br
.ti -1c
.RI "\fBangle\fP \fBasinh\fP (\fBfloat\fP x)"
.br
.ti -1c
.RI "\fBangle\fP \fBacosh\fP (\fBfloat\fP x)"
.br
.ti -1c
.RI "\fBangle\fP \fBatanh\fP (\fBfloat\fP x)"
.br
.ti -1c
.RI "\fBfloat\fP \fBradian_to_grade\fP (\fBfloat\fP x)"
.br
.ti -1c
.RI "\fBfloat\fP \fBgrade_to_radian\fP (\fBfloat\fP x)"
.br
.ti -1c
.RI "\fBfloat\fP \fBasin_grade\fP (\fBfloat\fP x)"
.br
.ti -1c
.RI "\fBfloat\fP \fBacos_grade\fP (\fBfloat\fP x)"
.br
.ti -1c
.RI "\fBfloat\fP \fBatan_grade\fP (\fBfloat\fP x)"
.br
.ti -1c
.RI "\fBfloat\fP \fBasinh_grade\fP (\fBfloat\fP x)"
.br
.ti -1c
.RI "\fBfloat\fP \fBacosh_grade\fP (\fBfloat\fP x)"
.br
.ti -1c
.RI "\fBfloat\fP \fBatanh_grade\fP (\fBfloat\fP x)"
.br
.ti -1c
.RI "\fBbool\fP \fBis_complex\fP (\fBconst\fP \fBstring\fP &\fBinit_complex_number\fP)"
.br
.ti -1c
.RI "template<\fBtypename\fP T > \fBstring\fP \fBto_string\fP (\fBconst\fP \fBcomplex_number\fP< T > &x)"
.br
.ti -1c
.RI "template<\fBtypename\fP T > T \fBabs\fP (\fBconst\fP \fBcomplex_number\fP< T > &x)"
.br
.ti -1c
.RI "template<\fBtypename\fP T > \fBcomplex_number\fP< \fBscalar_unit\fP > \fBsqrt\fP (\fBconst\fP \fBcomplex_number\fP< T > &x)"
.br
.ti -1c
.RI "\fBbool\fP \fBis_lab_number\fP (\fBconst\fP \fBstring\fP &\fBinit_lab_number\fP)"
.br
.ti -1c
.RI "template<\fBtypename\fP T > \fBstring\fP \fBto_string\fP (\fBconst\fP \fBlab_number\fP< T > &x)"
.br
.ti -1c
.RI "\fBVECTOR_UNIT_CPP\fP (\fBspecific_angular_momentum\fP,'m2/\fBs'\fP)"
.br
.ti -1c
.RI "\fBVECTOR_UNIT_HPP\fP (\fBspecific_angular_momentum\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (\fBdensity\fP,'g/\fBm3'\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (\fBviscosity\fP,'m2/\fBs'\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (\fBspecific_volume\fP,'m3/\fBg'\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (\fBspecific_heat_capacity\fP,'m2/\fBs2\fP*\fBK'\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (\fBspecific_entropy\fP,'m2/\fBs2\fP*\fBK'\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (\fBspecific_energy\fP,'m2/\fBs2'\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (\fBmolar_volume\fP,'m3/\fBmol'\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (\fBmolar_mass\fP,'g/\fBmol'\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (\fBmolar_heat_capacity\fP,'m2*g/\fBs2\fP*K*\fBmol'\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (\fBmolar_enthalpy\fP,'m2*g/\fBs2\fP*\fBmol'\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (\fBmolar_entropy\fP,'m2*g/\fBs2\fP*K*\fBmol'\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (\fBmolar_energy\fP,'m2*g/\fBs2\fP*\fBmol'\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (\fBmolar_conductivity\fP,'s3*\fBA2\fP/g*\fBmol'\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (\fBenergy_density\fP,'g/m*\fBs2'\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (\fBcatalytic_efficiency\fP,'m3/s*\fBmol'\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (\fBmolarity\fP,'mol/\fBm3'\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (\fBmolality\fP,'mol/\fBg'\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (\fBlinear_mass_density\fP,'g/\fBm'\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (\fBarea_density\fP,'g/\fBm2'\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (\fBdynamic_viscosity\fP,'g/m*\fBs'\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (\fBmass_flow_rate\fP,'g/\fBs'\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (\fBcatalytic_activity\fP,'kat')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (\fBdensity\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (\fBviscosity\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (\fBspecific_volume\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (\fBspecific_heat_capacity\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (\fBspecific_entropy\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (\fBspecific_energy\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (\fBmolar_volume\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (\fBmolar_mass\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (\fBmolar_heat_capacity\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (\fBmolar_enthalpy\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (\fBmolar_entropy\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (\fBmolar_energy\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (\fBmolar_conductivity\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (\fBenergy_density\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (\fBcatalytic_efficiency\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (\fBmolarity\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (\fBmolality\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (\fBlinear_mass_density\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (\fBarea_density\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (\fBdynamic_viscosity\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (\fBmass_flow_rate\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (\fBcatalytic_activity\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (\fBelectrical_conductivity\fP,'A2*\fBs3\fP/\fBkg\fP*\fBm3'\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (\fBresistance\fP,'kg*\fBm2\fP/\fBA2\fP*\fBs3'\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (\fBelectric_conductance\fP,'A2*\fBs3\fP/\fBkg\fP*\fBm2'\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (\fBcapacitance\fP,'A2*\fBs4\fP/\fBm2\fP*\fBkg'\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (\fBpermittivity\fP,'A2*\fBs4\fP/\fBkg\fP*\fBm3'\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (\fBresistivity\fP,'kg*\fBm3\fP/\fBA2\fP*\fBs3'\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (\fBlinear_charge_density\fP,'A*s/\fBm'\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (\fBfrequency_drift\fP,'1/s2')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (\fBelectrical_conductivity\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (\fBresistance\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (\fBelectric_conductance\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (\fBcapacitance\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (\fBpermittivity\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (\fBresistivity\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (\fBlinear_charge_density\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (\fBfrequency_drift\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (\fBtransfer_speed\fP,'B/\fBs'\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (\fBtransfer_speed\fP)"
.br
.ti -1c
.RI "\fBVECTOR_UNIT_2D_CPP\fP (\fBdisplacement\fP,'m')"
.br
.ti -1c
.RI "\fBVECTOR_UNIT_3D_CPP\fP (\fBdisplacement\fP,'m')"
.br
.ti -1c
.RI "\fBVECTOR_UNIT_ND_CPP\fP (\fBdisplacement\fP,'m')"
.br
.ti -1c
.RI "\fBVECTOR_UNIT_CPP\fP (\fBvelocity\fP,'m/\fBs'\fP)"
.br
.ti -1c
.RI "\fBVECTOR_UNIT_CPP\fP (\fBacceleration\fP,'m/\fBs2'\fP)"
.br
.ti -1c
.RI "\fBVECTOR_UNIT_CPP\fP (\fBjerk\fP,'m/\fBs3'\fP)"
.br
.ti -1c
.RI "\fBVECTOR_UNIT_CPP\fP (\fBsnap\fP,'m/\fBs4'\fP)"
.br
.ti -1c
.RI "\fBVECTOR_UNIT_CPP\fP (\fBangular_velocity\fP,'rad/\fBs'\fP)"
.br
.ti -1c
.RI "\fBVECTOR_UNIT_CPP\fP (\fBangular_acceleration\fP,'rad/\fBs2'\fP)"
.br
.ti -1c
.RI "\fBVECTOR_UNIT_CPP\fP (\fBangular_momentum\fP,'m2*\fBkg\fP/\fBs'\fP)"
.br
.ti -1c
.RI "\fBVECTOR_UNIT_CPP\fP (\fBimpulse\fP,'m*\fBkg\fP/\fBs'\fP)"
.br
.ti -1c
.RI "\fBVECTOR_UNIT_CPP\fP (\fBforce\fP,'kg*m/\fBs2'\fP)"
.br
.ti -1c
.RI "\fBVECTOR_UNIT_CPP\fP (\fBtorque\fP,'kg*\fBm2\fP/\fBs2'\fP)"
.br
.ti -1c
.RI "\fBVECTOR_UNIT_CPP\fP (\fBpressure\fP,'kg/m*\fBs2'\fP)"
.br
.ti -1c
.RI "\fBVECTOR_UNIT_CPP\fP (\fBsurface_tension\fP,'kg/\fBs2'\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (\fBstiffness\fP,'kg/\fBs2'\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (\fBmoment_of_inertia\fP,'m2*\fBkg'\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (\fBelectric_current\fP,'A')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (\fBvoltage\fP,'V')"
.br
.ti -1c
.RI "\fBVECTOR_UNIT_CPP\fP (\fBelectric_displacement_field\fP,'A*s/\fBm2'\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (\fBelectric_charge_density\fP,'A*s/\fBm3'\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (\fBelectric_current_density\fP,'A/\fBm2'\fP)"
.br
.ti -1c
.RI "\fBVECTOR_UNIT_CPP\fP (\fBelectric_field_strength\fP,'kg*m/A*\fBs3'\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (\fBelectron_mobility\fP,'A*\fBs2\fP/\fBkg'\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (\fBinductance\fP,'H')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (\fBvolumetric_flow\fP,'m3/\fBs'\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (\fBdiffusion_coefficient\fP,'m2/\fBs'\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (\fBcompressibility\fP,'m*\fBs2\fP/\fBkg'\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (\fBpolarization_density\fP,'A*s/\fBm2'\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (\fBmagnetic_permeability\fP,'A2*\fBs2\fP/\fBkg\fP*\fBm'\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (\fBmagnetization\fP,'A/\fBm'\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (\fBmagnetic_flux\fP,'Wb')"
.br
.ti -1c
.RI "\fBVECTOR_UNIT_CPP\fP (\fBmagnetic_strength\fP,'Wb/\fBm2'\fP)"
.br
.ti -1c
.RI "\fBVECTOR_UNIT_CPP\fP (\fBmagnetic_moment\fP,'A*\fBm2'\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (\fBmagnetic_reluctance\fP,'A2*\fBs2\fP/\fBkg\fP*\fBm2'\fP)"
.br
.ti -1c
.RI "\fBVECTOR_UNIT_CPP\fP (\fBmagnetic_vector_potential\fP,'kg*m/A*\fBs2'\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (\fBmagnetic_rigidity\fP,'kg*m/A*\fBs2'\fP)"
.br
.ti -1c
.RI "\fBVECTOR_UNIT_CPP\fP (\fBmagnetomotive_force\fP,'A')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (\fBmagnetic_susceptibility\fP,'A2*\fBs2\fP/\fBkg\fP*\fBm'\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (\fBoptical_power\fP,'1/m')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (\fBluminance\fP,'cd/\fBm2'\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (\fBilluminance\fP,'lx')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (\fBluminous_flux\fP,'lm')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (\fBluminous_energy\fP,'cd*\fBsr\fP*\fBs'\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (\fBluminous_exposure\fP,'cd*\fBsr\fP*s/\fBm2'\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (\fBluminous_efficacy\fP,'lm/\fBW'\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (\fBionizing_radiation\fP,'A*s/\fBkg'\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (\fBabsorbed_dose\fP,'m2/\fBs3'\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (\fBenergy\fP,'kg*\fBm2\fP/\fBs2'\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (\fBaction\fP,'kg*\fBm2\fP/\fBs'\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (\fBpower\fP,'kg*\fBm2\fP/\fBs3'\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (\fBpower_density\fP,'kg/m*\fBs3'\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (\fBenthalpy\fP,'kg*\fBm2\fP/\fBs2'\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (\fBentropy\fP,'kg*\fBm2\fP/K*\fBs2'\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (\fBheat_capacity\fP,'kg*\fBm2\fP/K*\fBs2'\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (\fBheat_flux_density\fP,'kg/\fBs3'\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (\fBthermal_conductivity\fP,'kg*m/K*\fBs3'\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (\fBthermal_diffusivity\fP,'m2/\fBs'\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (\fBthermal_resistance\fP,'K*\fBs3\fP/\fBkg\fP*\fBm2'\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (\fBthermal_expansion_coefficient\fP,'1/K')"
.br
.ti -1c
.RI "\fBVECTOR_UNIT_CPP\fP (\fBtemperature_gradient\fP,'K/\fBm'\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (\fBenergy_flux_density\fP,'kg/\fBs3'\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (\fBwavenumber\fP,'1/m')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (\fBfrequency\fP,'1/s')"
.br
.ti -1c
.RI "\fBVECTOR_UNIT_2D_HPP\fP (\fBdisplacement\fP)"
.br
.ti -1c
.RI "\fBVECTOR_UNIT_3D_HPP\fP (\fBdisplacement\fP)"
.br
.ti -1c
.RI "\fBVECTOR_UNIT_ND_HPP\fP (\fBdisplacement\fP)"
.br
.ti -1c
.RI "\fBVECTOR_UNIT_HPP\fP (\fBvelocity\fP)"
.br
.ti -1c
.RI "\fBVECTOR_UNIT_HPP\fP (\fBacceleration\fP)"
.br
.ti -1c
.RI "\fBVECTOR_UNIT_HPP\fP (\fBjerk\fP)"
.br
.ti -1c
.RI "\fBVECTOR_UNIT_HPP\fP (\fBsnap\fP)"
.br
.ti -1c
.RI "\fBVECTOR_UNIT_HPP\fP (\fBangular_velocity\fP)"
.br
.ti -1c
.RI "\fBVECTOR_UNIT_HPP\fP (\fBangular_acceleration\fP)"
.br
.ti -1c
.RI "\fBVECTOR_UNIT_HPP\fP (\fBangular_momentum\fP)"
.br
.ti -1c
.RI "\fBVECTOR_UNIT_HPP\fP (\fBimpulse\fP)"
.br
.ti -1c
.RI "\fBVECTOR_UNIT_HPP\fP (\fBforce\fP)"
.br
.ti -1c
.RI "\fBVECTOR_UNIT_HPP\fP (\fBtorque\fP)"
.br
.ti -1c
.RI "\fBVECTOR_UNIT_HPP\fP (\fBpressure\fP)"
.br
.ti -1c
.RI "\fBVECTOR_UNIT_HPP\fP (\fBsurface_tension\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (\fBstiffness\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (\fBmoment_of_inertia\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (\fBelectric_current\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (\fBvoltage\fP)"
.br
.ti -1c
.RI "\fBVECTOR_UNIT_HPP\fP (\fBelectric_displacement_field\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (\fBelectric_charge_density\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (\fBelectric_current_density\fP)"
.br
.ti -1c
.RI "\fBVECTOR_UNIT_HPP\fP (\fBelectric_field_strength\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (\fBelectron_mobility\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (\fBinductance\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (\fBvolumetric_flow\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (\fBdiffusion_coefficient\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (\fBcompressibility\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (\fBpolarization_density\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (\fBmagnetic_permeability\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (\fBmagnetization\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (\fBmagnetic_flux\fP)"
.br
.ti -1c
.RI "\fBVECTOR_UNIT_HPP\fP (\fBmagnetic_strength\fP)"
.br
.ti -1c
.RI "\fBVECTOR_UNIT_HPP\fP (\fBmagnetic_moment\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (\fBmagnetic_reluctance\fP)"
.br
.ti -1c
.RI "\fBVECTOR_UNIT_HPP\fP (\fBmagnetic_vector_potential\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (\fBmagnetic_rigidity\fP)"
.br
.ti -1c
.RI "\fBVECTOR_UNIT_HPP\fP (\fBmagnetomotive_force\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (\fBmagnetic_susceptibility\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (\fBoptical_power\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (\fBluminance\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (\fBilluminance\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (\fBluminous_flux\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (\fBluminous_energy\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (\fBluminous_exposure\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (\fBluminous_efficacy\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (\fBionizing_radiation\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (\fBabsorbed_dose\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (\fBenergy\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (\fBaction\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (\fBpower\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (\fBpower_density\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (\fBenthalpy\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (\fBentropy\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (\fBheat_capacity\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (\fBheat_flux_density\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (\fBthermal_conductivity\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (\fBthermal_diffusivity\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (\fBthermal_resistance\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (\fBthermal_expansion_coefficient\fP)"
.br
.ti -1c
.RI "\fBVECTOR_UNIT_HPP\fP (\fBtemperature_gradient\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (\fBenergy_flux_density\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (\fBwavenumber\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (\fBfrequency\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (\fBradioactivity\fP,'Bq')"
.br
.ti -1c
.RI "\fBVECTOR_UNIT_CPP\fP (\fBirradiance\fP,'kg/\fBs3'\fP)"
.br
.ti -1c
.RI "\fBVECTOR_UNIT_CPP\fP (\fBradiant_exposure\fP,'kg/\fBs2'\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (\fBradiant_intensity\fP,'kg*\fBm2\fP/\fBs3'\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (\fBspectral_intensity\fP,'kg*m/\fBs3'\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (\fBradiance\fP,'kg/\fBs3'\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (\fBspectral_radiance\fP,'kg/m*\fBs3'\fP)"
.br
.ti -1c
.RI "\fBVECTOR_UNIT_CPP\fP (\fBradiant_flux\fP,'kg*\fBm2\fP/\fBs3'\fP)"
.br
.ti -1c
.RI "\fBVECTOR_UNIT_CPP\fP (\fBspectral_flux\fP,'kg*m/\fBs3'\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (\fBradioactivity\fP)"
.br
.ti -1c
.RI "\fBVECTOR_UNIT_HPP\fP (\fBirradiance\fP)"
.br
.ti -1c
.RI "\fBVECTOR_UNIT_HPP\fP (\fBradiant_exposure\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (\fBradiant_intensity\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (\fBspectral_intensity\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (\fBradiance\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (\fBspectral_radiance\fP)"
.br
.ti -1c
.RI "\fBVECTOR_UNIT_HPP\fP (\fBradiant_flux\fP)"
.br
.ti -1c
.RI "\fBVECTOR_UNIT_HPP\fP (\fBspectral_flux\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (\fBarea\fP,'m2')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (\fBvolume\fP,'m3')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (\fBvolume_4d\fP,'m4')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (\fBcurvature\fP,'1/m')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP_BEGIN\fP (\fBarea\fP)"
.br
.ti -1c
.RI "\fBarea\fP (\fBconst\fP \fBsize_2d\fP< \fBlength\fP > &)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP_END\fP ()"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP_BEGIN\fP (\fBvolume\fP)"
.br
.ti -1c
.RI "\fBvolume\fP (\fBconst\fP \fBsize_3d\fP< \fBlength\fP > &)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (\fBvolume_4d\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (\fBcurvature\fP)"
.br
.ti -1c
.RI "\fBstring\fP \fBto_string\fP (\fBconst\fP \fBaid\fP &x)"
.br
.ti -1c
.RI "\fBstring\fP \fBto_string\fP (\fBconst\fP \fBaid::type\fP &x)"
.br
.ti -1c
.RI "\fBaid::type\fP \fBcreate_astronomical_type\fP (\fBconst\fP \fBstring\fP &\fBastronomical_type_abbreviation\fP)"
.br
.ti -1c
.RI "\fBstring\fP \fBto_string\fP (\fBconst\fP \fBfeeling\fP &)"
.br
.ti -1c
.RI "\fBstring\fP \fBto_string\fP (\fBconst\fP \fBemotion\fP &)"
.br
.ti -1c
.RI "\fBstring\fP \fBto_string\fP (\fBconst\fP \fBsensation\fP &)"
.br
.ti -1c
.RI "\fBstring\fP \fBto_string\fP (\fBconst\fP \fBpercentage\fP &x)"
.br
.ti -1c
.RI "\fBbool\fP \fBis_percentage\fP (\fBconst\fP \fBstring\fP &\fBinit_percentage\fP)"
.br
.ti -1c
.RI "\fBstring\fP \fBto_string\fP (\fBconst\fP \fBpH\fP &x)"
.br
.ti -1c
.RI "\fBstring\fP \fBto_string\fP (\fBconst\fP \fBpixel\fP &x)"
.br
.ti -1c
.RI "\fBbool\fP \fBis_pixel\fP (\fBconst\fP \fBstring\fP &\fBinit_pixel\fP)"
.br
.ti -1c
.RI "\fBpixel\fP \fBsqrt\fP (\fBconst\fP \fBpixel\fP &x)"
.br
.ti -1c
.RI "\fBpixel\fP \fBsqrt_nth\fP (\fBconst\fP \fBpixel\fP &x, \fBint\fP index)"
.br
.ti -1c
.RI "\fBstring\fP \fBto_string\fP (\fBconst\fP \fBpOH\fP &x)"
.br
.ti -1c
.RI "\fBstring\fP \fBto_string\fP (\fBconst\fP \fBsize_2d\fP< \fBfloat\fP > &x)"
.br
.ti -1c
.RI "template<\fBtypename\fP T > \fBstring\fP \fBto_string\fP (\fBconst\fP \fBsize_2d\fP< T > &x)"
.br
.ti -1c
.RI "\fBstring\fP \fBto_string\fP (\fBconst\fP \fBsize_3d\fP< \fBfloat\fP > &x)"
.br
.ti -1c
.RI "template<\fBtypename\fP T > \fBstring\fP \fBto_string\fP (\fBconst\fP \fBsize_3d\fP< T > &x)"
.br
.ti -1c
.RI "\fBstring\fP \fBto_string\fP (\fBconst\fP \fBsize_nd\fP< \fBfloat\fP > &x)"
.br
.ti -1c
.RI "template<\fBtypename\fP T > \fBstring\fP \fBto_string\fP (\fBconst\fP \fBsize_nd\fP< T > &x)"
.br
.ti -1c
.RI "\fBstring\fP \fBto_string\fP (\fBconst\fP \fBzid\fP &x)"
.br
.ti -1c
.RI "\fBdirection::name\fP \fBcreate_direction\fP (\fBconst\fP \fBstring\fP &x)"
.br
.ti -1c
.RI "\fBdirection::name\fP \fBinvert\fP (\fBdirection::name\fP x)"
.br
.ti -1c
.RI "\fBstring\fP \fBto_string\fP (\fBdirection::name\fP x)"
.br
.ti -1c
.RI "\fBstring\fP \fBto_string\fP (\fBconst\fP \fBdirection\fP &x)"
.br
.ti -1c
.RI "\fBstring\fP \fBto_string\fP (\fBconst\fP \fBpoint_1d\fP< \fBfloat\fP > &x)"
.br
.ti -1c
.RI "\fBfloat\fP \fBdistance\fP (\fBconst\fP \fBpoint_1d\fP< \fBfloat\fP > &x, \fBconst\fP \fBpoint_1d\fP< \fBfloat\fP > &y)"
.br
.ti -1c
.RI "template<\fBtypename\fP T > \fBstring\fP \fBto_string\fP (\fBconst\fP \fBpoint_1d\fP< T > &x)"
.br
.ti -1c
.RI "template<\fBtypename\fP T , \fBtypename\fP \fBU\fP > T \fBdistance\fP (\fBconst\fP \fBpoint_1d\fP< T > &x, \fBconst\fP \fBpoint_1d\fP< \fBU\fP > &y)"
.br
.ti -1c
.RI "\fBstring\fP \fBto_string\fP (\fBconst\fP \fBpoint_2d\fP< \fBfloat\fP > &x)"
.br
.ti -1c
.RI "\fBfloat\fP \fBdistance\fP (\fBconst\fP \fBpoint_2d\fP< \fBfloat\fP > &x, \fBconst\fP \fBpoint_2d\fP< \fBfloat\fP > &y)"
.br
.ti -1c
.RI "template<\fBtypename\fP T > \fBstring\fP \fBto_string\fP (\fBconst\fP \fBpoint_2d\fP< T > &x)"
.br
.ti -1c
.RI "template<\fBtypename\fP T , \fBtypename\fP \fBU\fP > T \fBdistance\fP (\fBconst\fP \fBpoint_2d\fP< T > &x, \fBconst\fP \fBpoint_2d\fP< \fBU\fP > &y)"
.br
.ti -1c
.RI "\fBstring\fP \fBto_string\fP (\fBconst\fP \fBpoint_3d\fP< \fBfloat\fP > &x)"
.br
.ti -1c
.RI "\fBfloat\fP \fBdistance\fP (\fBconst\fP \fBpoint_3d\fP< \fBfloat\fP > &x, \fBconst\fP \fBpoint_3d\fP< \fBfloat\fP > &y)"
.br
.ti -1c
.RI "template<\fBtypename\fP T > \fBstring\fP \fBto_string\fP (\fBconst\fP \fBpoint_3d\fP< T > &x)"
.br
.ti -1c
.RI "template<\fBtypename\fP T , \fBtypename\fP \fBU\fP > T \fBdistance\fP (\fBconst\fP \fBpoint_3d\fP< T > &x, \fBconst\fP \fBpoint_3d\fP< \fBU\fP > &y)"
.br
.ti -1c
.RI "\fBstring\fP \fBto_string\fP (\fBconst\fP \fBpoint_nd\fP< \fBfloat\fP > &x)"
.br
.ti -1c
.RI "\fBfloat\fP \fBdistance\fP (\fBconst\fP \fBpoint_nd\fP< \fBfloat\fP > &x, \fBconst\fP \fBpoint_nd\fP< \fBfloat\fP > &y)"
.br
.ti -1c
.RI "template<\fBtypename\fP T > \fBstring\fP \fBto_string\fP (\fBconst\fP \fBpoint_nd\fP< T > &x)"
.br
.ti -1c
.RI "template<\fBtypename\fP T , \fBtypename\fP \fBU\fP > T \fBdistance\fP (\fBconst\fP \fBpoint_nd\fP< T > &\fBx1\fP, \fBconst\fP \fBpoint_nd\fP< \fBU\fP > &\fBx2\fP)"
.br
.ti -1c
.RI "\fBstring\fP \fBto_string\fP (\fBconst\fP \fBdimension\fP &x)"
.br
.ti -1c
.RI "\fBstring\fP \fBto_string\fP (\fBconst\fP vector< \fBdimension\fP > &\fBx_dimensions\fP, \fBbool\fP \fBwith_brackets\fP)"
.br
.ti -1c
.RI "vector< \fBdimension\fP > \fBcreate_dimensions\fP (\fBstring\fP \fBinit_dimensions\fP)"
.br
.ti -1c
.RI "vector< \fBdimension\fP > \fBcreate_derived_dimensions\fP (\fBconst\fP \fBstring\fP &\fBinit_dimensions\fP)"
.br
.ti -1c
.RI "vector< \fBdimension\fP > \fBcreate_derived_dimensions\fP (\fBconst\fP vector< \fBdimension\fP > &x)"
.br
.ti -1c
.RI "vector< \fBdimension\fP > \fBcreate_derived_dimensions\fP (\fBconst\fP vector< \fBdimension\fP > &x, \fBlong\fP \fBdouble\fP &value)"
.br
.ti -1c
.RI "vector< \fBdimension\fP > \fBmultiply_dimensions\fP (\fBconst\fP vector< \fBdimension\fP > &x, \fBconst\fP vector< \fBdimension\fP > &y)"
.br
.ti -1c
.RI "vector< \fBdimension\fP > \fBmultiply_dimensions\fP (vector< \fBdimension\fP > x, \fBconst\fP vector< \fBdimension\fP > &y, \fBlong\fP \fBdouble\fP &value)"
.br
.ti -1c
.RI "vector< \fBdimension\fP > \fBdivide_dimensions\fP (vector< \fBdimension\fP > x, \fBconst\fP vector< \fBdimension\fP > &y, \fBlong\fP \fBdouble\fP &value)"
.br
.ti -1c
.RI "vector< \fBdimension\fP > \fBsquare_dimensions\fP (vector< \fBdimension\fP > x, \fBlong\fP \fBdouble\fP &value, \fBint\fP index)"
.br
.ti -1c
.RI "vector< \fBdimension\fP > \fBpower_dimensions\fP (\fBconst\fP vector< \fBdimension\fP > &x, \fBint\fP \fBexponent\fP)"
.br
.ti -1c
.RI "vector< \fBdimension\fP > \fBnormalize_dimensions\fP (\fBconst\fP vector< \fBdimension\fP > &x)"
.br
.ti -1c
.RI "vector< \fBdimension\fP > \fBnormalize_dimensions\fP (\fBconst\fP vector< \fBdimension\fP > &x, \fBlong\fP \fBdouble\fP &value)"
.br
.ti -1c
.RI "\fBbool\fP \fBcommon_dimension\fP (\fBconst\fP \fBdimension\fP &x, \fBconst\fP \fBdimension\fP &y)"
.br
.ti -1c
.RI "\fBbool\fP \fBequal_dimensions\fP (\fBconst\fP \fBstring\fP &\fBinit_dimensions_x\fP, \fBconst\fP \fBstring\fP &\fBinit_dimensions_y\fP)"
.br
.ti -1c
.RI "\fBbool\fP \fBequal_dimensions\fP (\fBconst\fP vector< \fBdimension\fP > &x, \fBconst\fP vector< \fBdimension\fP > &y)"
.br
.ti -1c
.RI "\fBbool\fP \fBequal_dimensions_and_prefixes\fP (\fBconst\fP vector< \fBdimension\fP > &x, \fBconst\fP vector< \fBdimension\fP > &y)"
.br
.ti -1c
.RI "template<\fBtypename\fP T , \fBtypename\fP \fBU\fP > \fBstring\fP \fBto_string\fP (\fBconst\fP \fBmaterial_vector_unit_2d\fP< T, \fBU\fP > &x)"
.br
.ti -1c
.RI "\fBprefix::type\fP \fBprefix_string\fP (\fBconst\fP \fBstring\fP &x)"
.br
.ti -1c
.RI "\fBprefix\fP \fBclosest_prefix\fP (\fBconst\fP \fBprefix\fP &\fBactual_prefix\fP, \fBint\fP \fBactual_scale\fP)"
.br
.ti -1c
.RI "\fBprefix\fP \fBcreate_prefix_by_factor\fP (\fBint\fP factor)"
.br
.ti -1c
.RI "\fBstring\fP \fBto_string\fP (\fBconst\fP \fBscalar_unit\fP &x)"
.br
.RI "Generates an string from the \fBscalar_unit\fP, it uses the display of the \fBscalar_unit\fP with 2 decimals, without brackets and without a close prefix\&. "
.ti -1c
.RI "\fBbool\fP \fBis_scalar_unit\fP (\fBconst\fP \fBstring\fP &\fBinit_scalar\fP)"
.br
.RI "Checks if an string is an initialization string of a \fBscalar_unit\fP\&. "
.ti -1c
.RI "\fBfloat\fP \fBabs\fP (\fBconst\fP \fBscalar_unit\fP &x)"
.br
.RI "Returns the absolute value of the \fBscalar_unit\fP, without dimensions\&. "
.ti -1c
.RI "\fBscalar_unit\fP \fBpow\fP (\fBconst\fP \fBscalar_unit\fP &x, \fBint\fP \fBexponent\fP)"
.br
.RI "Exponentiates a \fBscalar_unit\fP to some numeric type, the dimensions are also exponentiated\&. "
.ti -1c
.RI "\fBscalar_unit\fP \fBsqrt\fP (\fBconst\fP \fBscalar_unit\fP &x)"
.br
.RI "Square root of a \fBscalar_unit\fP, it squares the dimensions too\&. "
.ti -1c
.RI "\fBscalar_unit\fP \fBsqrt_nth\fP (\fBconst\fP \fBscalar_unit\fP &x, \fBint\fP index)"
.br
.RI "Nth root of a \fBscalar_unit\fP to any numeric value, it squares the dimensions too\&. "
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (\fBlength\fP,'m')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (\fBtime_duration\fP,'s')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (\fBmass\fP,'g')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (\fBcharge\fP,'C')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (\fBtemperature\fP,'K')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (\fBmole\fP,'mol')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (\fBlight\fP,'cd')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (data,'B')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (\fBlength\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP_BEGIN\fP (\fBtime_duration\fP)"
.br
.ti -1c
.RI "\fBtime_duration\fP (\fBconst\fP \fBstring\fP &\fBinit_time\fP)"
.br
.ti -1c
.RI "\fBint\fP \fBget_years\fP () \fBconst\fP"
.br
.ti -1c
.RI "\fBint\fP \fBget_months\fP () \fBconst\fP"
.br
.ti -1c
.RI "\fBint\fP \fBget_weeks\fP () \fBconst\fP"
.br
.ti -1c
.RI "\fBint\fP \fBget_days\fP () \fBconst\fP"
.br
.ti -1c
.RI "\fBint\fP \fBget_hours\fP () \fBconst\fP"
.br
.ti -1c
.RI "\fBint\fP \fBget_minutes\fP () \fBconst\fP"
.br
.ti -1c
.RI "\fBint\fP \fBget_seconds\fP () \fBconst\fP"
.br
.ti -1c
.RI "\fBstring\fP \fBget_finish_date\fP () \fBconst\fP"
.br
.ti -1c
.RI "\fBstring\fP \fBdisplay_as_time\fP () \fBconst\fP"
.br
.ti -1c
.RI "\fBstring\fP \fBdisplay_years\fP () \fBconst\fP"
.br
.ti -1c
.RI "\fBstring\fP \fBdisplay_months\fP () \fBconst\fP"
.br
.ti -1c
.RI "\fBstring\fP \fBdisplay_weeks\fP () \fBconst\fP"
.br
.ti -1c
.RI "\fBstring\fP \fBdisplay_days\fP () \fBconst\fP"
.br
.ti -1c
.RI "\fBstring\fP \fBdisplay_hours\fP () \fBconst\fP"
.br
.ti -1c
.RI "\fBstring\fP \fBdisplay_minutes\fP () \fBconst\fP"
.br
.ti -1c
.RI "\fBstring\fP \fBdisplay_seconds\fP () \fBconst\fP"
.br
.ti -1c
.RI "template<\fBtypename\fP \fBT1\fP , \fBtypename\fP \fBT2\fP > \fBscifir::time_duration\fP & \fBoperator+=\fP (chrono::duration< \fBT1\fP, \fBT2\fP > x)"
.br
.ti -1c
.RI "template<\fBtypename\fP \fBT1\fP , \fBtypename\fP \fBT2\fP > \fBscifir::time_duration\fP & \fBoperator\-=\fP (chrono::duration< \fBT1\fP, \fBT2\fP > x)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP_BEGIN\fP (\fBmass\fP)"
.br
.ti -1c
.RI "\fBmass\fP (\fBconst\fP \fBpercentage\fP &\fBnew_percentage\fP, \fBconst\fP mass &\fBnew_mass\fP)"
.br
.ti -1c
.RI "\fBmass\fP (\fBconst\fP \fBstring\fP &\fBinit_percentage\fP, \fBconst\fP \fBstring\fP &\fBinit_mass\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (\fBcharge\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (\fBtemperature\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP_BEGIN\fP (\fBmole\fP)"
.br
.ti -1c
.RI "\fBmole\fP (\fBconst\fP \fBpercentage\fP &\fBnew_percentage\fP, \fBconst\fP mole &\fBnew_mole\fP)"
.br
.ti -1c
.RI "\fBmole\fP (\fBconst\fP \fBstring\fP &\fBinit_percentage\fP, \fBconst\fP \fBstring\fP &\fBinit_mole\fP)"
.br
.ti -1c
.RI "\fBint\fP \fBnumber_of_particles\fP () \fBconst\fP"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (\fBlight\fP)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (data)"
.br
.ti -1c
.RI "\fBscalar_unit\fP \fBnorm\fP (\fBconst\fP \fBvector_unit_2d\fP &x)"
.br
.ti -1c
.RI "\fBvector_unit_2d\fP \fBsqrt\fP (\fBconst\fP \fBvector_unit_2d\fP &x)"
.br
.ti -1c
.RI "\fBvector_unit_2d\fP \fBsqrt_nth\fP (\fBconst\fP \fBvector_unit_2d\fP &x, \fBint\fP index)"
.br
.ti -1c
.RI "\fBscalar_unit\fP \fBdot_product\fP (\fBconst\fP \fBvector_unit_2d\fP &x, \fBconst\fP \fBvector_unit_2d\fP &y)"
.br
.ti -1c
.RI "\fBangle\fP \fBangle_between\fP (\fBconst\fP \fBvector_unit_2d\fP &x, \fBconst\fP \fBvector_unit_2d\fP &y)"
.br
.ti -1c
.RI "\fBbool\fP \fBsame_direction\fP (\fBconst\fP \fBvector_unit_2d\fP &x, \fBconst\fP \fBvector_unit_2d\fP &y)"
.br
.ti -1c
.RI "\fBbool\fP \fBparallel\fP (\fBconst\fP \fBvector_unit_2d\fP &x, \fBconst\fP \fBvector_unit_2d\fP &y)"
.br
.ti -1c
.RI "\fBbool\fP \fBorthogonal\fP (\fBconst\fP \fBvector_unit_2d\fP &x, \fBconst\fP \fBvector_unit_2d\fP &y)"
.br
.ti -1c
.RI "\fBstring\fP \fBto_string\fP (\fBconst\fP \fBvector_unit_2d\fP &x)"
.br
.ti -1c
.RI "\fBscalar_unit\fP \fBnorm\fP (\fBconst\fP \fBvector_unit_3d\fP &x)"
.br
.ti -1c
.RI "\fBvector_unit_3d\fP \fBsqrt\fP (\fBconst\fP \fBvector_unit_3d\fP &x)"
.br
.ti -1c
.RI "\fBvector_unit_3d\fP \fBsqrt_nth\fP (\fBconst\fP \fBvector_unit_3d\fP &x, \fBint\fP index)"
.br
.ti -1c
.RI "\fBscalar_unit\fP \fBdot_product\fP (\fBconst\fP \fBvector_unit_3d\fP &x, \fBconst\fP \fBvector_unit_3d\fP &y)"
.br
.ti -1c
.RI "\fBvector_unit_3d\fP \fBcross_product\fP (\fBconst\fP \fBvector_unit_3d\fP &x, \fBconst\fP \fBvector_unit_3d\fP &y)"
.br
.ti -1c
.RI "\fBangle\fP \fBangle_between\fP (\fBconst\fP \fBvector_unit_3d\fP &x, \fBconst\fP \fBvector_unit_3d\fP &y)"
.br
.ti -1c
.RI "\fBbool\fP \fBsame_direction\fP (\fBconst\fP \fBvector_unit_3d\fP &x, \fBconst\fP \fBvector_unit_3d\fP &y)"
.br
.ti -1c
.RI "\fBbool\fP \fBparallel\fP (\fBconst\fP \fBvector_unit_3d\fP &x, \fBconst\fP \fBvector_unit_3d\fP &y)"
.br
.ti -1c
.RI "\fBbool\fP \fBorthogonal\fP (\fBconst\fP \fBvector_unit_3d\fP &x, \fBconst\fP \fBvector_unit_3d\fP &y)"
.br
.ti -1c
.RI "\fBstring\fP \fBto_string\fP (\fBconst\fP \fBvector_unit_3d\fP &x)"
.br
.ti -1c
.RI "\fBstring\fP \fBto_string\fP (\fBconst\fP \fBvector_unit_nd\fP &x)"
.br
.ti -1c
.RI "\fBscalar_unit\fP \fBnorm\fP (\fBconst\fP \fBvector_unit_nd\fP &x)"
.br
.ti -1c
.RI "\fBvector_unit_nd\fP \fBsqrt\fP (\fBconst\fP \fBvector_unit_nd\fP &x)"
.br
.ti -1c
.RI "\fBvector_unit_nd\fP \fBsqrt_nth\fP (\fBconst\fP \fBvector_unit_nd\fP &x, \fBint\fP index)"
.br
.ti -1c
.RI "\fBscalar_unit\fP \fBdot_product\fP (\fBconst\fP \fBvector_unit_nd\fP &x, \fBconst\fP \fBvector_unit_nd\fP &y)"
.br
.ti -1c
.RI "\fBvector_unit_nd\fP \fBcross_product\fP (\fBconst\fP \fBvector_unit_nd\fP &x, \fBconst\fP \fBvector_unit_nd\fP &y)"
.br
.ti -1c
.RI "\fBangle\fP \fBangle_between\fP (\fBconst\fP \fBvector_unit_nd\fP &x, \fBconst\fP \fBvector_unit_nd\fP &y)"
.br
.ti -1c
.RI "\fBbool\fP \fBsame_nd\fP (\fBconst\fP \fBvector_unit_nd\fP &x, \fBconst\fP \fBvector_unit_nd\fP &y)"
.br
.ti -1c
.RI "\fBbool\fP \fBsame_direction\fP (\fBconst\fP \fBvector_unit_nd\fP &x, \fBconst\fP \fBvector_unit_nd\fP &y)"
.br
.ti -1c
.RI "\fBbool\fP \fBparallel\fP (\fBconst\fP \fBvector_unit_nd\fP &x, \fBconst\fP \fBvector_unit_nd\fP &y)"
.br
.ti -1c
.RI "\fBbool\fP \fBorthogonal\fP (\fBconst\fP \fBvector_unit_nd\fP &x, \fBconst\fP \fBvector_unit_nd\fP &y)"
.br
.ti -1c
.RI "\fBfloat\fP \fBparse_float\fP (\fBconst\fP \fBstring\fP &x)"
.br
.ti -1c
.RI "\fBint\fP \fBparse_int\fP (\fBconst\fP \fBstring\fP &x)"
.br
.ti -1c
.RI "\fBstring\fP \fBdisplay_float\fP (\fBconst\fP \fBfloat\fP &value, \fBint\fP \fBnumber_of_decimals\fP)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "\fBangle\fP \fBcoordinates_ndr_no_angle\fP = \fBangle\fP()"
.br
.ti -1c
.RI "\fBconstexpr\fP \fBfloat\fP \fBPI\fP = boost::math::constants::pi<\fBfloat\fP>()"
.br
.ti -1c
.RI "\fBstatic\fP \fBconst\fP \fBlong\fP \fBdouble\fP \fBAVOGADRO_CONSTANT\fP = 6\&.02214076\fBe23\fP"
.br
.ti -1c
.RI "\fBmap\fP< \fBstring\fP, \fBconversion\fP > \fBget_conversion\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
The namespace scifir contains all scifir-units, excepting the string literals, which are outside\&. 
.SH "Typedef Documentation"
.PP 
.SS "\fBtypedef\fP \fBlength\fP \fBscifir::wavelength\fP"

.PP
Definition at line \fB93\fP of file \fBphysics_units\&.hpp\fP\&.
.SH "Enumeration Type Documentation"
.PP 
.SS "\fBenum\fP \fBclass\fP \fBscifir::alert_state\fP\fC [strong]\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIVIGIL \fP\fP
.TP
\fB\fISLEEP \fP\fP
.TP
\fB\fIMEDITATION \fP\fP
.PP
Definition at line \fB10\fP of file \fBmind\&.hpp\fP\&..PP
.nf
10 { VIGIL, SLEEP, MEDITATION };
.fi

.SS "\fBenum\fP \fBclass\fP \fBscifir::astronomical_body\fP : \fBint8_t\fP\fC [strong]\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fINONE \fP\fP
.TP
\fB\fIMILKY_WAY \fP\fP
.TP
\fB\fIANDROMEDA \fP\fP
.TP
\fB\fISOLAR_SYSTEM \fP\fP
.TP
\fB\fISUN \fP\fP
.TP
\fB\fIMOON \fP\fP
.TP
\fB\fIMERCURY \fP\fP
.TP
\fB\fIVENUS \fP\fP
.TP
\fB\fIEARTH \fP\fP
.TP
\fB\fIMARS \fP\fP
.TP
\fB\fIJUPITER \fP\fP
.TP
\fB\fISATURN \fP\fP
.TP
\fB\fIURANUS \fP\fP
.TP
\fB\fINEPTUNE \fP\fP
.TP
\fB\fICERES \fP\fP
.TP
\fB\fIORCUS \fP\fP
.TP
\fB\fIPLUTO \fP\fP
.TP
\fB\fIHAUMEA \fP\fP
.TP
\fB\fIQUAOAR \fP\fP
.TP
\fB\fIMAKEMAKE \fP\fP
.TP
\fB\fIGONGGONG \fP\fP
.TP
\fB\fIERIS \fP\fP
.TP
\fB\fISEDNA \fP\fP
.TP
\fB\fIIO \fP\fP
.TP
\fB\fIEUROPA \fP\fP
.TP
\fB\fIGANYMEDE \fP\fP
.TP
\fB\fICALLISTO \fP\fP
.TP
\fB\fIMIMAS \fP\fP
.TP
\fB\fIENCELADUS \fP\fP
.TP
\fB\fITETHYS \fP\fP
.TP
\fB\fIDIONE \fP\fP
.TP
\fB\fIRHEA \fP\fP
.TP
\fB\fITITAN \fP\fP
.TP
\fB\fIIAPETUS \fP\fP
.TP
\fB\fIMIRANDA \fP\fP
.TP
\fB\fIARIEL \fP\fP
.TP
\fB\fIUMBRIEL \fP\fP
.TP
\fB\fITITANIA \fP\fP
.TP
\fB\fIOBERON \fP\fP
.TP
\fB\fITRITON \fP\fP
.TP
\fB\fICHARON \fP\fP
.TP
\fB\fIDYSNOMIA \fP\fP
.PP
Definition at line \fB11\fP of file \fBaid\&.hpp\fP\&..PP
.nf
11 : int8_t {NONE,MILKY_WAY,ANDROMEDA,SOLAR_SYSTEM,SUN,MOON,MERCURY,VENUS,EARTH,MARS,JUPITER,SATURN,URANUS,NEPTUNE,CERES,ORCUS,PLUTO,HAUMEA,QUAOAR,MAKEMAKE,GONGGONG,ERIS,SEDNA,IO,EUROPA,GANYMEDE,CALLISTO,MIMAS,ENCELADUS,TETHYS,DIONE,RHEA,TITAN,IAPETUS,MIRANDA,ARIEL,UMBRIEL,TITANIA,OBERON,TRITON,CHARON,DYSNOMIA};
.fi

.SS "\fBenum\fP \fBclass\fP \fBscifir::body_health\fP\fC [strong]\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIHEALTHY \fP\fP
.TP
\fB\fIDAMAGED \fP\fP
.TP
\fB\fISICK \fP\fP
.TP
\fB\fISICK_AND_DAMAGED \fP\fP
.PP
Definition at line \fB12\fP of file \fBbody\&.hpp\fP\&..PP
.nf
12 { HEALTHY, DAMAGED, SICK, SICK_AND_DAMAGED };
.fi

.SS "\fBenum\fP \fBclass\fP \fBscifir::conscience_state\fP\fC [strong]\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fINORMAL \fP\fP
.TP
\fB\fIALTERED \fP\fP
.PP
Definition at line \fB18\fP of file \fBmind\&.hpp\fP\&..PP
.nf
18 { NORMAL, ALTERED };
.fi

.SS "\fBenum\fP \fBclass\fP \fBscifir::emotion\fP\fC [strong]\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIHAPPY \fP\fP
.TP
\fB\fIEXCITED \fP\fP
.TP
\fB\fITENDER \fP\fP
.TP
\fB\fISCARED \fP\fP
.TP
\fB\fIANGRY \fP\fP
.TP
\fB\fISAD \fP\fP
.PP
Definition at line \fB14\fP of file \fBmind\&.hpp\fP\&..PP
.nf
14 { HAPPY, EXCITED, TENDER, SCARED, ANGRY, SAD };
.fi

.SS "\fBenum\fP \fBclass\fP \fBscifir::feeling\fP\fC [strong]\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fISADNESS \fP\fP
.TP
\fB\fIRANCOR \fP\fP
.TP
\fB\fILOVE \fP\fP
.PP
Definition at line \fB12\fP of file \fBmind\&.hpp\fP\&..PP
.nf
12 { SADNESS, RANCOR, LOVE };
.fi

.SS "\fBenum\fP \fBclass\fP \fBscifir::movement\fP\fC [strong]\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fISTILL \fP\fP
.TP
\fB\fIWALK \fP\fP
.TP
\fB\fIRUN \fP\fP
.TP
\fB\fISWIM \fP\fP
.TP
\fB\fICLIMB \fP\fP
.TP
\fB\fIFLY \fP\fP
.PP
Definition at line \fB8\fP of file \fBbody\&.hpp\fP\&..PP
.nf
8 { STILL, WALK, RUN, SWIM, CLIMB, FLY };
.fi

.SS "\fBenum\fP \fBclass\fP \fBscifir::movement_state\fP\fC [strong]\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fISTILL \fP\fP
.TP
\fB\fIACTIVE \fP\fP
.PP
Definition at line \fB10\fP of file \fBbody\&.hpp\fP\&..PP
.nf
10 { STILL, ACTIVE };
.fi

.SS "\fBenum\fP \fBclass\fP \fBscifir::sensation\fP\fC [strong]\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fILIGHT \fP\fP
.TP
\fB\fISOUND \fP\fP
.TP
\fB\fIACCELERATION \fP\fP
.TP
\fB\fIODOR \fP\fP
.TP
\fB\fITASTE \fP\fP
.TP
\fB\fITOUCH \fP\fP
.TP
\fB\fITEMPERATURE \fP\fP
.PP
Definition at line \fB16\fP of file \fBmind\&.hpp\fP\&..PP
.nf
16 { LIGHT, SOUND, ACCELERATION, ODOR, TASTE, TOUCH, TEMPERATURE };
.fi

.SH "Function Documentation"
.PP 
.SS "template<\fBtypename\fP T > T scifir::abs (\fBconst\fP \fBcomplex_number\fP< T > & x)"

.PP
Definition at line \fB182\fP of file \fBcomplex_number\&.hpp\fP\&..PP
.nf
183     {
184         return scifir::sqrt((x\&.real^2) + (x\&.imaginary^2));
185     }
.fi

.SS "\fBfloat\fP scifir::abs (\fBconst\fP \fBscalar_unit\fP & x)"

.PP
Returns the absolute value of the \fBscalar_unit\fP, without dimensions\&. 
.PP
Definition at line \fB720\fP of file \fBscalar_unit\&.cpp\fP\&..PP
.nf
721     {
722         return std::abs(x\&.get_value());
723     }
.fi

.SS "\fBangle\fP scifir::acos (\fBfloat\fP x)"

.PP
Definition at line \fB334\fP of file \fBangle\&.cpp\fP\&..PP
.nf
335     {
336         return angle(radian_to_grade(std::acos(x)));
337     }
.fi

.SS "\fBfloat\fP scifir::acos_grade (\fBfloat\fP x)\fC [inline]\fP"

.PP
Definition at line \fB191\fP of file \fBangle\&.hpp\fP\&..PP
.nf
192     {
193         return radian_to_grade(std::acos(x));
194     }
.fi

.SS "\fBangle\fP scifir::acosh (\fBfloat\fP x)"

.PP
Definition at line \fB364\fP of file \fBangle\&.cpp\fP\&..PP
.nf
365     {
366         return angle(radian_to_grade(std::acosh(x)));
367     }
.fi

.SS "\fBfloat\fP scifir::acosh_grade (\fBfloat\fP x)\fC [inline]\fP"

.PP
Definition at line \fB206\fP of file \fBangle\&.hpp\fP\&..PP
.nf
207     {
208         return radian_to_grade(std::acosh(x));
209     }
.fi

.SS "\fBangle\fP scifir::angle_between (\fBconst\fP \fBvector_unit_2d\fP & x, \fBconst\fP \fBvector_unit_2d\fP & y)"

.PP
Definition at line \fB345\fP of file \fBvector_unit_2d\&.cpp\fP\&..PP
.nf
346     {
347         return angle(radian_to_grade(std::atan2(float(y\&.y_projection() * x\&.x_projection() \- y\&.x_projection() * x\&.y_projection()),float(y\&.x_projection() * x\&.x_projection() + y\&.y_projection() * x\&.y_projection()))));
348     }
.fi

.SS "\fBangle\fP scifir::angle_between (\fBconst\fP \fBvector_unit_3d\fP & x, \fBconst\fP \fBvector_unit_3d\fP & y)"

.PP
Definition at line \fB472\fP of file \fBvector_unit_3d\&.cpp\fP\&..PP
.nf
473     {
474         return scifir::acos(float(dot_product(x,y)/(norm(x)*norm(y))));
475     }
.fi

.SS "\fBangle\fP scifir::angle_between (\fBconst\fP \fBvector_unit_nd\fP & x, \fBconst\fP \fBvector_unit_nd\fP & y)"

.PP
Definition at line \fB799\fP of file \fBvector_unit_nd\&.cpp\fP\&..PP
.nf
800     {
801         return scifir::acos(float(dot_product(x,y)/(norm(x) * norm(y))));
802     }
.fi

.SS "scifir::area::area (\fBconst\fP \fBsize_2d\fP< \fBlength\fP > & x)\fC [explicit]\fP"

.PP
Definition at line \fB13\fP of file \fBspace_units\&.cpp\fP\&..PP
.nf
13                                        : scalar_unit()
14     {
15         length x_height = x\&.height;
16         x_height\&.change_dimensions(x\&.width);
17         *this = x\&.width * x_height;
18     }
.fi

.SS "\fBangle\fP scifir::asin (\fBfloat\fP x)"

.PP
Definition at line \fB329\fP of file \fBangle\&.cpp\fP\&..PP
.nf
330     {
331         return angle(radian_to_grade(std::asin(x)));
332     }
.fi

.SS "\fBfloat\fP scifir::asin_grade (\fBfloat\fP x)\fC [inline]\fP"

.PP
Definition at line \fB186\fP of file \fBangle\&.hpp\fP\&..PP
.nf
187     {
188         return radian_to_grade(std::asin(x));
189     }
.fi

.SS "\fBangle\fP scifir::asinh (\fBfloat\fP x)"

.PP
Definition at line \fB359\fP of file \fBangle\&.cpp\fP\&..PP
.nf
360     {
361         return angle(radian_to_grade(std::asinh(x)));
362     }
.fi

.SS "\fBfloat\fP scifir::asinh_grade (\fBfloat\fP x)\fC [inline]\fP"

.PP
Definition at line \fB201\fP of file \fBangle\&.hpp\fP\&..PP
.nf
202     {
203         return radian_to_grade(std::asinh(x));
204     }
.fi

.SS "\fBangle\fP scifir::atan (\fBfloat\fP x)"

.PP
Definition at line \fB339\fP of file \fBangle\&.cpp\fP\&..PP
.nf
340     {
341         return angle(radian_to_grade(std::atan(x)));
342     }
.fi

.SS "\fBfloat\fP scifir::atan_grade (\fBfloat\fP x)\fC [inline]\fP"

.PP
Definition at line \fB196\fP of file \fBangle\&.hpp\fP\&..PP
.nf
197     {
198         return radian_to_grade(std::atan(x));
199     }
.fi

.SS "\fBangle\fP scifir::atanh (\fBfloat\fP x)"

.PP
Definition at line \fB369\fP of file \fBangle\&.cpp\fP\&..PP
.nf
370     {
371         return angle(radian_to_grade(std::atanh(x)));
372     }
.fi

.SS "\fBfloat\fP scifir::atanh_grade (\fBfloat\fP x)\fC [inline]\fP"

.PP
Definition at line \fB211\fP of file \fBangle\&.hpp\fP\&..PP
.nf
212     {
213         return radian_to_grade(std::atanh(x));
214     }
.fi

.SS "\fBscalar_unit\fP scifir::cartesian_2d_to_polar_p (\fBconst\fP \fBscalar_unit\fP & x, \fBscalar_unit\fP y)\fC [inline]\fP"

.PP
Definition at line \fB374\fP of file \fBcoordinates_2d\&.hpp\fP\&..PP
.nf
375     {
376         y\&.change_dimensions(x);
377         return scalar_unit(std::sqrt(std::pow(float(x),2) + std::pow(float(y),2)),x\&.get_dimensions());
378     }
.fi

.SS "\fBfloat\fP scifir::cartesian_2d_to_polar_p (\fBfloat\fP x, \fBfloat\fP y)\fC [inline]\fP"

.PP
Definition at line \fB396\fP of file \fBcoordinates_2d\&.hpp\fP\&..PP
.nf
397     {
398         return float(std::sqrt(std::pow(x,2) + std::pow(y,2)));
399     }
.fi

.SS "\fBangle\fP scifir::cartesian_2d_to_polar_theta (\fBconst\fP \fBscalar_unit\fP & x, \fBscalar_unit\fP y)\fC [inline]\fP"

.PP
Definition at line \fB380\fP of file \fBcoordinates_2d\&.hpp\fP\&..PP
.nf
381     {
382         y\&.change_dimensions(x);
383         return scifir::angle(scifir::atan_grade(float(y)/float(x)));
384     }
.fi

.SS "\fBangle\fP scifir::cartesian_2d_to_polar_theta (\fBfloat\fP x, \fBfloat\fP y)\fC [inline]\fP"

.PP
Definition at line \fB401\fP of file \fBcoordinates_2d\&.hpp\fP\&..PP
.nf
402     {
403         return scifir::angle(scifir::atan_grade(y/x));
404     }
.fi

.SS "\fBscalar_unit\fP scifir::cartesian_3d_to_cylindrical_p (\fBconst\fP \fBscalar_unit\fP & x, \fBscalar_unit\fP y, \fBconst\fP \fBscalar_unit\fP & z)\fC [inline]\fP"

.PP
Definition at line \fB616\fP of file \fBcoordinates_3d\&.hpp\fP\&..PP
.nf
617     {
618         y\&.change_dimensions(x);
619         return scalar_unit(std::sqrt(std::pow(float(x),2) + std::pow(float(y),2)),x\&.get_dimensions());
620     }
.fi

.SS "\fBfloat\fP scifir::cartesian_3d_to_cylindrical_p (\fBfloat\fP x, \fBfloat\fP y, \fBfloat\fP z)\fC [inline]\fP"

.PP
Definition at line \fB715\fP of file \fBcoordinates_3d\&.hpp\fP\&..PP
.nf
716     {
717         return float(std::sqrt(std::pow(x,2) + std::pow(y,2)));
718     }
.fi

.SS "\fBangle\fP scifir::cartesian_3d_to_cylindrical_theta (\fBconst\fP \fBscalar_unit\fP & x, \fBscalar_unit\fP y, \fBconst\fP \fBscalar_unit\fP & z)\fC [inline]\fP"

.PP
Definition at line \fB622\fP of file \fBcoordinates_3d\&.hpp\fP\&..PP
.nf
623     {
624         y\&.change_dimensions(x);
625         return angle(scifir::atan_grade(float(y) / float(x)));
626     }
.fi

.SS "\fBangle\fP scifir::cartesian_3d_to_cylindrical_theta (\fBfloat\fP x, \fBfloat\fP y, \fBfloat\fP z)\fC [inline]\fP"

.PP
Definition at line \fB720\fP of file \fBcoordinates_3d\&.hpp\fP\&..PP
.nf
721     {
722         return angle(scifir::atan_grade(y / x));
723     }
.fi

.SS "\fBscalar_unit\fP scifir::cartesian_3d_to_cylindrical_z (\fBconst\fP \fBscalar_unit\fP & x, \fBconst\fP \fBscalar_unit\fP & y, \fBconst\fP \fBscalar_unit\fP & z)\fC [inline]\fP"

.PP
Definition at line \fB628\fP of file \fBcoordinates_3d\&.hpp\fP\&..PP
.nf
629     {
630         return z;
631     }
.fi

.SS "\fBfloat\fP scifir::cartesian_3d_to_cylindrical_z (\fBfloat\fP x, \fBfloat\fP y, \fBfloat\fP z)\fC [inline]\fP"

.PP
Definition at line \fB725\fP of file \fBcoordinates_3d\&.hpp\fP\&..PP
.nf
726     {
727         return z;
728     }
.fi

.SS "\fBangle\fP scifir::cartesian_3d_to_spherical_phi (\fBconst\fP \fBscalar_unit\fP & x, \fBscalar_unit\fP y, \fBscalar_unit\fP z)\fC [inline]\fP"

.PP
Definition at line \fB646\fP of file \fBcoordinates_3d\&.hpp\fP\&..PP
.nf
647     {
648         y\&.change_dimensions(x);
649         z\&.change_dimensions(x);
650         return angle(scifir::acos_grade(float(z) / float(std::sqrt(std::pow(float(x),2) + std::pow(float(y),2) + std::pow(float(z),2)))));
651     }
.fi

.SS "\fBangle\fP scifir::cartesian_3d_to_spherical_phi (\fBfloat\fP x, \fBfloat\fP y, \fBfloat\fP z)\fC [inline]\fP"

.PP
Definition at line \fB740\fP of file \fBcoordinates_3d\&.hpp\fP\&..PP
.nf
741     {
742         return angle(scifir::acos_grade(z / float(std::sqrt(std::pow(x,2) + std::pow(y,2) + std::pow(z,2)))));
743     }
.fi

.SS "\fBscalar_unit\fP scifir::cartesian_3d_to_spherical_r (\fBconst\fP \fBscalar_unit\fP & x, \fBscalar_unit\fP y, \fBscalar_unit\fP z)\fC [inline]\fP"

.PP
Definition at line \fB633\fP of file \fBcoordinates_3d\&.hpp\fP\&..PP
.nf
634     {
635         y\&.change_dimensions(x);
636         z\&.change_dimensions(x);
637         return scalar_unit(std::sqrt(std::pow(float(x),2) + std::pow(float(y),2) + std::pow(float(z),2)),x\&.get_dimensions());
638     }
.fi

.SS "\fBfloat\fP scifir::cartesian_3d_to_spherical_r (\fBfloat\fP x, \fBfloat\fP y, \fBfloat\fP z)\fC [inline]\fP"

.PP
Definition at line \fB730\fP of file \fBcoordinates_3d\&.hpp\fP\&..PP
.nf
731     {
732         return float(std::sqrt(std::pow(x,2) + std::pow(y,2) + std::pow(z,2)));
733     }
.fi

.SS "\fBangle\fP scifir::cartesian_3d_to_spherical_theta (\fBconst\fP \fBscalar_unit\fP & x, \fBscalar_unit\fP y, \fBconst\fP \fBscalar_unit\fP & z)\fC [inline]\fP"

.PP
Definition at line \fB640\fP of file \fBcoordinates_3d\&.hpp\fP\&..PP
.nf
641     {
642         y\&.change_dimensions(x);
643         return angle(scifir::atan_grade(float(y) / float(x)));
644     }
.fi

.SS "\fBangle\fP scifir::cartesian_3d_to_spherical_theta (\fBfloat\fP x, \fBfloat\fP y, \fBfloat\fP z)\fC [inline]\fP"

.PP
Definition at line \fB735\fP of file \fBcoordinates_3d\&.hpp\fP\&..PP
.nf
736     {
737         return angle(scifir::atan_grade(y / x));
738     }
.fi

.SS "\fBprefix\fP scifir::closest_prefix (\fBconst\fP \fBprefix\fP & actual_prefix, \fBint\fP actual_scale)"

.PP
Definition at line \fB283\fP of file \fBprefix\&.cpp\fP\&..PP
.nf
284     {
285         int factor_difference = actual_scale + actual_prefix\&.get_conversion_factor();
286         return create_prefix_by_factor(factor_difference);
287         
288     }
.fi

.SS "\fBbool\fP scifir::common_dimension (\fBconst\fP \fBdimension\fP & x, \fBconst\fP \fBdimension\fP & y)"

.PP
Definition at line \fB1614\fP of file \fBdimension\&.cpp\fP\&..PP
.nf
1615     {
1616         for (const dimension& x_dimension : x\&.get_basic_dimensions())
1617         {
1618             for (const dimension& y_dimension : y\&.get_basic_dimensions())
1619             {
1620                 if (x_dimension == y_dimension)
1621                 {
1622                     return true;
1623                 }
1624             }
1625         }
1626         return false;
1627     }
.fi

.SS "\fBfloat\fP scifir::cos (\fBconst\fP \fBangle\fP & x)"

.PP
Definition at line \fB319\fP of file \fBangle\&.cpp\fP\&..PP
.nf
320     {
321         return std::cos(x\&.get_radian());
322     }
.fi

.SS "\fBfloat\fP scifir::cosh (\fBconst\fP \fBangle\fP & x)"

.PP
Definition at line \fB349\fP of file \fBangle\&.cpp\fP\&..PP
.nf
350     {
351         return std::cosh(x\&.get_radian());
352     }
.fi

.SS "\fBaid::type\fP scifir::create_astronomical_type (\fBconst\fP \fBstring\fP & astronomical_type_abbreviation)"

.PP
Definition at line \fB501\fP of file \fBaid\&.cpp\fP\&..PP
.nf
502     {
503         if (astronomical_type_abbreviation == "U")
504         {
505             return aid::UNIVERSE;
506         }
507         else if (astronomical_type_abbreviation == "G")
508         {
509             return aid::GALAXY;
510         }
511         else if (astronomical_type_abbreviation == "SS")
512         {
513             return aid::SOLAR_SYSTEM;
514         }
515         else if (astronomical_type_abbreviation == "P")
516         {
517             return aid::PLANET;
518         }
519         else if (astronomical_type_abbreviation == "ST")
520         {
521             return aid::STAR;
522         }
523         else if (astronomical_type_abbreviation == "A")
524         {
525             return aid::ASTEROID;
526         }
527         else if (astronomical_type_abbreviation == "MN")
528         {
529             return aid::MOON;
530         }
531         else if (astronomical_type_abbreviation == "MT")
532         {
533             return aid::METEOR;
534         }
535         else
536         {
537             return aid::NONE;
538         }
539     }
.fi

.SS "vector< \fBdimension\fP > scifir::create_derived_dimensions (\fBconst\fP \fBstring\fP & init_dimensions)"

.PP
Definition at line \fB1327\fP of file \fBdimension\&.cpp\fP\&..PP
.nf
1328     {
1329         vector<dimension> new_dimensions = create_dimensions(init_dimensions);
1330         return create_derived_dimensions(new_dimensions);
1331     }
.fi

.SS "vector< \fBdimension\fP > scifir::create_derived_dimensions (\fBconst\fP vector< \fBdimension\fP > & x)"

.PP
Definition at line \fB1333\fP of file \fBdimension\&.cpp\fP\&..PP
.nf
1334     {
1335         vector<dimension> new_x = vector<dimension>();
1336         for(unsigned int i = 0; i < x\&.size(); i++)
1337         {
1338             vector<dimension> x_subdimensions = x[i]\&.get_basic_dimensions();
1339             for (dimension& x_subdimension : x_subdimensions)
1340             {
1341                 if (x[i]\&.dimension_sign == dimension::DENOMINATOR)
1342                 {
1343                     x_subdimension\&.invert();
1344                 }
1345                 new_x\&.push_back(x_subdimension);
1346             }
1347         }
1348         return new_x;
1349     }
.fi

.SS "vector< \fBdimension\fP > scifir::create_derived_dimensions (\fBconst\fP vector< \fBdimension\fP > & x, \fBlong\fP \fBdouble\fP & value)"

.PP
Definition at line \fB1351\fP of file \fBdimension\&.cpp\fP\&..PP
.nf
1352     {
1353         vector<dimension> new_x = vector<dimension>();
1354         for(unsigned int i = 0; i < x\&.size(); i++)
1355         {
1356             if (x[i]\&.dimension_sign == dimension::NUMERATOR)
1357             {
1358                 value *= x[i]\&.get_conversion_factor();
1359                 value *= x[i]\&.prefix_math();
1360             }
1361             else if (x[i]\&.dimension_sign == dimension::DENOMINATOR)
1362             {
1363                 value /= x[i]\&.get_conversion_factor();
1364                 value /= x[i]\&.prefix_math();
1365             }
1366             vector<dimension> x_subdimensions = x[i]\&.get_basic_dimensions();
1367             for (dimension& x_subdimension : x_subdimensions)
1368             {
1369                 if (x[i]\&.dimension_sign == dimension::DENOMINATOR)
1370                 {
1371                     x_subdimension\&.invert();
1372                 }
1373                 new_x\&.push_back(x_subdimension);
1374             }
1375         }
1376         return new_x;
1377     }
.fi

.SS "vector< \fBdimension\fP > scifir::create_dimensions (\fBstring\fP init_dimensions)"

.PP
Definition at line \fB1277\fP of file \fBdimension\&.cpp\fP\&..PP
.nf
1278     {
1279         boost::algorithm::erase_all(init_dimensions, " ");
1280         dimension::position new_sign = dimension::NUMERATOR;
1281         int new_scale = 1;
1282         int new_size = 1;
1283         int new_start = 0;
1284         string new_dimension_str;
1285         vector<dimension> dimensions = vector<dimension>();
1286         for(unsigned int j = 0; j < init_dimensions\&.size(); j++)
1287         {
1288             if(init_dimensions[j] == '1' and init_dimensions[j + 1] == '/')
1289             {
1290                 new_sign = dimension::DENOMINATOR;
1291             }
1292             if(isalpha(init_dimensions[j]) and (!isalpha(init_dimensions[j + 1]) or (j + 1) == init_dimensions\&.size()))
1293             {
1294                 new_dimension_str = init_dimensions\&.substr(new_start, new_size);
1295                 if(isdigit(init_dimensions[j + 1]))
1296                 {
1297                     new_scale = stoi(init_dimensions\&.substr(j + 1, 1));
1298                 }
1299             }
1300             if(init_dimensions[j] == '*')
1301             {
1302                 new_size = 0;
1303                 new_start = j + 1;
1304             }
1305             else if(init_dimensions[j] == '/')
1306             {
1307                 new_sign = dimension::DENOMINATOR;
1308                 new_size = 0;
1309                 new_start = j + 1;
1310             }
1311             if(!new_dimension_str\&.empty())
1312             {
1313                 dimension new_dimension = dimension(new_dimension_str,new_sign);
1314                 for (int k = 0; k < new_scale; k++)
1315                 {
1316                     dimensions\&.push_back(new_dimension);
1317                 }
1318                 new_dimension_str\&.clear();
1319                 new_scale = 1;
1320                 new_size = 0;
1321             }
1322             new_size++;
1323         }
1324         return dimensions;
1325     }
.fi

.SS "\fBdirection::name\fP scifir::create_direction (\fBconst\fP \fBstring\fP & x)"

.PP
Definition at line \fB55\fP of file \fBdirection\&.cpp\fP\&..PP
.nf
56     {
57         if (x == "left")
58         {
59             return direction::LEFT;
60         }
61         else if (x == "right")
62         {
63             return direction::RIGHT;
64         }
65         else if (x == "top")
66         {
67             return direction::TOP;
68         }
69         else if (x == "bottom")
70         {
71             return direction::BOTTOM;
72         }
73         else if (x == "front")
74         {
75             return direction::FRONT;
76         }
77         else if (x == "back")
78         {
79             return direction::BACK;
80         }
81         else if (x == "left\-top")
82         {
83             return direction::LEFT_TOP;
84         }
85         else if (x == "left\-bottom")
86         {
87             return direction::LEFT_BOTTOM;
88         }
89         else if (x == "right\-top")
90         {
91             return direction::RIGHT_TOP;
92         }
93         else if (x == "right\-bottom")
94         {
95             return direction::RIGHT_BOTTOM;
96         }
97         else if (x == "left\-front")
98         {
99             return direction::LEFT_FRONT;
100         }
101         else if (x == "left\-back")
102         {
103             return direction::LEFT_BACK;
104         }
105         else if (x == "right\-front")
106         {
107             return direction::RIGHT_FRONT;
108         }
109         else if (x == "right\-back")
110         {
111             return direction::RIGHT_BACK;
112         }
113         else if (x == "top\-front")
114         {
115             return direction::TOP_FRONT;
116         }
117         else if (x == "top\-back")
118         {
119             return direction::TOP_BACK;
120         }
121         else if (x == "bottom\-front")
122         {
123             return direction::BOTTOM_FRONT;
124         }
125         else if (x == "bottom\-back")
126         {
127             return direction::BOTTOM_BACK;
128         }
129         else if (x == "left\-top\-front")
130         {
131             return direction::LEFT_TOP_FRONT;
132         }
133         else if (x == "left\-top\-back")
134         {
135             return direction::LEFT_TOP_BACK;
136         }
137         else if (x == "left\-bottom\-front")
138         {
139             return direction::LEFT_BOTTOM_FRONT;
140         }
141         else if (x == "left\-bottom\-back")
142         {
143             return direction::LEFT_BOTTOM_BACK;
144         }
145         else if (x == "right\-top\-front")
146         {
147             return direction::RIGHT_TOP_FRONT;
148         }
149         else if (x == "right\-top\-back")
150         {
151             return direction::RIGHT_TOP_BACK;
152         }
153         else if (x == "right\-bottom\-front")
154         {
155             return direction::RIGHT_BOTTOM_FRONT;
156         }
157         else if (x == "right\-bottom\-back")
158         {
159             return direction::RIGHT_BOTTOM_BACK;
160         }
161         else
162         {
163             return direction::NONE;
164         }
165     }
.fi

.SS "\fBprefix\fP scifir::create_prefix_by_factor (\fBint\fP factor)"

.PP
Definition at line \fB290\fP of file \fBprefix\&.cpp\fP\&..PP
.nf
291     {
292         if (factor == 0)
293         {
294             return prefix(prefix::no_prefix);
295         }
296         else if (factor == 1)
297         {
298             return prefix(prefix::da);
299         }
300         else if (factor == 2)
301         {
302             return prefix(prefix::h);
303         }
304         else if (factor == \-1)
305         {
306             return prefix(prefix::d);
307         }
308         else if (factor == \-2)
309         {
310             return prefix(prefix::c);
311         }
312         else if (factor >= 3 and factor < 6)
313         {
314             return prefix(prefix::k);
315         }
316         else if (factor >= 6 and factor < 9)
317         {
318             return prefix(prefix::M);
319         }
320         else if (factor >= 9 and factor < 12)
321         {
322             return prefix(prefix::G);
323         }
324         else if (factor >= 12 and factor < 15)
325         {
326             return prefix(prefix::T);
327         }
328         else if (factor >= 15 and factor < 18)
329         {
330             return prefix(prefix::P);
331         }
332         else if (factor >= 18 and factor < 21)
333         {
334             return prefix(prefix::E);
335         }
336         else if (factor >= 21 and factor < 24)
337         {
338             return prefix(prefix::Z);
339         }
340         else if (factor >= 24)
341         {
342             return prefix(prefix::Y);
343         }
344         else if (factor <= \-3 and factor > \-6)
345         {
346             return prefix(prefix::m);
347         }
348         else if (factor <= \-6 and factor > \-9)
349         {
350             return prefix(prefix::u);
351         }
352         else if (factor <= \-9 and factor > \-12)
353         {
354             return prefix(prefix::n);
355         }
356         else if (factor <= \-12 and factor > \-15)
357         {
358             return prefix(prefix::p);
359         }
360         else if (factor <= \-15 and factor > \-18)
361         {
362             return prefix(prefix::f);
363         }
364         else if (factor <= \-18 and factor > \-21)
365         {
366             return prefix(prefix::a);
367         }
368         else if (factor <= \-21 and factor > \-24)
369         {
370             return prefix(prefix::z);
371         }
372         else if (factor <= \-24)
373         {
374             return prefix(prefix::y);
375         }
376         return prefix();
377     }
.fi

.SS "\fBvector_unit_3d\fP scifir::cross_product (\fBconst\fP \fBvector_unit_3d\fP & x, \fBconst\fP \fBvector_unit_3d\fP & y)"

.PP
Definition at line \fB450\fP of file \fBvector_unit_3d\&.cpp\fP\&..PP
.nf
451     {
452         long double new_value;
453         angle new_theta;
454         angle new_phi;
455         if(y\&.theta == x\&.theta and y\&.phi == x\&.phi)
456         {
457             new_value = 0\&.0l;
458         }
459         else
460         {
461             float new_x = float(x\&.y_projection() * y\&.z_projection() \- x\&.z_projection() * y\&.y_projection());
462             float new_y = float(x\&.z_projection() * y\&.x_projection() \- x\&.x_projection() * y\&.z_projection());
463             float new_z = float(x\&.x_projection() * y\&.y_projection() \- x\&.y_projection() * y\&.x_projection());
464             new_value = cartesian_3d_to_spherical_r(new_x, new_y, new_z);
465             new_theta = cartesian_3d_to_spherical_theta(new_x, new_y, new_z);
466             new_phi = cartesian_3d_to_spherical_phi(new_x, new_y, new_z);
467         }
468         vector<dimension> new_dimensions = multiply_dimensions(x\&.get_dimensions(), y\&.get_dimensions(),new_value);
469         return vector_unit_3d(float(new_value), new_dimensions, new_theta, new_phi);
470     }
.fi

.SS "\fBvector_unit_nd\fP scifir::cross_product (\fBconst\fP \fBvector_unit_nd\fP & x, \fBconst\fP \fBvector_unit_nd\fP & y)"

.PP
Definition at line \fB766\fP of file \fBvector_unit_nd\&.cpp\fP\&..PP
.nf
767     {
768         if(x\&.is_nd(3) and y\&.is_nd(3))
769         {
770             long double new_value;
771             angle new_theta;
772             angle new_phi;
773             if(y\&.angles[0] == x\&.angles[0] and y\&.angles[1] == x\&.angles[1])
774             {
775                 new_value = 0\&.0l;
776             }
777             else
778             {
779                 float new_x = float(x\&.y_projection() * y\&.z_projection() \- x\&.z_projection() * y\&.y_projection());
780                 float new_y = float(x\&.z_projection() * y\&.x_projection() \- x\&.x_projection() * y\&.z_projection());
781                 float new_z = float(x\&.x_projection() * y\&.y_projection() \- x\&.y_projection() * y\&.x_projection());
782                 new_value = cartesian_3d_to_spherical_r(new_x, new_y, new_z);
783                 new_theta = cartesian_3d_to_spherical_theta(new_x, new_y, new_z);
784                 new_phi = cartesian_3d_to_spherical_phi(new_x, new_y, new_z);
785             }
786             vector<dimension> new_dimensions = multiply_dimensions(x\&.get_dimensions(), y\&.get_dimensions(),new_value);
787             scalar_unit new_unit = scalar_unit(float(new_value), new_dimensions);
788             vector<angle> angles;
789             angles\&.push_back(new_theta);
790             angles\&.push_back(new_phi);
791             return vector_unit_nd(new_unit, angles);
792         }
793         else
794         {
795             return vector_unit_nd();
796         }
797     }
.fi

.SS "\fBscalar_unit\fP scifir::cylindrical_to_cartesian_3d_x (\fBconst\fP \fBscalar_unit\fP & p, \fBconst\fP \fBangle\fP & theta, \fBconst\fP \fBscalar_unit\fP & z)\fC [inline]\fP"

.PP
Definition at line \fB683\fP of file \fBcoordinates_3d\&.hpp\fP\&..PP
.nf
684     {
685         return p * scifir::cos(theta);
686     }
.fi

.SS "\fBfloat\fP scifir::cylindrical_to_cartesian_3d_x (\fBfloat\fP p, \fBconst\fP \fBangle\fP & theta, \fBfloat\fP z)\fC [inline]\fP"

.PP
Definition at line \fB775\fP of file \fBcoordinates_3d\&.hpp\fP\&..PP
.nf
776     {
777         return p * scifir::cos(theta);
778     }
.fi

.SS "\fBscalar_unit\fP scifir::cylindrical_to_cartesian_3d_y (\fBconst\fP \fBscalar_unit\fP & p, \fBconst\fP \fBangle\fP & theta, \fBconst\fP \fBscalar_unit\fP & z)\fC [inline]\fP"

.PP
Definition at line \fB688\fP of file \fBcoordinates_3d\&.hpp\fP\&..PP
.nf
689     {
690         return p * scifir::sin(theta);
691     }
.fi

.SS "\fBfloat\fP scifir::cylindrical_to_cartesian_3d_y (\fBfloat\fP p, \fBconst\fP \fBangle\fP & theta, \fBfloat\fP z)\fC [inline]\fP"

.PP
Definition at line \fB780\fP of file \fBcoordinates_3d\&.hpp\fP\&..PP
.nf
781     {
782         return p * scifir::sin(theta);
783     }
.fi

.SS "\fBscalar_unit\fP scifir::cylindrical_to_cartesian_3d_z (\fBconst\fP \fBscalar_unit\fP & p, \fBconst\fP \fBangle\fP & theta, \fBconst\fP \fBscalar_unit\fP & z)\fC [inline]\fP"

.PP
Definition at line \fB693\fP of file \fBcoordinates_3d\&.hpp\fP\&..PP
.nf
694     {
695         return z;
696     }
.fi

.SS "\fBfloat\fP scifir::cylindrical_to_cartesian_3d_z (\fBfloat\fP p, \fBconst\fP \fBangle\fP & theta, \fBfloat\fP z)\fC [inline]\fP"

.PP
Definition at line \fB785\fP of file \fBcoordinates_3d\&.hpp\fP\&..PP
.nf
786     {
787         return z;
788     }
.fi

.SS "\fBangle\fP scifir::cylindrical_to_spherical_phi (\fBconst\fP \fBscalar_unit\fP & p, \fBconst\fP \fBangle\fP & theta, \fBscalar_unit\fP z)\fC [inline]\fP"

.PP
Definition at line \fB709\fP of file \fBcoordinates_3d\&.hpp\fP\&..PP
.nf
710     {
711         z\&.change_dimensions(p);
712         return angle(scifir::atan_grade(float(p) / float(z)));
713     }
.fi

.SS "\fBangle\fP scifir::cylindrical_to_spherical_phi (\fBfloat\fP p, \fBconst\fP \fBangle\fP & theta, \fBfloat\fP z)\fC [inline]\fP"

.PP
Definition at line \fB800\fP of file \fBcoordinates_3d\&.hpp\fP\&..PP
.nf
801     {
802         return angle(scifir::atan_grade(p / z));
803     }
.fi

.SS "\fBscalar_unit\fP scifir::cylindrical_to_spherical_r (\fBconst\fP \fBscalar_unit\fP & p, \fBconst\fP \fBangle\fP & theta, \fBscalar_unit\fP z)\fC [inline]\fP"

.PP
Definition at line \fB698\fP of file \fBcoordinates_3d\&.hpp\fP\&..PP
.nf
699     {
700         z\&.change_dimensions(p);
701         return scalar_unit(std::sqrt(std::pow(float(p),2) + std::pow(float(z),2)),p\&.get_dimensions());
702     }
.fi

.SS "\fBfloat\fP scifir::cylindrical_to_spherical_r (\fBfloat\fP p, \fBconst\fP \fBangle\fP & theta, \fBfloat\fP z)\fC [inline]\fP"

.PP
Definition at line \fB790\fP of file \fBcoordinates_3d\&.hpp\fP\&..PP
.nf
791     {
792         return float(std::sqrt(std::pow(p,2) + std::pow(z,2)));
793     }
.fi

.SS "\fBangle\fP scifir::cylindrical_to_spherical_theta (\fBconst\fP \fBscalar_unit\fP & p, \fBconst\fP \fBangle\fP & theta, \fBconst\fP \fBscalar_unit\fP & z)\fC [inline]\fP"

.PP
Definition at line \fB704\fP of file \fBcoordinates_3d\&.hpp\fP\&..PP
.nf
705     {
706         return theta;
707     }
.fi

.SS "\fBangle\fP scifir::cylindrical_to_spherical_theta (\fBfloat\fP p, \fBconst\fP \fBangle\fP & theta, \fBfloat\fP z)\fC [inline]\fP"

.PP
Definition at line \fB795\fP of file \fBcoordinates_3d\&.hpp\fP\&..PP
.nf
796     {
797         return theta;
798     }
.fi

.SS "\fBstring\fP scifir::time_duration::display_as_time () const"

.PP
Definition at line \fB208\fP of file \fBunit_basic\&.cpp\fP\&..PP
.nf
209     {
210         ostringstream output;
211         scifir::time_duration remaining_time = *this;
212         scifir::time_duration one_year ("365d");
213         if (*this >= one_year)
214         {
215             int total_of_years = int(trunc((*this / one_year)\&.get_value()));
216             output << total_of_years << "y ";
217             remaining_time \-= scifir::time_duration(float(total_of_years) * 365,"d");
218         }
219         scifir::time_duration one_month("30d");
220         if (remaining_time >= one_month)
221         {
222             int total_of_months = int(trunc((remaining_time / one_month)\&.get_value()));
223             output << total_of_months << "m ";
224             remaining_time \-= scifir::time_duration(float(total_of_months) * 30,"d");
225         }
226         scifir::time_duration one_day("1d");
227         if (remaining_time >= one_day)
228         {
229             int total_of_days = int(trunc((remaining_time / one_day)\&.get_value()));
230             output << total_of_days << "d ";
231             remaining_time \-= scifir::time_duration(float(total_of_days),"d");
232         }
233         scifir::time_duration one_hour("1h");
234         if (remaining_time >= one_hour)
235         {
236             int total_of_hours = int(trunc((remaining_time / one_hour)\&.get_value()));
237             output << total_of_hours << "h ";
238             remaining_time \-= scifir::time_duration(float(total_of_hours),"h");
239         }
240         scifir::time_duration one_minute("1min");
241         if (remaining_time >= one_minute)
242         {
243             int total_of_minutes = int(trunc((remaining_time / one_minute)\&.get_value()));
244             output << total_of_minutes << "min ";
245             remaining_time \-= scifir::time_duration(float(total_of_minutes),"min");
246         }
247         scifir::time_duration one_second("1s");
248         if (remaining_time >= one_second)
249         {
250             remaining_time\&.change_dimensions("s");
251             float total_of_seconds = float(remaining_time\&.get_value());
252             output << total_of_seconds << "s";
253         }
254         return output\&.str();
255     }
.fi

.SS "\fBstring\fP scifir::time_duration::display_days () const"

.PP
Definition at line \fB278\fP of file \fBunit_basic\&.cpp\fP\&..PP
.nf
279     {
280         ostringstream out;
281         out << get_days() << " d";
282         return out\&.str();
283     }
.fi

.SS "\fBstring\fP scifir::display_float (\fBconst\fP \fBfloat\fP & value, \fBint\fP number_of_decimals)"

.PP
Definition at line \fB36\fP of file \fBtypes\&.cpp\fP\&..PP
.nf
37     {
38         ostringstream output;
39         if (number_of_decimals > 0)
40         {
41             output << (std::trunc(value*std::pow(10,number_of_decimals)) / std::pow(10,number_of_decimals));
42         }
43         else
44         {
45             output << value;
46         }
47         if (output\&.str() == "\-0")
48         {
49             return "0";
50         }
51         else
52         {
53             return output\&.str();
54         }
55     }
.fi

.SS "\fBstring\fP scifir::time_duration::display_hours () const"

.PP
Definition at line \fB285\fP of file \fBunit_basic\&.cpp\fP\&..PP
.nf
286     {
287         ostringstream out;
288         out << get_hours() << " h";
289         return out\&.str();
290     }
.fi

.SS "\fBstring\fP scifir::time_duration::display_minutes () const"

.PP
Definition at line \fB292\fP of file \fBunit_basic\&.cpp\fP\&..PP
.nf
293     {
294         ostringstream out;
295         out << get_minutes() << " min";
296         return out\&.str();
297     }
.fi

.SS "\fBstring\fP scifir::time_duration::display_months () const"

.PP
Definition at line \fB264\fP of file \fBunit_basic\&.cpp\fP\&..PP
.nf
265     {
266         ostringstream out;
267         out << get_months() << " months";
268         return out\&.str();
269     }
.fi

.SS "\fBstring\fP scifir::time_duration::display_seconds () const"

.PP
Definition at line \fB299\fP of file \fBunit_basic\&.cpp\fP\&..PP
.nf
300     {
301         ostringstream out;
302         out << get_seconds() << " s";
303         return out\&.str();
304     }
.fi

.SS "\fBstring\fP scifir::time_duration::display_weeks () const"

.PP
Definition at line \fB271\fP of file \fBunit_basic\&.cpp\fP\&..PP
.nf
272     {
273         ostringstream out;
274         out << get_weeks() << " weeks";
275         return out\&.str();
276     }
.fi

.SS "\fBstring\fP scifir::time_duration::display_years () const"

.PP
Definition at line \fB257\fP of file \fBunit_basic\&.cpp\fP\&..PP
.nf
258     {
259         ostringstream out;
260         out << get_years() << " y";
261         return out\&.str();
262     }
.fi

.SS "\fBfloat\fP scifir::distance (\fBconst\fP \fBcoordinates_1d\fP< \fBfloat\fP > & x, \fBconst\fP \fBcoordinates_1d\fP< \fBfloat\fP > & y)"

.PP
Definition at line \fB13\fP of file \fBcoordinates_1d\&.cpp\fP\&..PP
.nf
14     {
15         return float(std::sqrt(std::pow(x\&.x \- y\&.x,2)));
16     }
.fi

.SS "\fBfloat\fP scifir::distance (\fBconst\fP \fBcoordinates_1d\fP< \fBfloat\fP > & x, \fBconst\fP \fBpoint_1d\fP< \fBfloat\fP > & y)"

.PP
Definition at line \fB18\fP of file \fBcoordinates_1d\&.cpp\fP\&..PP
.nf
19     {
20         return float(std::sqrt(std::pow(x\&.x \- y\&.x,2)));
21     }
.fi

.SS "template<\fBtypename\fP T , \fBtypename\fP \fBU\fP > T scifir::distance (\fBconst\fP \fBcoordinates_1d\fP< T > & x, \fBconst\fP \fBcoordinates_1d\fP< \fBU\fP > & y)"

.PP
Definition at line \fB217\fP of file \fBcoordinates_1d\&.hpp\fP\&..PP
.nf
218     {
219         return scifir::sqrt(scifir::pow(x\&.x \- y\&.x,2));
220     }
.fi

.SS "template<\fBtypename\fP T , \fBtypename\fP \fBU\fP > T scifir::distance (\fBconst\fP \fBcoordinates_1d\fP< T > & x, \fBconst\fP \fBpoint_1d\fP< \fBU\fP > & y)"

.PP
Definition at line \fB225\fP of file \fBcoordinates_1d\&.hpp\fP\&..PP
.nf
226     {
227         return scifir::sqrt(scifir::pow(x\&.x \- y\&.x,2));
228     }
.fi

.SS "\fBfloat\fP scifir::distance (\fBconst\fP \fBcoordinates_2d\fP< \fBfloat\fP > & x, \fBconst\fP \fBcoordinates_2d\fP< \fBfloat\fP > & y)"

.PP
Definition at line \fB14\fP of file \fBcoordinates_2d\&.cpp\fP\&..PP
.nf
15     {
16         return float(std::sqrt(std::pow(x\&.x \- y\&.x,2) + std::pow(x\&.y \- y\&.y,2)));
17     }
.fi

.SS "\fBfloat\fP scifir::distance (\fBconst\fP \fBcoordinates_2d\fP< \fBfloat\fP > & x, \fBconst\fP \fBcoordinates_2dr\fP< \fBfloat\fP > & y)"

.PP
Definition at line \fB22\fP of file \fBcoordinates_2dr\&.cpp\fP\&..PP
.nf
23     {
24         return float(std::sqrt(std::pow(x\&.x \- y\&.x,2) + std::pow(x\&.y \- y\&.y,2)));
25     }
.fi

.SS "\fBfloat\fP scifir::distance (\fBconst\fP \fBcoordinates_2d\fP< \fBfloat\fP > & x, \fBconst\fP \fBpoint_2d\fP< \fBfloat\fP > & y)"

.PP
Definition at line \fB19\fP of file \fBcoordinates_2d\&.cpp\fP\&..PP
.nf
20     {
21         return float(std::sqrt(std::pow(x\&.x \- y\&.x,2) + std::pow(x\&.y \- y\&.y,2)));
22     }
.fi

.SS "template<\fBtypename\fP T , \fBtypename\fP \fBU\fP > T scifir::distance (\fBconst\fP \fBcoordinates_2d\fP< T > & x, \fBconst\fP \fBcoordinates_2d\fP< \fBU\fP > & y)"

.PP
Definition at line \fB351\fP of file \fBcoordinates_2d\&.hpp\fP\&..PP
.nf
352     {
353         return scifir::sqrt(scifir::pow(x\&.x \- y\&.x,2) + scifir::pow(x\&.y \- y\&.y,2));
354     }
.fi

.SS "template<\fBtypename\fP T , \fBtypename\fP \fBU\fP > T scifir::distance (\fBconst\fP \fBcoordinates_2d\fP< T > & x, \fBconst\fP \fBcoordinates_2dr\fP< \fBU\fP > & y)"

.PP
Definition at line \fB508\fP of file \fBcoordinates_2dr\&.hpp\fP\&..PP
.nf
509     {
510         return scifir::sqrt(scifir::pow(x\&.x \- y\&.x,2) + scifir::pow(x\&.y \- y\&.y,2));
511     }
.fi

.SS "template<\fBtypename\fP T , \fBtypename\fP \fBU\fP > T scifir::distance (\fBconst\fP \fBcoordinates_2d\fP< T > & x, \fBconst\fP \fBpoint_2d\fP< \fBU\fP > & y)"

.PP
Definition at line \fB359\fP of file \fBcoordinates_2d\&.hpp\fP\&..PP
.nf
360     {
361         return scifir::sqrt(scifir::pow(x\&.x \- y\&.x,2) + scifir::pow(x\&.y \- y\&.y,2));
362     }
.fi

.SS "\fBfloat\fP scifir::distance (\fBconst\fP \fBcoordinates_2dr\fP< \fBfloat\fP > & x, \fBconst\fP \fBcoordinates_2d\fP< \fBfloat\fP > & y)"

.PP
Definition at line \fB17\fP of file \fBcoordinates_2dr\&.cpp\fP\&..PP
.nf
18     {
19         return float(std::sqrt(std::pow(x\&.x \- y\&.x,2) + std::pow(x\&.y \- y\&.y,2)));
20     }
.fi

.SS "\fBfloat\fP scifir::distance (\fBconst\fP \fBcoordinates_2dr\fP< \fBfloat\fP > & x, \fBconst\fP \fBcoordinates_2dr\fP< \fBfloat\fP > & y)"

.PP
Definition at line \fB12\fP of file \fBcoordinates_2dr\&.cpp\fP\&..PP
.nf
13     {
14         return float(std::sqrt(std::pow(x\&.x \- y\&.x,2) + std::pow(x\&.y \- y\&.y,2)));
15     }
.fi

.SS "\fBfloat\fP scifir::distance (\fBconst\fP \fBcoordinates_2dr\fP< \fBfloat\fP > & x, \fBconst\fP \fBpoint_2d\fP< \fBfloat\fP > & y)"

.PP
Definition at line \fB27\fP of file \fBcoordinates_2dr\&.cpp\fP\&..PP
.nf
28     {
29         return float(std::sqrt(std::pow(x\&.x \- y\&.x,2) + std::pow(x\&.y \- y\&.y,2)));
30     }
.fi

.SS "template<\fBtypename\fP T , \fBtypename\fP \fBU\fP > T scifir::distance (\fBconst\fP \fBcoordinates_2dr\fP< T > & x, \fBconst\fP \fBcoordinates_2d\fP< \fBU\fP > & y)"

.PP
Definition at line \fB500\fP of file \fBcoordinates_2dr\&.hpp\fP\&..PP
.nf
501     {
502         return scifir::sqrt(scifir::pow(x\&.x \- y\&.x,2) + scifir::pow(x\&.y \- y\&.y,2));
503     }
.fi

.SS "template<\fBtypename\fP T , \fBtypename\fP \fBU\fP > T scifir::distance (\fBconst\fP \fBcoordinates_2dr\fP< T > & x, \fBconst\fP \fBcoordinates_2dr\fP< \fBU\fP > & y)"

.PP
Definition at line \fB492\fP of file \fBcoordinates_2dr\&.hpp\fP\&..PP
.nf
493     {
494         return scifir::sqrt(scifir::pow(x\&.x \- y\&.x,2) + scifir::pow(x\&.y \- y\&.y,2));
495     }
.fi

.SS "template<\fBtypename\fP T , \fBtypename\fP \fBU\fP > T scifir::distance (\fBconst\fP \fBcoordinates_2dr\fP< T > & x, \fBconst\fP \fBpoint_2d\fP< \fBU\fP > & y)"

.PP
Definition at line \fB516\fP of file \fBcoordinates_2dr\&.hpp\fP\&..PP
.nf
517     {
518         return scifir::sqrt(scifir::pow(x\&.x \- y\&.x,2) + scifir::pow(x\&.y \- y\&.y,2));
519     }
.fi

.SS "\fBfloat\fP scifir::distance (\fBconst\fP \fBcoordinates_3d\fP< \fBfloat\fP > & x, \fBconst\fP \fBcoordinates_3d\fP< \fBfloat\fP > & y)"

.PP
Definition at line \fB12\fP of file \fBcoordinates_3d\&.cpp\fP\&..PP
.nf
13     {
14         return float(std::sqrt(std::pow(x\&.x \- y\&.x,2) + std::pow(x\&.y \- y\&.y,2) + std::pow(x\&.z \- y\&.z,2)));
15     }
.fi

.SS "\fBfloat\fP scifir::distance (\fBconst\fP \fBcoordinates_3d\fP< \fBfloat\fP > & x, \fBconst\fP \fBcoordinates_3dr\fP< \fBfloat\fP > & y)"

.PP
Definition at line \fB22\fP of file \fBcoordinates_3dr\&.cpp\fP\&..PP
.nf
23     {
24         return float(std::sqrt(std::pow(x\&.x \- y\&.x,2) + std::pow(x\&.y \- y\&.y,2) + std::pow(x\&.z \- y\&.z,2)));
25     }
.fi

.SS "\fBfloat\fP scifir::distance (\fBconst\fP \fBcoordinates_3d\fP< \fBfloat\fP > & x, \fBconst\fP \fBpoint_3d\fP< \fBfloat\fP > & y)"

.PP
Definition at line \fB17\fP of file \fBcoordinates_3d\&.cpp\fP\&..PP
.nf
18     {
19         return float(std::sqrt(std::pow(x\&.x \- y\&.x,2) + std::pow(x\&.y \- y\&.y,2) + std::pow(x\&.z \- y\&.z,2)));
20     }
.fi

.SS "template<\fBtypename\fP T , \fBtypename\fP \fBU\fP > T scifir::distance (\fBconst\fP \fBcoordinates_3d\fP< T > & x, \fBconst\fP \fBcoordinates_3d\fP< \fBU\fP > & y)"

.PP
Definition at line \fB593\fP of file \fBcoordinates_3d\&.hpp\fP\&..PP
.nf
594     {
595         return scifir::sqrt(scifir::pow(x\&.x \- y\&.x,2) + scifir::pow(x\&.y \- y\&.y,2) + scifir::pow(x\&.z \- y\&.z,2));
596     }
.fi

.SS "template<\fBtypename\fP T , \fBtypename\fP \fBU\fP > T scifir::distance (\fBconst\fP \fBcoordinates_3d\fP< T > & x, \fBconst\fP \fBcoordinates_3dr\fP< \fBU\fP > & y)"

.PP
Definition at line \fB956\fP of file \fBcoordinates_3dr\&.hpp\fP\&..PP
.nf
957     {
958         return scifir::sqrt(scifir::pow(x\&.x \- y\&.x,2) + scifir::pow(x\&.y \- y\&.y,2) + scifir::pow(x\&.z \- y\&.z,2));
959     }
.fi

.SS "template<\fBtypename\fP T , \fBtypename\fP \fBU\fP > T scifir::distance (\fBconst\fP \fBcoordinates_3d\fP< T > & x, \fBconst\fP \fBpoint_3d\fP< \fBU\fP > & y)"

.PP
Definition at line \fB601\fP of file \fBcoordinates_3d\&.hpp\fP\&..PP
.nf
602     {
603         return scifir::sqrt(scifir::pow(x\&.x \- y\&.x,2) + scifir::pow(x\&.y \- y\&.y,2) + scifir::pow(x\&.z \- y\&.z,2));
604     }
.fi

.SS "\fBfloat\fP scifir::distance (\fBconst\fP \fBcoordinates_3dr\fP< \fBfloat\fP > & x, \fBconst\fP \fBcoordinates_3d\fP< \fBfloat\fP > & y)"

.PP
Definition at line \fB17\fP of file \fBcoordinates_3dr\&.cpp\fP\&..PP
.nf
18     {
19         return float(std::sqrt(std::pow(x\&.x \- y\&.x,2) + std::pow(x\&.y \- y\&.y,2) + std::pow(x\&.z \- y\&.z,2)));
20     }
.fi

.SS "\fBfloat\fP scifir::distance (\fBconst\fP \fBcoordinates_3dr\fP< \fBfloat\fP > & x, \fBconst\fP \fBcoordinates_3dr\fP< \fBfloat\fP > & y)"

.PP
Definition at line \fB12\fP of file \fBcoordinates_3dr\&.cpp\fP\&..PP
.nf
13     {
14         return float(std::sqrt(std::pow(x\&.x \- y\&.x,2) + std::pow(x\&.y \- y\&.y,2) + std::pow(x\&.z \- y\&.z,2)));
15     }
.fi

.SS "\fBfloat\fP scifir::distance (\fBconst\fP \fBcoordinates_3dr\fP< \fBfloat\fP > & x, \fBconst\fP \fBpoint_3d\fP< \fBfloat\fP > & y)"

.PP
Definition at line \fB27\fP of file \fBcoordinates_3dr\&.cpp\fP\&..PP
.nf
28     {
29         return float(std::sqrt(std::pow(x\&.x \- y\&.x,2) + std::pow(x\&.y \- y\&.y,2) + std::pow(x\&.z \- y\&.z,2)));
30     }
.fi

.SS "template<\fBtypename\fP T , \fBtypename\fP \fBU\fP > T scifir::distance (\fBconst\fP \fBcoordinates_3dr\fP< T > & x, \fBconst\fP \fBcoordinates_3d\fP< \fBU\fP > & y)"

.PP
Definition at line \fB948\fP of file \fBcoordinates_3dr\&.hpp\fP\&..PP
.nf
949     {
950         return scifir::sqrt(scifir::pow(x\&.x \- y\&.x,2) + scifir::pow(x\&.y \- y\&.y,2) + scifir::pow(x\&.z \- y\&.z,2));
951     }
.fi

.SS "template<\fBtypename\fP T , \fBtypename\fP \fBU\fP > T scifir::distance (\fBconst\fP \fBcoordinates_3dr\fP< T > & x, \fBconst\fP \fBcoordinates_3dr\fP< \fBU\fP > & y)"

.PP
Definition at line \fB940\fP of file \fBcoordinates_3dr\&.hpp\fP\&..PP
.nf
941     {
942         return scifir::sqrt(scifir::pow(x\&.x \- y\&.x,2) + scifir::pow(x\&.y \- y\&.y,2) + scifir::pow(x\&.z \- y\&.z,2));
943     }
.fi

.SS "template<\fBtypename\fP T , \fBtypename\fP \fBU\fP > T scifir::distance (\fBconst\fP \fBcoordinates_3dr\fP< T > & x, \fBconst\fP \fBpoint_3d\fP< \fBU\fP > & y)"

.PP
Definition at line \fB964\fP of file \fBcoordinates_3dr\&.hpp\fP\&..PP
.nf
965     {
966         return scifir::sqrt(scifir::pow(x\&.x \- y\&.x,2) + scifir::pow(x\&.y \- y\&.y,2) + scifir::pow(x\&.z \- y\&.z,2));
967     }
.fi

.SS "\fBfloat\fP scifir::distance (\fBconst\fP \fBcoordinates_nd\fP< \fBfloat\fP > & x, \fBconst\fP \fBcoordinates_nd\fP< \fBfloat\fP > & y)"

.PP
Definition at line \fB30\fP of file \fBcoordinates_nd\&.cpp\fP\&..PP
.nf
31     {
32         if (x\&.get_nd() == y\&.get_nd())
33         {
34             float x_length = 0;
35             for (unsigned int i = 0; i < x\&.values\&.size(); i++)
36             {
37                 x_length += float(std::pow(x\&.values[i] \- y\&.values[i],2));
38             }
39             return std::sqrt(x_length);
40         }
41         else
42         {
43             return 0\&.0f;
44         }
45     }
.fi

.SS "\fBfloat\fP scifir::distance (\fBconst\fP \fBcoordinates_nd\fP< \fBfloat\fP > & x, \fBconst\fP \fBcoordinates_ndr\fP< \fBfloat\fP > & y)"

.PP
Definition at line \fB82\fP of file \fBcoordinates_ndr\&.cpp\fP\&..PP
.nf
83     {
84         if (x\&.get_nd() == y\&.get_nd())
85         {
86             float x_length = 0;
87             for (unsigned int i = 0; i < x\&.values\&.size(); i++)
88             {
89                 x_length += float(std::pow(x\&.values[i] \- y\&.get_value(i),2));
90             }
91             return std::sqrt(x_length);
92         }
93         else
94         {
95             return 0\&.0f;
96         }
97     }
.fi

.SS "\fBfloat\fP scifir::distance (\fBconst\fP \fBcoordinates_nd\fP< \fBfloat\fP > & x, \fBconst\fP \fBpoint_nd\fP< \fBfloat\fP > & y)"

.PP
Definition at line \fB47\fP of file \fBcoordinates_nd\&.cpp\fP\&..PP
.nf
48     {
49         if (x\&.get_nd() == y\&.get_nd())
50         {
51             float x_length = 0;
52             for (unsigned int i = 0; i < x\&.values\&.size(); i++)
53             {
54                 x_length += float(std::pow(x\&.values[i] \- y\&.values[i],2));
55             }
56             return std::sqrt(x_length);
57         }
58         else
59         {
60             return 0\&.0f;
61         }
62     }
.fi

.SS "template<\fBtypename\fP T , \fBtypename\fP \fBU\fP > T scifir::distance (\fBconst\fP \fBcoordinates_nd\fP< T > & x, \fBconst\fP \fBcoordinates_nd\fP< \fBU\fP > & y)"

.PP
Definition at line \fB1088\fP of file \fBcoordinates_nd\&.hpp\fP\&..PP
.nf
1089     {
1090         if (x\&.get_nd() == y\&.get_nd())
1091         {
1092             scalar_unit x_length = scalar_unit(0\&.0f,"m2");
1093             for (int i = 0; i < x\&.values\&.size(); i++)
1094             {
1095                 x_length += scifir::pow(x\&.values[i] \- y\&.values[i],2);
1096             }
1097             return scifir::sqrt(x_length);
1098         }
1099         else
1100         {
1101             return T();
1102         }
1103     }
.fi

.SS "template<\fBtypename\fP T , \fBtypename\fP \fBU\fP > T scifir::distance (\fBconst\fP \fBcoordinates_nd\fP< T > & x, \fBconst\fP \fBcoordinates_ndr\fP< \fBU\fP > & y)"

.PP
Definition at line \fB2226\fP of file \fBcoordinates_ndr\&.hpp\fP\&..PP
.nf
2227     {
2228         if (x\&.get_nd() == y\&.get_nd())
2229         {
2230             scalar_unit x_length = scalar_unit(0\&.0f,"m2");
2231             for (int i = 0; i < x\&.values\&.size(); i++)
2232             {
2233                 x_length += scifir::pow(x\&.values[i] \- y\&.get_value(i),2);
2234             }
2235             return scifir::sqrt(x_length);
2236         }
2237         else
2238         {
2239             return T();
2240         }
2241     }
.fi

.SS "template<\fBtypename\fP T , \fBtypename\fP \fBU\fP > T scifir::distance (\fBconst\fP \fBcoordinates_nd\fP< T > & x, \fBconst\fP \fBpoint_nd\fP< \fBU\fP > & y)"

.PP
Definition at line \fB1108\fP of file \fBcoordinates_nd\&.hpp\fP\&..PP
.nf
1109     {
1110         if (x\&.get_nd() == y\&.get_nd())
1111         {
1112             scalar_unit x_length = scalar_unit(0\&.0f,"m2");
1113             for (int i = 0; i < x\&.values\&.size(); i++)
1114             {
1115                 x_length += scifir::pow(x\&.values[i] \- y\&.values[i],2);
1116             }
1117             return scifir::sqrt(x_length);
1118         }
1119         else
1120         {
1121             return T();
1122         }
1123     }
.fi

.SS "\fBfloat\fP scifir::distance (\fBconst\fP \fBcoordinates_ndr\fP< \fBfloat\fP > & x, \fBconst\fP \fBcoordinates_nd\fP< \fBfloat\fP > & y)"

.PP
Definition at line \fB65\fP of file \fBcoordinates_ndr\&.cpp\fP\&..PP
.nf
66     {
67         if (x\&.get_nd() == y\&.get_nd())
68         {
69             float x_length = 0;
70             for (unsigned int i = 0; i < x\&.get_values()\&.size(); i++)
71             {
72                 x_length += float(std::pow(x\&.get_value(i) \- y\&.values[i],2));
73             }
74             return std::sqrt(x_length);
75         }
76         else
77         {
78             return 0\&.0f;
79         }
80     }
.fi

.SS "\fBfloat\fP scifir::distance (\fBconst\fP \fBcoordinates_ndr\fP< \fBfloat\fP > & x, \fBconst\fP \fBcoordinates_ndr\fP< \fBfloat\fP > & y)"

.PP
Definition at line \fB48\fP of file \fBcoordinates_ndr\&.cpp\fP\&..PP
.nf
49     {
50         if (x\&.get_nd() == y\&.get_nd())
51         {
52             float x_length = 0;
53             for (unsigned int i = 0; i < x\&.get_values()\&.size(); i++)
54             {
55                 x_length += float(std::pow(x\&.get_value(i) \- y\&.get_value(i),2));
56             }
57             return std::sqrt(x_length);
58         }
59         else
60         {
61             return 0\&.0f;
62         }
63     }
.fi

.SS "\fBfloat\fP scifir::distance (\fBconst\fP \fBcoordinates_ndr\fP< \fBfloat\fP > & x, \fBconst\fP \fBpoint_nd\fP< \fBfloat\fP > & y)"

.PP
Definition at line \fB99\fP of file \fBcoordinates_ndr\&.cpp\fP\&..PP
.nf
100     {
101         if (x\&.get_nd() == y\&.get_nd())
102         {
103             float x_length = 0;
104             for (unsigned int i = 0; i < x\&.get_values()\&.size(); i++)
105             {
106                 x_length += float(std::pow(x\&.get_value(i) \- y\&.values[i],2));
107             }
108             return std::sqrt(x_length);
109         }
110         else
111         {
112             return 0\&.0f;
113         }
114     }
.fi

.SS "template<\fBtypename\fP T , \fBtypename\fP \fBU\fP > T scifir::distance (\fBconst\fP \fBcoordinates_ndr\fP< T > & x, \fBconst\fP \fBcoordinates_nd\fP< \fBU\fP > & y)"

.PP
Definition at line \fB2206\fP of file \fBcoordinates_ndr\&.hpp\fP\&..PP
.nf
2207     {
2208         if (x\&.get_nd() == y\&.get_nd())
2209         {
2210             scalar_unit x_length = scalar_unit(0\&.0f,"m2");
2211             for (int i = 0; i < x\&.get_values()\&.size(); i++)
2212             {
2213                 x_length += scifir::pow(x\&.get_value(i) \- y\&.values[i],2);
2214             }
2215             return scifir::sqrt(x_length);
2216         }
2217         else
2218         {
2219             return T();
2220         }
2221     }
.fi

.SS "template<\fBtypename\fP T , \fBtypename\fP \fBU\fP > T scifir::distance (\fBconst\fP \fBcoordinates_ndr\fP< T > & x, \fBconst\fP \fBcoordinates_ndr\fP< \fBU\fP > & y)"

.PP
Definition at line \fB2186\fP of file \fBcoordinates_ndr\&.hpp\fP\&..PP
.nf
2187     {
2188         if (x\&.get_nd() == y\&.get_nd())
2189         {
2190             scalar_unit x_length = scalar_unit(0\&.0f,"m2");
2191             for (int i = 0; i < x\&.get_values()\&.size(); i++)
2192             {
2193                 x_length += scifir::pow(x\&.get_value(i) \- y\&.get_value(i),2);
2194             }
2195             return scifir::sqrt(x_length);
2196         }
2197         else
2198         {
2199             return T();
2200         }
2201     }
.fi

.SS "template<\fBtypename\fP T , \fBtypename\fP \fBU\fP > T scifir::distance (\fBconst\fP \fBcoordinates_ndr\fP< T > & x, \fBconst\fP \fBpoint_nd\fP< \fBU\fP > & y)"

.PP
Definition at line \fB2246\fP of file \fBcoordinates_ndr\&.hpp\fP\&..PP
.nf
2247     {
2248         if (x\&.get_nd() == y\&.get_nd())
2249         {
2250             scalar_unit x_length = scalar_unit(0\&.0f,"m2");
2251             for (int i = 0; i < x\&.get_values()\&.size(); i++)
2252             {
2253                 x_length += scifir::pow(x\&.get_value(i) \- y\&.values[i],2);
2254             }
2255             return scifir::sqrt(x_length);
2256         }
2257         else
2258         {
2259             return T();
2260         }
2261     }
.fi

.SS "\fBfloat\fP scifir::distance (\fBconst\fP \fBpoint_1d\fP< \fBfloat\fP > & x, \fBconst\fP \fBcoordinates_1d\fP< \fBfloat\fP > & y)"

.PP
Definition at line \fB23\fP of file \fBcoordinates_1d\&.cpp\fP\&..PP
.nf
24     {
25         return float(std::sqrt(std::pow(x\&.x \- y\&.x,2)));
26     }
.fi

.SS "\fBfloat\fP scifir::distance (\fBconst\fP \fBpoint_1d\fP< \fBfloat\fP > & x, \fBconst\fP \fBpoint_1d\fP< \fBfloat\fP > & y)"

.PP
Definition at line \fB33\fP of file \fBpoint_1d\&.cpp\fP\&..PP
.nf
34     {
35         return float(std::sqrt(std::pow(x\&.x \- y\&.x,2)));
36     }
.fi

.SS "template<\fBtypename\fP T , \fBtypename\fP \fBU\fP > T scifir::distance (\fBconst\fP \fBpoint_1d\fP< T > & x, \fBconst\fP \fBcoordinates_1d\fP< \fBU\fP > & y)"

.PP
Definition at line \fB233\fP of file \fBcoordinates_1d\&.hpp\fP\&..PP
.nf
234     {
235         return scifir::sqrt(scifir::pow(x\&.x \- y\&.x,2));
236     }
.fi

.SS "template<\fBtypename\fP T , \fBtypename\fP \fBU\fP > T scifir::distance (\fBconst\fP \fBpoint_1d\fP< T > & x, \fBconst\fP \fBpoint_1d\fP< \fBU\fP > & y)"

.PP
Definition at line \fB199\fP of file \fBpoint_1d\&.hpp\fP\&..PP
.nf
200     {
201         return scifir::sqrt(scifir::pow(x\&.x \- y\&.x,2));
202     }
.fi

.SS "\fBfloat\fP scifir::distance (\fBconst\fP \fBpoint_2d\fP< \fBfloat\fP > & x, \fBconst\fP \fBcoordinates_2d\fP< \fBfloat\fP > & y)"

.PP
Definition at line \fB24\fP of file \fBcoordinates_2d\&.cpp\fP\&..PP
.nf
25     {
26         return float(std::sqrt(std::pow(x\&.x \- y\&.x,2) + std::pow(x\&.y \- y\&.y,2)));
27     }
.fi

.SS "\fBfloat\fP scifir::distance (\fBconst\fP \fBpoint_2d\fP< \fBfloat\fP > & x, \fBconst\fP \fBcoordinates_2dr\fP< \fBfloat\fP > & y)"

.PP
Definition at line \fB32\fP of file \fBcoordinates_2dr\&.cpp\fP\&..PP
.nf
33     {
34         return float(std::sqrt(std::pow(x\&.x \- y\&.x,2) + std::pow(x\&.y \- y\&.y,2)));
35     }
.fi

.SS "\fBfloat\fP scifir::distance (\fBconst\fP \fBpoint_2d\fP< \fBfloat\fP > & x, \fBconst\fP \fBpoint_2d\fP< \fBfloat\fP > & y)"

.PP
Definition at line \fB35\fP of file \fBpoint_2d\&.cpp\fP\&..PP
.nf
36     {
37         return float(std::sqrt(std::pow(x\&.x \- y\&.x,2) + std::pow(x\&.y \- y\&.y,2)));
38     }
.fi

.SS "template<\fBtypename\fP T , \fBtypename\fP \fBU\fP > T scifir::distance (\fBconst\fP \fBpoint_2d\fP< T > & x, \fBconst\fP \fBcoordinates_2d\fP< \fBU\fP > & y)"

.PP
Definition at line \fB367\fP of file \fBcoordinates_2d\&.hpp\fP\&..PP
.nf
368     {
369         return scifir::sqrt(scifir::pow(x\&.x \- y\&.x,2) + scifir::pow(x\&.y \- y\&.y,2));
370     }
.fi

.SS "template<\fBtypename\fP T , \fBtypename\fP \fBU\fP > T scifir::distance (\fBconst\fP \fBpoint_2d\fP< T > & x, \fBconst\fP \fBcoordinates_2dr\fP< \fBU\fP > & y)"

.PP
Definition at line \fB524\fP of file \fBcoordinates_2dr\&.hpp\fP\&..PP
.nf
525     {
526         return scifir::sqrt(scifir::pow(x\&.x \- y\&.x,2) + scifir::pow(x\&.y \- y\&.y,2));
527     }
.fi

.SS "template<\fBtypename\fP T , \fBtypename\fP \fBU\fP > T scifir::distance (\fBconst\fP \fBpoint_2d\fP< T > & x, \fBconst\fP \fBpoint_2d\fP< \fBU\fP > & y)"

.PP
Definition at line \fB328\fP of file \fBpoint_2d\&.hpp\fP\&..PP
.nf
329     {
330         return scifir::sqrt(scifir::pow(x\&.x \- y\&.x,2) + scifir::pow(x\&.y \- y\&.y,2));
331     }
.fi

.SS "\fBfloat\fP scifir::distance (\fBconst\fP \fBpoint_3d\fP< \fBfloat\fP > & x, \fBconst\fP \fBcoordinates_3d\fP< \fBfloat\fP > & y)"

.PP
Definition at line \fB22\fP of file \fBcoordinates_3d\&.cpp\fP\&..PP
.nf
23     {
24         return float(std::sqrt(std::pow(x\&.x \- y\&.x,2) + std::pow(x\&.y \- y\&.y,2) + std::pow(x\&.z \- y\&.z,2)));
25     }
.fi

.SS "\fBfloat\fP scifir::distance (\fBconst\fP \fBpoint_3d\fP< \fBfloat\fP > & x, \fBconst\fP \fBcoordinates_3dr\fP< \fBfloat\fP > & y)"

.PP
Definition at line \fB32\fP of file \fBcoordinates_3dr\&.cpp\fP\&..PP
.nf
33     {
34         return float(std::sqrt(std::pow(x\&.x \- y\&.x,2) + std::pow(x\&.y \- y\&.y,2) + std::pow(x\&.z \- y\&.z,2)));
35     }
.fi

.SS "\fBfloat\fP scifir::distance (\fBconst\fP \fBpoint_3d\fP< \fBfloat\fP > & x, \fBconst\fP \fBpoint_3d\fP< \fBfloat\fP > & y)"

.PP
Definition at line \fB37\fP of file \fBpoint_3d\&.cpp\fP\&..PP
.nf
38     {
39         return float(std::sqrt(std::pow(x\&.x \- y\&.x,2) + std::pow(x\&.y \- y\&.y,2) + std::pow(x\&.z \- y\&.z,2)));
40     }
.fi

.SS "template<\fBtypename\fP T , \fBtypename\fP \fBU\fP > T scifir::distance (\fBconst\fP \fBpoint_3d\fP< T > & x, \fBconst\fP \fBcoordinates_3d\fP< \fBU\fP > & y)"

.PP
Definition at line \fB609\fP of file \fBcoordinates_3d\&.hpp\fP\&..PP
.nf
610     {
611         return scifir::sqrt(scifir::pow(x\&.x \- y\&.x,2) + scifir::pow(x\&.y \- y\&.y,2) + scifir::pow(x\&.z \- y\&.z,2));
612     }
.fi

.SS "template<\fBtypename\fP T , \fBtypename\fP \fBU\fP > T scifir::distance (\fBconst\fP \fBpoint_3d\fP< T > & x, \fBconst\fP \fBcoordinates_3dr\fP< \fBU\fP > & y)"

.PP
Definition at line \fB972\fP of file \fBcoordinates_3dr\&.hpp\fP\&..PP
.nf
973     {
974         return scifir::sqrt(scifir::pow(x\&.x \- y\&.x,2) + scifir::pow(x\&.y \- y\&.y,2) + scifir::pow(x\&.z \- y\&.z,2));
975     }
.fi

.SS "template<\fBtypename\fP T , \fBtypename\fP \fBU\fP > T scifir::distance (\fBconst\fP \fBpoint_3d\fP< T > & x, \fBconst\fP \fBpoint_3d\fP< \fBU\fP > & y)"

.PP
Definition at line \fB565\fP of file \fBpoint_3d\&.hpp\fP\&..PP
.nf
566     {
567         return scifir::sqrt(scifir::pow(x\&.x \- y\&.x,2) + scifir::pow(x\&.y \- y\&.y,2) + scifir::pow(x\&.z \- y\&.z,2));
568     }
.fi

.SS "\fBfloat\fP scifir::distance (\fBconst\fP \fBpoint_nd\fP< \fBfloat\fP > & x, \fBconst\fP \fBcoordinates_nd\fP< \fBfloat\fP > & y)"

.PP
Definition at line \fB64\fP of file \fBcoordinates_nd\&.cpp\fP\&..PP
.nf
65     {
66         if (x\&.get_nd() == y\&.get_nd())
67         {
68             float x_length = 0;
69             for (unsigned int i = 0; i < x\&.values\&.size(); i++)
70             {
71                 x_length += float(std::pow(x\&.values[i] \- y\&.values[i],2));
72             }
73             return std::sqrt(x_length);
74         }
75         else
76         {
77             return 0\&.0f;
78         }
79     }
.fi

.SS "\fBfloat\fP scifir::distance (\fBconst\fP \fBpoint_nd\fP< \fBfloat\fP > & x, \fBconst\fP \fBcoordinates_ndr\fP< \fBfloat\fP > & y)"

.PP
Definition at line \fB116\fP of file \fBcoordinates_ndr\&.cpp\fP\&..PP
.nf
117     {
118         if (x\&.get_nd() == y\&.get_nd())
119         {
120             float x_length = 0;
121             for (unsigned int i = 0; i < x\&.values\&.size(); i++)
122             {
123                 x_length += float(std::pow(x\&.values[i] \- y\&.get_value(i),2));
124             }
125             return std::sqrt(x_length);
126         }
127         else
128         {
129             return 0\&.0f;
130         }
131     }
.fi

.SS "\fBfloat\fP scifir::distance (\fBconst\fP \fBpoint_nd\fP< \fBfloat\fP > & x, \fBconst\fP \fBpoint_nd\fP< \fBfloat\fP > & y)"

.PP
Definition at line \fB51\fP of file \fBpoint_nd\&.cpp\fP\&..PP
.nf
52     {
53         if (x\&.get_nd() == y\&.get_nd())
54         {
55             float x_length = 0;
56             for (unsigned int i = 0; i < x\&.values\&.size(); i++)
57             {
58                 x_length += float(std::pow(x\&.values[i] \- y\&.values[i],2));
59             }
60             return std::sqrt(x_length);
61         }
62         else
63         {
64             return float();
65         }
66     }
.fi

.SS "template<\fBtypename\fP T , \fBtypename\fP \fBU\fP > T scifir::distance (\fBconst\fP \fBpoint_nd\fP< T > & x, \fBconst\fP \fBcoordinates_nd\fP< \fBU\fP > & y)"

.PP
Definition at line \fB1128\fP of file \fBcoordinates_nd\&.hpp\fP\&..PP
.nf
1129     {
1130         if (x\&.get_nd() == y\&.get_nd())
1131         {
1132             scalar_unit x_length = scalar_unit(0\&.0f,"m2");
1133             for (int i = 0; i < x\&.values\&.size(); i++)
1134             {
1135                 x_length += scifir::pow(x\&.values[i] \- y\&.values[i],2);
1136             }
1137             return scifir::sqrt(x_length);
1138         }
1139         else
1140         {
1141             return T();
1142         }
1143     }
.fi

.SS "template<\fBtypename\fP T , \fBtypename\fP \fBU\fP > T scifir::distance (\fBconst\fP \fBpoint_nd\fP< T > & x, \fBconst\fP \fBcoordinates_ndr\fP< \fBU\fP > & y)"

.PP
Definition at line \fB2266\fP of file \fBcoordinates_ndr\&.hpp\fP\&..PP
.nf
2267     {
2268         if (x\&.get_nd() == y\&.get_nd())
2269         {
2270             scalar_unit x_length = scalar_unit(0\&.0f,"m2");
2271             for (int i = 0; i < x\&.values\&.size(); i++)
2272             {
2273                 x_length += scifir::pow(x\&.values[i] \- y\&.get_value(i),2);
2274             }
2275             return scifir::sqrt(x_length);
2276         }
2277         else
2278         {
2279             return T();
2280         }
2281     }
.fi

.SS "template<\fBtypename\fP T , \fBtypename\fP \fBU\fP > T scifir::distance (\fBconst\fP \fBpoint_nd\fP< T > & x1, \fBconst\fP \fBpoint_nd\fP< \fBU\fP > & x2)"

.PP
Definition at line \fB1072\fP of file \fBpoint_nd\&.hpp\fP\&..PP
.nf
1073     {
1074         if (x1\&.get_nd() == x2\&.get_nd())
1075         {
1076             scalar_unit x_length = scalar_unit(0\&.0f,"m2");
1077             for (int i = 0; i < x1\&.values\&.size(); i++)
1078             {
1079                 x_length += scifir::pow(x1\&.values[i] \- x2\&.values[i],2);
1080             }
1081             return scifir::sqrt(x_length);
1082         }
1083         else
1084         {
1085             return T();
1086         }
1087     }
.fi

.SS "vector< \fBdimension\fP > scifir::divide_dimensions (vector< \fBdimension\fP > x, \fBconst\fP vector< \fBdimension\fP > & y, \fBlong\fP \fBdouble\fP & value)"

.PP
Definition at line \fB1398\fP of file \fBdimension\&.cpp\fP\&..PP
.nf
1399     {
1400         for(dimension y_dimension : y)
1401         {
1402             y_dimension\&.invert();
1403             x\&.push_back(y_dimension);
1404         }
1405         return normalize_dimensions(x,value);
1406     }
.fi

.SS "\fBscalar_unit\fP scifir::dot_product (\fBconst\fP \fBvector_unit_2d\fP & x, \fBconst\fP \fBvector_unit_2d\fP & y)"

.PP
Definition at line \fB338\fP of file \fBvector_unit_2d\&.cpp\fP\&..PP
.nf
339     {
340         long double new_value = (x\&.x_projection() * y\&.x_projection() + x\&.y_projection() * y\&.y_projection())\&.get_value();
341         vector<dimension> new_dimensions = multiply_dimensions(x\&.get_dimensions(), y\&.get_dimensions(),new_value);
342         return scalar_unit(new_value,new_dimensions);
343     }
.fi

.SS "\fBscalar_unit\fP scifir::dot_product (\fBconst\fP \fBvector_unit_3d\fP & x, \fBconst\fP \fBvector_unit_3d\fP & y)"

.PP
Definition at line \fB443\fP of file \fBvector_unit_3d\&.cpp\fP\&..PP
.nf
444     {
445         long double new_value = float(x\&.x_projection()*y\&.x_projection() + x\&.y_projection()*y\&.y_projection() + x\&.z_projection()*y\&.z_projection());
446         vector<dimension> new_dimensions = multiply_dimensions(x\&.get_dimensions(), y\&.get_dimensions(),new_value);
447         return scalar_unit(float(new_value),new_dimensions);
448     }
.fi

.SS "\fBscalar_unit\fP scifir::dot_product (\fBconst\fP \fBvector_unit_nd\fP & x, \fBconst\fP \fBvector_unit_nd\fP & y)"

.PP
Definition at line \fB759\fP of file \fBvector_unit_nd\&.cpp\fP\&..PP
.nf
760     {
761         long double new_value = float(x\&.x_projection()*y\&.x_projection() + x\&.y_projection()*y\&.y_projection() + x\&.z_projection()*y\&.z_projection());
762         vector<dimension> new_dimensions = multiply_dimensions(x\&.get_dimensions(), y\&.get_dimensions(),new_value);
763         return scalar_unit(float(new_value),new_dimensions);
764     }
.fi

.SS "\fBbool\fP scifir::equal_dimensions (\fBconst\fP \fBstring\fP & init_dimensions_x, \fBconst\fP \fBstring\fP & init_dimensions_y)"

.PP
Definition at line \fB1629\fP of file \fBdimension\&.cpp\fP\&..PP
.nf
1630     {
1631         vector<dimension> x_dimensions = create_dimensions(init_dimensions_x);
1632         vector<dimension> y_dimensions = create_dimensions(init_dimensions_y);
1633         return equal_dimensions(x_dimensions,y_dimensions);
1634     }
.fi

.SS "\fBbool\fP scifir::equal_dimensions (\fBconst\fP vector< \fBdimension\fP > & x, \fBconst\fP vector< \fBdimension\fP > & y)"

.PP
Definition at line \fB1636\fP of file \fBdimension\&.cpp\fP\&..PP
.nf
1637     {
1638         vector<dimension> x_derived_dimensions = create_derived_dimensions(x);
1639         vector<dimension> y_derived_dimensions = create_derived_dimensions(y);
1640         if (x_derived_dimensions\&.size() == y_derived_dimensions\&.size())
1641         {
1642             vector<unsigned int> skip = vector<unsigned int>();
1643             for (const dimension& x_dimension: x_derived_dimensions)
1644             {
1645                 bool is_equal = false;
1646                 for (unsigned int j = 0; j < y_derived_dimensions\&.size(); j++)
1647                 {
1648                     bool skip_j = false;
1649                     if (skip\&.size() > 0)
1650                     {
1651                         for (unsigned int k = 0; k < skip\&.size(); k++)
1652                         {
1653                             if (j == skip[k])
1654                             {
1655                                 skip_j = true;
1656                             }
1657                         }
1658                     }
1659                     if (skip_j)
1660                     {
1661                         continue;
1662                     }
1663                     if (x_dimension == y_derived_dimensions[j])
1664                     {
1665                         skip\&.push_back(j);
1666                         is_equal = true;
1667                         break;
1668                     }
1669                 }
1670                 if (!is_equal)
1671                 {
1672                     return false;
1673                 }
1674             }
1675             return true;
1676         }
1677         else
1678         {
1679             return false;
1680         }
1681     }
.fi

.SS "\fBbool\fP scifir::equal_dimensions_and_prefixes (\fBconst\fP vector< \fBdimension\fP > & x, \fBconst\fP vector< \fBdimension\fP > & y)"

.PP
Definition at line \fB1683\fP of file \fBdimension\&.cpp\fP\&..PP
.nf
1684     {
1685         vector<unsigned int> skip = vector<unsigned int>();
1686         if (x\&.size() == y\&.size())
1687         {
1688             for (const dimension& x_dimension: x)
1689             {
1690                 bool is_equal = false;
1691                 for (unsigned int j = 0; j < y\&.size(); j++)
1692                 {
1693                     bool skip_j = false;
1694                     if (skip\&.size() > 0)
1695                     {
1696                         for (unsigned int k = 0; k < skip\&.size(); k++)
1697                         {
1698                             if (j == skip[k])
1699                             {
1700                                 skip_j = true;
1701                             }
1702                         }
1703                     }
1704                     if (skip_j)
1705                     {
1706                         continue;
1707                     }
1708                     if (x_dimension == y[j] and x_dimension\&.prefix == y[j]\&.prefix)
1709                     {
1710                         skip\&.push_back(j);
1711                         is_equal = true;
1712                         break;
1713                     }
1714                 }
1715                 if (!is_equal)
1716                 {
1717                     return false;
1718                 }
1719             }
1720             return true;
1721         }
1722         else
1723         {
1724             return false;
1725         }
1726     }
.fi

.SS "\fBint\fP scifir::time_duration::get_days () const"

.PP
Definition at line \fB132\fP of file \fBunit_basic\&.cpp\fP\&..PP
.nf
133     {
134         scifir::time_duration one_day("1d");
135         if (*this >= one_day)
136         {
137             return int(trunc((*this / one_day)\&.get_value()));
138         }
139         else
140         {
141             return 0;
142         }
143     }
.fi

.SS "\fBstring\fP scifir::get_finish_date () const"

.SS "\fBint\fP scifir::time_duration::get_hours () const"

.PP
Definition at line \fB145\fP of file \fBunit_basic\&.cpp\fP\&..PP
.nf
146     {
147         scifir::time_duration one_hour("1h");
148         if (*this >= one_hour)
149         {
150             return int(trunc((*this / one_hour)\&.get_value()));
151         }
152         else
153         {
154             return 0;
155         }
156     }
.fi

.SS "\fBint\fP scifir::time_duration::get_minutes () const"

.PP
Definition at line \fB158\fP of file \fBunit_basic\&.cpp\fP\&..PP
.nf
159     {
160         scifir::time_duration one_minute = scifir::time_duration("1min");
161         if (*this >= one_minute)
162         {
163             return int(trunc((*this / one_minute)\&.get_value()));
164         }
165         else
166         {
167             return 0;
168         }
169     }
.fi

.SS "\fBint\fP scifir::time_duration::get_months () const"

.PP
Definition at line \fB106\fP of file \fBunit_basic\&.cpp\fP\&..PP
.nf
107     {
108         scifir::time_duration one_month("30d");
109         if (*this >= one_month)
110         {
111             return int(trunc((*this / one_month)\&.get_value()));
112         }
113         else
114         {
115             return 0;
116         }
117     }
.fi

.SS "\fBint\fP scifir::time_duration::get_seconds () const"

.PP
Definition at line \fB171\fP of file \fBunit_basic\&.cpp\fP\&..PP
.nf
172     {
173         scifir::time_duration one_second("1s");
174         if (*this >= one_second)
175         {
176             return int(trunc((*this / one_second)\&.get_value()));
177         }
178         else
179         {
180             return 0;
181         }
182     }
.fi

.SS "\fBint\fP scifir::time_duration::get_weeks () const"

.PP
Definition at line \fB119\fP of file \fBunit_basic\&.cpp\fP\&..PP
.nf
120     {
121         scifir::time_duration one_week("7d");
122         if (*this >= one_week)
123         {
124             return int(trunc((*this / one_week)\&.get_value()));
125         }
126         else
127         {
128             return 0;
129         }
130     }
.fi

.SS "\fBint\fP scifir::time_duration::get_years () const"

.PP
Definition at line \fB93\fP of file \fBunit_basic\&.cpp\fP\&..PP
.nf
94     {
95         scifir::time_duration one_year ("365d");
96         if (*this >= one_year)
97         {
98             return int(trunc((*this / one_year)\&.get_value()));
99         }
100         else
101         {
102             return 0;
103         }
104     }
.fi

.SS "\fBfloat\fP scifir::grade_to_radian (\fBfloat\fP x)\fC [inline]\fP"

.PP
Definition at line \fB22\fP of file \fBangle\&.hpp\fP\&..PP
.nf
23     {
24         return x * PI / 180\&.0f;
25     }
.fi

.SS "\fBdirection::name\fP scifir::invert (\fBdirection::name\fP x)"

.PP
Definition at line \fB167\fP of file \fBdirection\&.cpp\fP\&..PP
.nf
168     {
169         if (x == direction::LEFT)
170         {
171             return direction::RIGHT;
172         }
173         else if (x == direction::RIGHT)
174         {
175             return direction::LEFT;
176         }
177         else if (x == direction::TOP)
178         {
179             return direction::BOTTOM;
180         }
181         else if (x == direction::BOTTOM)
182         {
183             return direction::TOP;
184         }
185         else if (x == direction::FRONT)
186         {
187             return direction::BACK;
188         }
189         else if (x == direction::BACK)
190         {
191             return direction::FRONT;
192         }
193         else if (x == direction::LEFT_TOP)
194         {
195             return direction::RIGHT_BOTTOM;
196         }
197         else if (x == direction::LEFT_BOTTOM)
198         {
199             return direction::RIGHT_TOP;
200         }
201         else if (x == direction::RIGHT_TOP)
202         {
203             return direction::LEFT_BOTTOM;
204         }
205         else if (x == direction::RIGHT_BOTTOM)
206         {
207             return direction::LEFT_TOP;
208         }
209         else if (x == direction::LEFT_FRONT)
210         {
211             return direction::RIGHT_BACK;
212         }
213         else if (x == direction::LEFT_BACK)
214         {
215             return direction::RIGHT_FRONT;
216         }
217         else if (x == direction::RIGHT_FRONT)
218         {
219             return direction::LEFT_BACK;
220         }
221         else if (x == direction::RIGHT_BACK)
222         {
223             return direction::LEFT_FRONT;
224         }
225         else if (x == direction::TOP_FRONT)
226         {
227             return direction::BOTTOM_BACK;
228         }
229         else if (x == direction::TOP_BACK)
230         {
231             return direction::BOTTOM_FRONT;
232         }
233         else if (x == direction::BOTTOM_FRONT)
234         {
235             return direction::TOP_BACK;
236         }
237         else if (x == direction::BOTTOM_BACK)
238         {
239             return direction::TOP_FRONT;
240         }
241         else if (x == direction::LEFT_TOP_FRONT)
242         {
243             return direction::RIGHT_BOTTOM_BACK;
244         }
245         else if (x == direction::LEFT_TOP_BACK)
246         {
247             return direction::RIGHT_BOTTOM_FRONT;
248         }
249         else if (x == direction::LEFT_BOTTOM_FRONT)
250         {
251             return direction::RIGHT_TOP_BACK;
252         }
253         else if (x == direction::LEFT_BOTTOM_BACK)
254         {
255             return direction::RIGHT_TOP_FRONT;
256         }
257         else if (x == direction::RIGHT_TOP_FRONT)
258         {
259             return direction::LEFT_BOTTOM_BACK;
260         }
261         else if (x == direction::RIGHT_TOP_BACK)
262         {
263             return direction::LEFT_BOTTOM_FRONT;
264         }
265         else if (x == direction::RIGHT_BOTTOM_FRONT)
266         {
267             return direction::LEFT_TOP_BACK;
268         }
269         else if (x == direction::RIGHT_BOTTOM_BACK)
270         {
271             return direction::LEFT_TOP_FRONT;
272         }
273         else
274         {
275             return direction::NONE;
276         }
277     }
.fi

.SS "\fBbool\fP scifir::is_angle (\fBconst\fP \fBstring\fP & init_angle)"

.PP
Definition at line \fB246\fP of file \fBangle\&.cpp\fP\&..PP
.nf
247     {
248         icu::UnicodeString x_unicode = icu::UnicodeString(init_angle\&.c_str());
249         int total_chars = x_unicode\&.countChar32();
250         if (x_unicode[total_chars \- 1] == 0x00B0 || x_unicode[total_chars \- 1] == 0x00BA)
251         {
252             bool dot_present = false;
253             for (int i = 0; i < (total_chars \- 1); i++)
254             {
255                 if (x_unicode[i] == '\&.')
256                 {
257                     if (dot_present)
258                     {
259                         return false;
260                     }
261                     else
262                     {
263                         dot_present = true;
264                     }
265                 }
266                 else if (!u_isdigit(x_unicode[i]))
267                 {
268                     return false;
269                 }
270             }
271             return true;
272         }
273         else
274         {
275             return false;
276         }
277     }
.fi

.SS "\fBbool\fP scifir::is_complex (\fBconst\fP \fBstring\fP & init_complex_number)"

.PP
Definition at line \fB7\fP of file \fBcomplex_number\&.cpp\fP\&..PP
.nf
8     {
9         if ((init_complex_number\&.find("+") != string::npos or init_complex_number\&.find("\-") != string::npos) and init_complex_number\&.length() > 1)
10         {
11             vector<string> numbers;
12             boost::split(numbers,init_complex_number,boost::is_any_of("+\-"));
13             if (numbers\&.size() != 2)
14             {
15                 return false;
16             }
17             int imaginary_length = int(numbers[1]\&.length()) \- 3;
18             if (imaginary_length <= 0)
19             {
20                 return false;
21             }
22             if (numbers[1]\&.substr(imaginary_length) == "(i)")
23             {
24                 bool dot_present = false;
25                 bool after_whitespace = false;
26                 bool after_alpha = false;
27                 boost::trim(numbers[0]);
28                 boost::trim(numbers[1]);
29                 for (unsigned int i = 0; i < numbers[0]\&.length(); i++)
30                 {
31                     if (numbers[0][i] == '\&.')
32                     {
33                         if (dot_present)
34                         {
35                             return false;
36                         }
37                         else
38                         {
39                             dot_present = true;
40                             continue;
41                         }
42                     }
43                     else if (numbers[0][i] == ' ')
44                     {
45                         after_whitespace = true;
46                         continue;
47                     }
48                     else if (!std::isdigit(numbers[0][i]) and after_whitespace == false)
49                     {
50                         return false;
51                     }
52                     else if (after_whitespace == true)
53                     {
54                         if (after_alpha == true and std::isalpha(numbers[0][i]))
55                         {
56                             return false;
57                         }
58                         else if (std::isalpha(numbers[0][i]))
59                         {
60                             continue;
61                         }
62                         else if (std::isdigit(numbers[0][i]))
63                         {
64                             after_alpha = true;
65                         }
66                     }
67                 }
68                 dot_present = false;
69                 after_whitespace = false;
70                 after_alpha = false;
71                 for (unsigned int i = 0; i < imaginary_length; i++)
72                 {
73                     if (numbers[1][i] == '\&.')
74                     {
75                         if (dot_present)
76                         {
77                             return false;
78                         }
79                         else
80                         {
81                             dot_present = true;
82                             continue;
83                         }
84                     }
85                     else if (numbers[1][i] == ' ')
86                     {
87                         after_whitespace = true;
88                         continue;
89                     }
90                     else if (!std::isdigit(numbers[1][i]) and after_whitespace == false)
91                     {
92                         return false;
93                     }
94                     else if (after_whitespace == true)
95                     {
96                         if (after_alpha == true and std::isalpha(numbers[1][i]))
97                         {
98                             return false;
99                         }
100                         else if (std::isalpha(numbers[1][i]))
101                         {
102                             continue;
103                         }
104                         else if (std::isdigit(numbers[1][i]))
105                         {
106                             after_alpha = true;
107                         }
108                     }
109                 }
110                 return true;
111             }
112             else
113             {
114                 return false;
115             }
116         }
117         else
118         {
119             return false;
120         }
121     }
.fi

.SS "\fBbool\fP scifir::is_lab_number (\fBconst\fP \fBstring\fP & init_lab_number)"

.PP
Definition at line \fB7\fP of file \fBlab_number\&.cpp\fP\&..PP
.nf
8     {
9         if ((init_lab_number\&.find("\\u00B1") != string::npos or init_lab_number\&.find("+") != string::npos or init_lab_number\&.find("\-") != string::npos) and init_lab_number\&.length() > 1)
10         {
11             vector<string> numbers;
12             boost::split(numbers,init_lab_number,boost::is_any_of("+\-,\\u00B1"));
13             if (numbers\&.size() != 3)
14             {
15                 return false;
16             }
17             if (numbers[2]\&.length() < 1)
18             {
19                 return false;
20             }
21             bool dot_present = false;
22             bool after_whitespace = false;
23             bool after_alpha = false;
24             boost::trim(numbers[0]);
25             boost::trim(numbers[2]);
26             for (unsigned int i = 0; i < numbers[0]\&.length(); i++)
27             {
28                 if (numbers[0][i] == '\&.')
29                 {
30                     if (dot_present)
31                     {
32                         return false;
33                     }
34                     else
35                     {
36                         dot_present = true;
37                         continue;
38                     }
39                 }
40                 else if (numbers[0][i] == ' ')
41                 {
42                     after_whitespace = true;
43                     continue;
44                 }
45                 else if (!std::isdigit(numbers[0][i]) and after_whitespace == false)
46                 {
47                     return false;
48                 }
49                 else if (after_whitespace == true)
50                 {
51                     if (after_alpha == true and std::isalpha(numbers[0][i]))
52                     {
53                         return false;
54                     }
55                     else if (std::isalpha(numbers[0][i]))
56                     {
57                         continue;
58                     }
59                     else if (std::isdigit(numbers[0][i]))
60                     {
61                         after_alpha = true;
62                     }
63                 }
64             }
65             dot_present = false;
66             after_whitespace = false;
67             after_alpha = false;
68             for (unsigned int i = 0; i < numbers[2]\&.length(); i++)
69             {
70                 if (numbers[2][i] == '\&.')
71                 {
72                     if (dot_present)
73                     {
74                         return false;
75                     }
76                     else
77                     {
78                         dot_present = true;
79                         continue;
80                     }
81                 }
82                 else if (numbers[2][i] == ' ')
83                 {
84                     after_whitespace = true;
85                     continue;
86                 }
87                 else if (!std::isdigit(numbers[2][i]) and after_whitespace == false)
88                 {
89                     return false;
90                 }
91                 else if (after_whitespace == true)
92                 {
93                     if (after_alpha == true and std::isalpha(numbers[2][i]))
94                     {
95                         return false;
96                     }
97                     else if (std::isalpha(numbers[2][i]))
98                     {
99                         continue;
100                     }
101                     else if (std::isdigit(numbers[2][i]))
102                     {
103                         after_alpha = true;
104                     }
105                 }
106             }
107             return true;
108         }
109         else
110         {
111             return false;
112         }
113     }
.fi

.SS "\fBbool\fP scifir::is_percentage (\fBconst\fP \fBstring\fP & init_percentage)"

.PP
Definition at line \fB424\fP of file \fBpercentage\&.cpp\fP\&..PP
.nf
425     {
426         int iteration_limit;
427         if (init_percentage\&.back() == '%')
428         {
429             iteration_limit = int(init_percentage\&.length()) \- 1;
430         }
431         else
432         {
433             string percentage_unit = init_percentage\&.substr(init_percentage\&.length() \- 4,4);
434             if (percentage_unit == " ppm"/* or percentage_unit == " ppb" or percentage_unit == " ppt" or percentage_unit == " ppq"*/)
435             {
436                 iteration_limit = int(init_percentage\&.length()) \- 4;
437             }
438             else
439             {
440                 percentage_unit = init_percentage\&.substr(init_percentage\&.length() \- 3,3);
441                 if (percentage_unit == "ppm"/* or percentage_unit == "ppb" or percentage_unit == "ppt" or percentage_unit == "ppq"*/)
442                 {
443                     iteration_limit = int(init_percentage\&.length()) \- 3;
444                 }
445                 else
446                 {
447                     return false;
448                 }
449             }
450         }
451         bool dot_present = false;
452         for (int i = 0; i < iteration_limit; i++)
453         {
454             if (init_percentage[i] == '\&.')
455             {
456                 if (dot_present)
457                 {
458                     return false;
459                 }
460                 else
461                 {
462                     dot_present = true;
463                 }
464             }
465             else if (!std::isdigit(init_percentage[i]))
466             {
467                 return false;
468             }
469         }
470         return true;
471     }
.fi

.SS "\fBbool\fP scifir::is_pixel (\fBconst\fP \fBstring\fP & init_pixel)"

.PP
Definition at line \fB191\fP of file \fBpixel\&.cpp\fP\&..PP
.nf
192     {
193         int iteration_limit;
194         if (init_pixel\&.substr(init_pixel\&.length() \- 3,3) == " px")
195         {
196             iteration_limit = int(init_pixel\&.length()) \- 3;
197         }
198         else if (init_pixel\&.substr(init_pixel\&.length() \- 2,2) == "px")
199         {
200             iteration_limit = int(init_pixel\&.length()) \- 2;
201         }
202         else
203         {
204             iteration_limit = int(init_pixel\&.length());
205         }
206         bool dot_present = false;
207         for (int i = 0; i < iteration_limit; i++)
208         {
209             if (init_pixel[i] == '\&.')
210             {
211                 if (dot_present)
212                 {
213                     return false;
214                 }
215                 else
216                 {
217                     dot_present = true;
218                 }
219             }
220             else if (!std::isdigit(init_pixel[i]))
221             {
222                 return false;
223             }
224         }
225         return true;
226     }
.fi

.SS "\fBbool\fP scifir::is_scalar_unit (\fBconst\fP \fBstring\fP & init_scalar)"

.PP
Checks if an string is an initialization string of a \fBscalar_unit\fP\&. 
.PP
\fBParameters\fP
.RS 4
\fIinit_scalar\fP string to check\&. It must be an initialization string of a \fBscalar_unit\fP to return true\&. 
.RE
.PP

.PP
Definition at line \fB542\fP of file \fBscalar_unit\&.cpp\fP\&..PP
.nf
543     {
544         bool dot_present = false;
545         bool e_present = false;
546         unsigned int current_pos = 0;
547         int e_present_pos = 0;
548         for (unsigned int i = 0; i < init_scalar\&.length(); i++)
549         {
550             if (init_scalar[i] == ' ')
551             {
552                 if (e_present and ((unsigned int)(e_present_pos + 1) == i))
553                 {
554                     return false;
555                 }
556                 current_pos = i;
557                 break;
558             }
559             if (e_present == false)
560             {
561                 if (init_scalar[i] == '\&.')
562                 {
563                     if (dot_present)
564                     {
565                         return false;
566                     }
567                     else
568                     {
569                         dot_present = true;
570                     }
571                 }
572                 else if (init_scalar[i] == 'e' or init_scalar[i] == 'E')
573                 {
574                     e_present = true;
575                     e_present_pos = i;
576                     continue;
577                 }
578                 else if (init_scalar[i] == '*')
579                 {
580                     if (!(init_scalar\&.substr(i + 1,3) == "10^"))
581                     {
582                         return false;
583                     }
584                     else
585                     {
586                         e_present = true;
587                         i += 3;
588                         e_present_pos = i;
589                         continue;
590                     }
591                 }
592                 else if (!isdigit(init_scalar[i]))
593                 {
594                     return false;
595                 }
596                 else if (i == (init_scalar\&.length() \- 1))
597                 {
598                     return false;
599                 }
600             }
601             else
602             {
603                 if (!isdigit(init_scalar[i]))
604                 {
605                     return false;
606                 }
607             }
608         }
609         if (current_pos == (init_scalar\&.length() \- 1))
610         {
611             return false;
612         }
613         if (current_pos == 0)
614         {
615             return false;
616         }
617         vector<string> values;
618         boost::split(values,init_scalar\&.substr(current_pos),boost::is_any_of("/"));
619         if (values\&.size() == 1)
620         {
621             vector<string> subvalues;
622             boost::split(subvalues,values[0],boost::is_any_of("*"));
623             for (string& x_subvalue : subvalues)
624             {
625                 boost::trim(x_subvalue);
626                 bool number_present = false;
627                 for (unsigned int i = 0; i < x_subvalue\&.length(); i++)
628                 {
629                     if (number_present == false)
630                     {
631                         if (isdigit(x_subvalue[i]))
632                         {
633                             number_present = true;
634                             continue;
635                         }
636                         else if (!isalpha(x_subvalue[i]))
637                         {
638                             return false;
639                         }
640                     }
641                     else
642                     {
643                         if (!isdigit(x_subvalue[i]))
644                         {
645                             return false;
646                         }
647                     }
648                 }
649             }
650             return true;
651         }
652         else if (values\&.size() == 2)
653         {
654             if (values[0] != "1")
655             {
656                 vector<string> subvalues;
657                 boost::split(subvalues,values[0],boost::is_any_of("*"));
658                 for (string& x_subvalue : subvalues)
659                 {
660                     boost::trim(x_subvalue);
661                     bool number_present = false;
662                     for (unsigned int i = 0; i < x_subvalue\&.length(); i++)
663                     {
664                         if (number_present == false)
665                         {
666                             if (isdigit(x_subvalue[i]))
667                             {
668                                 number_present = true;
669                                 continue;
670                             }
671                             else if (!isalpha(x_subvalue[i]))
672                             {
673                                 return false;
674                             }
675                         }
676                         else
677                         {
678                             if (!isdigit(x_subvalue[i]))
679                             {
680                                 return false;
681                             }
682                         }
683                     }
684                 }
685             }
686             vector<string> subvalues_denominator;
687             boost::split(subvalues_denominator,values[1],boost::is_any_of("*"));
688             for (string& x_subvalue : subvalues_denominator)
689             {
690                 boost::trim(x_subvalue);
691                 bool number_present = false;
692                 for (unsigned int i = 0; i < x_subvalue\&.length(); i++)
693                 {
694                     if (number_present == false)
695                     {
696                         if (isdigit(x_subvalue[i]))
697                         {
698                             number_present = true;
699                             continue;
700                         }
701                         else if (!isalpha(x_subvalue[i]))
702                         {
703                             return false;
704                         }
705                     }
706                     else
707                     {
708                         if (!isdigit(x_subvalue[i]))
709                         {
710                             return false;
711                         }
712                     }
713                 }
714             }
715             return true;
716         }
717         return false;
718     }
.fi

.SS "scifir::mass::mass (\fBconst\fP \fBpercentage\fP & new_percentage, \fBconst\fP mass & new_mass)"

.PP
Definition at line \fB308\fP of file \fBunit_basic\&.cpp\fP\&..PP
.nf
308                                                                     : scalar_unit()
309     {
310         dimensions = new_mass\&.get_dimensions();
311         value = new_percentage * new_mass\&.get_value();
312     }
.fi

.SS "scifir::mass::mass (\fBconst\fP \fBstring\fP & init_percentage, \fBconst\fP \fBstring\fP & init_mass)"

.PP
Definition at line \fB314\fP of file \fBunit_basic\&.cpp\fP\&..PP
.nf
314                                                                     : scalar_unit()
315     {
316         initialize_from_string(init_mass);
317         percentage new_percentage = percentage(init_percentage);
318         value = new_percentage * value;
319     }
.fi

.SS "scifir::mole::mole (\fBconst\fP \fBpercentage\fP & new_percentage, \fBconst\fP mole & new_mole)"

.PP
Definition at line \fB325\fP of file \fBunit_basic\&.cpp\fP\&..PP
.nf
325                                                                     : scalar_unit()
326     {
327         dimensions = new_mole\&.get_dimensions();
328         value = new_percentage * new_mole\&.get_value();
329     }
.fi

.SS "scifir::mole::mole (\fBconst\fP \fBstring\fP & init_percentage, \fBconst\fP \fBstring\fP & init_mole)"

.PP
Definition at line \fB331\fP of file \fBunit_basic\&.cpp\fP\&..PP
.nf
331                                                                     : scalar_unit()
332     {
333         initialize_from_string(init_mole);
334         percentage new_percentage = percentage(init_percentage);
335         value = new_percentage * value;
336     }
.fi

.SS "vector< \fBdimension\fP > scifir::multiply_dimensions (\fBconst\fP vector< \fBdimension\fP > & x, \fBconst\fP vector< \fBdimension\fP > & y)"

.PP
Definition at line \fB1379\fP of file \fBdimension\&.cpp\fP\&..PP
.nf
1380     {
1381         vector<dimension> new_dimensions = x;
1382         for(const dimension& y_dimension : y)
1383         {
1384             new_dimensions\&.push_back(y_dimension);
1385         }
1386         return new_dimensions;
1387     }
.fi

.SS "vector< \fBdimension\fP > scifir::multiply_dimensions (vector< \fBdimension\fP > x, \fBconst\fP vector< \fBdimension\fP > & y, \fBlong\fP \fBdouble\fP & value)"

.PP
Definition at line \fB1389\fP of file \fBdimension\&.cpp\fP\&..PP
.nf
1390     {
1391         for(const dimension& y_dimension : y)
1392         {
1393             x\&.push_back(y_dimension);
1394         }
1395         return normalize_dimensions(x,value);
1396     }
.fi

.SS "\fBscalar_unit\fP scifir::norm (\fBconst\fP \fBvector_unit_2d\fP & x)"

.PP
Definition at line \fB321\fP of file \fBvector_unit_2d\&.cpp\fP\&..PP
.nf
322     {
323         return scalar_unit(std::abs(x\&.get_value()),x\&.get_dimensions());
324     }
.fi

.SS "\fBscalar_unit\fP scifir::norm (\fBconst\fP \fBvector_unit_3d\fP & x)"

.PP
Definition at line \fB426\fP of file \fBvector_unit_3d\&.cpp\fP\&..PP
.nf
427     {
428         return scalar_unit(std::abs(x\&.get_value()),x\&.get_dimensions());
429     }
.fi

.SS "\fBscalar_unit\fP scifir::norm (\fBconst\fP \fBvector_unit_nd\fP & x)"

.PP
Definition at line \fB742\fP of file \fBvector_unit_nd\&.cpp\fP\&..PP
.nf
743     {
744         return scalar_unit(std::abs(x\&.get_value()),x\&.get_dimensions());
745     }
.fi

.SS "vector< \fBdimension\fP > scifir::normalize_dimensions (\fBconst\fP vector< \fBdimension\fP > & x)"

.PP
Definition at line \fB1493\fP of file \fBdimension\&.cpp\fP\&..PP
.nf
1494     {
1495         vector<dimension> new_x = create_derived_dimensions(x);
1496         vector<unsigned int> skip_dimensions = vector<unsigned int>();
1497         for(unsigned int i = 0; i < new_x\&.size(); i++)
1498         {
1499             for(unsigned int j = i + 1; j < new_x\&.size(); j++)
1500             {
1501                 if (skip_dimensions\&.size() > 0)
1502                 {
1503                     bool skip = false;
1504                     for(unsigned int k = 0; k < skip_dimensions\&.size(); k++)
1505                     {
1506                         if (j == skip_dimensions[k])
1507                         {
1508                             skip = true;
1509                         }
1510                     }
1511                     if (skip)
1512                     {
1513                         continue;
1514                     }
1515                 }
1516                 if (new_x[i]\&.dimension_type == new_x[j]\&.dimension_type and new_x[i]\&.dimension_sign != new_x[j]\&.dimension_sign)
1517                 {
1518                     skip_dimensions\&.push_back(i);
1519                     skip_dimensions\&.push_back(j);
1520                     break;
1521                 }
1522             }
1523         }
1524         vector<dimension> new_dimensions = vector<dimension>();
1525         for(unsigned int i = 0; i < new_x\&.size(); i++)
1526         {
1527             bool skip = false;
1528             for(unsigned int j = 0; j < skip_dimensions\&.size(); j++)
1529             {
1530                 if (i == skip_dimensions[j])
1531                 {
1532                     skip = true;
1533                 }
1534             }
1535             if (!skip)
1536             {
1537                 new_dimensions\&.push_back(new_x[i]);
1538             }
1539         }
1540         return new_dimensions;
1541     }
.fi

.SS "vector< \fBdimension\fP > scifir::normalize_dimensions (\fBconst\fP vector< \fBdimension\fP > & x, \fBlong\fP \fBdouble\fP & value)"

.PP
Definition at line \fB1543\fP of file \fBdimension\&.cpp\fP\&..PP
.nf
1544     {
1545         vector<dimension> new_x = create_derived_dimensions(x,value);
1546         vector<unsigned int> skip_dimensions = vector<unsigned int>();
1547         for(unsigned int i = 0; i < new_x\&.size(); i++)
1548         {
1549             for(unsigned int j = i + 1; j < new_x\&.size(); j++)
1550             {
1551                 if (skip_dimensions\&.size() > 0)
1552                 {
1553                     bool skip = false;
1554                     for(unsigned int k = 0; k < skip_dimensions\&.size(); k++)
1555                     {
1556                         if (j == skip_dimensions[k])
1557                         {
1558                             skip = true;
1559                         }
1560                     }
1561                     if (skip)
1562                     {
1563                         continue;
1564                     }
1565                 }
1566                 if (new_x[i]\&.dimension_type == new_x[j]\&.dimension_type and new_x[i]\&.dimension_sign != new_x[j]\&.dimension_sign)
1567                 {
1568                     if (new_x[i]\&.dimension_sign == dimension::NUMERATOR)
1569                     {
1570                         value *= float(new_x[i]\&.get_conversion_factor());
1571                         value *= float(new_x[i]\&.prefix_math());
1572                     }
1573                     else if (new_x[i]\&.dimension_sign == dimension::DENOMINATOR)
1574                     {
1575                         value /= float(new_x[i]\&.get_conversion_factor());
1576                         value /= float(new_x[i]\&.prefix_math());
1577                     }
1578                     if (new_x[j]\&.dimension_sign == dimension::NUMERATOR)
1579                     {
1580                         value *= float(new_x[j]\&.get_conversion_factor());
1581                         value *= float(new_x[j]\&.prefix_math());
1582                     }
1583                     else if (new_x[j]\&.dimension_sign == dimension::DENOMINATOR)
1584                     {
1585                         value /= float(new_x[j]\&.get_conversion_factor());
1586                         value /= float(new_x[j]\&.prefix_math());
1587                     }
1588                     skip_dimensions\&.push_back(i);
1589                     skip_dimensions\&.push_back(j);
1590                     break;
1591                 }
1592             }
1593         }
1594         vector<dimension> new_dimensions = vector<dimension>();
1595         for(unsigned int i = 0; i < new_x\&.size(); i++)
1596         {
1597             bool skip = false;
1598             for(unsigned int j = 0; j < skip_dimensions\&.size(); j++)
1599             {
1600                 if (i == skip_dimensions[j])
1601                 {
1602                     skip = true;
1603                     break;
1604                 }
1605             }
1606             if (!skip)
1607             {
1608                 new_dimensions\&.push_back(new_x[i]);
1609             }
1610         }
1611         return new_dimensions;
1612     }
.fi

.SS "\fBint\fP scifir::mole::number_of_particles () const"

.PP
Definition at line \fB338\fP of file \fBunit_basic\&.cpp\fP\&..PP
.nf
339     {
340         return 1;
341         /*if (scalar_unit::actual_dimensions\&.count(particles))
342         {
343             return scalar_unit::value;
344         }
345         else
346         {
347             return scalar_unit::value * scifir::AVOGADRO_CONSTANT;
348         }*/
349     }
.fi

.SS "template<\fBtypename\fP \fBT1\fP , \fBtypename\fP \fBT2\fP > \fBscifir::time_duration\fP & \fBscifir::operator\fP+= (chrono::duration< \fBT1\fP, \fBT2\fP > x)"

.PP
Definition at line \fB44\fP of file \fBunit_basic\&.hpp\fP\&..PP
.nf
45             {
46                  chrono::seconds d = chrono::duration_cast<chrono::seconds>(x);
47                  scifir::time_duration x_second = scifir::time_duration((long double)d\&.count(),"s");
48                  scalar_unit::operator+=(x_second);
49                  return *this;
50             }
.fi

.SS "template<\fBtypename\fP \fBT1\fP , \fBtypename\fP \fBT2\fP > \fBscifir::time_duration\fP & \fBscifir::operator\fP\-= (chrono::duration< \fBT1\fP, \fBT2\fP > x)"

.PP
Definition at line \fB53\fP of file \fBunit_basic\&.hpp\fP\&..PP
.nf
54             {
55                  chrono::seconds d = chrono::duration_cast<chrono::seconds>(x);
56                  scifir::time_duration x_second = scifir::time_duration((long double)d\&.count(),"s");
57                  scalar_unit::operator\-=(x_second);
58                  return *this;
59             }
.fi

.SS "\fBbool\fP scifir::orthogonal (\fBconst\fP \fBangle\fP & x, \fBconst\fP \fBangle\fP & y)"

.PP
Definition at line \fB291\fP of file \fBangle\&.cpp\fP\&..PP
.nf
292     {
293         float difference = std::abs((x \- y)\&.get_value());
294         if (difference == 90\&.0f or difference == 270\&.0f)
295         {
296             return true;
297         }
298         else
299         {
300             return false;
301         }
302     }
.fi

.SS "\fBbool\fP scifir::orthogonal (\fBconst\fP \fBvector_unit_2d\fP & x, \fBconst\fP \fBvector_unit_2d\fP & y)"

.PP
Definition at line \fB360\fP of file \fBvector_unit_2d\&.cpp\fP\&..PP
.nf
361     {
362         return scifir::orthogonal(x\&.theta,y\&.theta);
363     }
.fi

.SS "\fBbool\fP scifir::orthogonal (\fBconst\fP \fBvector_unit_3d\fP & x, \fBconst\fP \fBvector_unit_3d\fP & y)"

.PP
Definition at line \fB501\fP of file \fBvector_unit_3d\&.cpp\fP\&..PP
.nf
502     {
503         scifir::angle x_angle = angle_between(x,y);
504         return (x_angle == 90\&.0f);
505     }
.fi

.SS "\fBbool\fP scifir::orthogonal (\fBconst\fP \fBvector_unit_nd\fP & x, \fBconst\fP \fBvector_unit_nd\fP & y)"

.PP
Definition at line \fB855\fP of file \fBvector_unit_nd\&.cpp\fP\&..PP
.nf
856     {
857         if (same_nd(x,y))
858         {
859             if (x\&.get_nd() == 1)
860             {
861                 return false;
862             }
863             else if (x\&.get_nd() == 2)
864             {
865                 return scifir::orthogonal(x\&.angles[0],y\&.angles[0]);
866             }
867             else if (x\&.get_nd() == 3)
868             {
869                 scifir::angle x_angle = angle_between(x,y);
870                 return (x_angle == 90\&.0f);
871             }
872         }
873         return false;
874     }
.fi

.SS "\fBbool\fP scifir::parallel (\fBconst\fP \fBangle\fP & x, \fBconst\fP \fBangle\fP & y)"

.PP
Definition at line \fB279\fP of file \fBangle\&.cpp\fP\&..PP
.nf
280     {
281         if(x == y or (x + 180\&.0f) == y)
282         {
283             return true;
284         }
285         else
286         {
287             return false;
288         }
289     }
.fi

.SS "\fBbool\fP scifir::parallel (\fBconst\fP \fBvector_unit_2d\fP & x, \fBconst\fP \fBvector_unit_2d\fP & y)"

.PP
Definition at line \fB355\fP of file \fBvector_unit_2d\&.cpp\fP\&..PP
.nf
356     {
357         return scifir::parallel(x\&.theta,y\&.theta);
358     }
.fi

.SS "\fBbool\fP scifir::parallel (\fBconst\fP \fBvector_unit_3d\fP & x, \fBconst\fP \fBvector_unit_3d\fP & y)"

.PP
Definition at line \fB489\fP of file \fBvector_unit_3d\&.cpp\fP\&..PP
.nf
490     {
491         if ((x\&.theta == y\&.theta and x\&.phi == y\&.phi) or (x\&.theta == (180\&.0f + y\&.theta) and x\&.phi == (180\&.0f \- y\&.phi)))
492         {
493             return true;
494         }
495         else
496         {
497             return false;
498         }
499     }
.fi

.SS "\fBbool\fP scifir::parallel (\fBconst\fP \fBvector_unit_nd\fP & x, \fBconst\fP \fBvector_unit_nd\fP & y)"

.PP
Definition at line \fB828\fP of file \fBvector_unit_nd\&.cpp\fP\&..PP
.nf
829     {
830         if (same_nd(x,y))
831         {
832             if (x\&.get_nd() == 1)
833             {
834                 return true;
835             }
836             else if (x\&.get_nd() == 2)
837             {
838                 return scifir::parallel(x\&.angles[0],y\&.angles[0]);
839             }
840             else if (x\&.get_nd() == 3)
841             {
842                 if ((x\&.angles[0] == y\&.angles[0] and x\&.angles[1] == y\&.angles[1]) or (x\&.angles[0] == (180\&.0f + y\&.angles[0]) and x\&.angles[1] == (180\&.0f \- y\&.angles[1])))
843                 {
844                     return true;
845                 }
846                 else
847                 {
848                     return false;
849                 }
850             }
851         }
852         return false;
853     }
.fi

.SS "\fBfloat\fP scifir::parse_float (\fBconst\fP \fBstring\fP & x)"

.PP
Definition at line \fB10\fP of file \fBtypes\&.cpp\fP\&..PP
.nf
11     {
12         try
13         {
14             float value = stof(x);
15             return value;
16         }
17         catch (const exception& e)
18         {
19             return 0;
20         }
21     }
.fi

.SS "\fBint\fP scifir::parse_int (\fBconst\fP \fBstring\fP & x)"

.PP
Definition at line \fB23\fP of file \fBtypes\&.cpp\fP\&..PP
.nf
24     {
25         try
26         {
27             int value = stoi(x);
28             return value;
29         }
30         catch (const exception& e)
31         {
32             return 0;
33         }
34     }
.fi

.SS "\fBscalar_unit\fP scifir::polar_to_cartesian_2d_x (\fBconst\fP \fBscalar_unit\fP & p, \fBconst\fP \fBangle\fP & theta)\fC [inline]\fP"

.PP
Definition at line \fB386\fP of file \fBcoordinates_2d\&.hpp\fP\&..PP
.nf
387     {
388         return p * scifir::cos(theta);
389     }
.fi

.SS "\fBfloat\fP scifir::polar_to_cartesian_2d_x (\fBfloat\fP p, \fBconst\fP \fBangle\fP & theta)\fC [inline]\fP"

.PP
Definition at line \fB406\fP of file \fBcoordinates_2d\&.hpp\fP\&..PP
.nf
407     {
408         return p * scifir::cos(theta);
409     }
.fi

.SS "\fBscalar_unit\fP scifir::polar_to_cartesian_2d_y (\fBconst\fP \fBscalar_unit\fP & p, \fBconst\fP \fBangle\fP & theta)\fC [inline]\fP"

.PP
Definition at line \fB391\fP of file \fBcoordinates_2d\&.hpp\fP\&..PP
.nf
392     {
393         return p * scifir::sin(theta);
394     }
.fi

.SS "\fBfloat\fP scifir::polar_to_cartesian_2d_y (\fBfloat\fP p, \fBconst\fP \fBangle\fP & theta)\fC [inline]\fP"

.PP
Definition at line \fB411\fP of file \fBcoordinates_2d\&.hpp\fP\&..PP
.nf
412     {
413         return p * scifir::sin(theta);
414     }
.fi

.SS "\fBscalar_unit\fP scifir::pow (\fBconst\fP \fBscalar_unit\fP & x, \fBint\fP exponent)"

.PP
Exponentiates a \fBscalar_unit\fP to some numeric type, the dimensions are also exponentiated\&. 
.PP
Definition at line \fB725\fP of file \fBscalar_unit\&.cpp\fP\&..PP
.nf
726     {
727         return x ^ exponent;
728     }
.fi

.SS "vector< \fBdimension\fP > scifir::power_dimensions (\fBconst\fP vector< \fBdimension\fP > & x, \fBint\fP exponent)"

.PP
Definition at line \fB1480\fP of file \fBdimension\&.cpp\fP\&..PP
.nf
1481     {
1482         vector<dimension> new_dimensions = vector<dimension>();
1483         for (const dimension& x_dimension: x)
1484         {
1485             for (int j = 1; j <= exponent; j++)
1486             {
1487                 new_dimensions\&.push_back(x_dimension);
1488             }
1489         }
1490         return new_dimensions;
1491     }
.fi

.SS "\fBprefix::type\fP scifir::prefix_string (\fBconst\fP \fBstring\fP & x)"

.PP
Definition at line \fB191\fP of file \fBprefix\&.cpp\fP\&..PP
.nf
192     {
193         if (x == "Y")
194         {
195             return prefix::Y;
196         }
197         else if (x == "Z")
198         {
199             return prefix::Z;
200         }
201         else if (x == "E")
202         {
203             return prefix::E;
204         }
205         else if (x == "P")
206         {
207             return prefix::P;
208         }
209         else if (x == "T")
210         {
211             return prefix::T;
212         }
213         else if(x == "G")
214         {
215             return prefix::G;
216         }
217         else if(x == "M")
218         {
219             return prefix::M;
220         }
221         else if(x == "k")
222         {
223             return prefix::k;
224         }
225         else if(x == "h")
226         {
227             return prefix::h;
228         }
229         else if(x == "da")
230         {
231             return prefix::da;
232         }
233         else if(x == "d")
234         {
235             return prefix::d;
236         }
237         else if(x == "c")
238         {
239             return prefix::c;
240         }
241         else if(x == "m")
242         {
243             return prefix::m;
244         }
245         else if(x == "u" or x == "\\u00B5")
246         {
247             return prefix::u;
248         }
249         else if(x == "n")
250         {
251             return prefix::n;
252         }
253         else if(x == "p")
254         {
255             return prefix::p;
256         }
257         else if(x == "f")
258         {
259             return prefix::f;
260         }
261         else if(x == "a")
262         {
263             return prefix::a;
264         }
265         else if(x == "z")
266         {
267             return prefix::z;
268         }
269         else if(x == "y")
270         {
271             return prefix::y;
272         }
273         else if (x == "")
274         {
275             return prefix::no_prefix;
276         }
277         else
278         {
279             return prefix::no_prefix;
280         }
281     }
.fi

.SS "\fBfloat\fP scifir::radian_to_grade (\fBfloat\fP x)\fC [inline]\fP"

.PP
Definition at line \fB17\fP of file \fBangle\&.hpp\fP\&..PP
.nf
18     {
19         return x * 180\&.0f / PI;
20     }
.fi

.SS "\fBbool\fP scifir::same_direction (\fBconst\fP \fBvector_unit_2d\fP & x, \fBconst\fP \fBvector_unit_2d\fP & y)"

.PP
Definition at line \fB350\fP of file \fBvector_unit_2d\&.cpp\fP\&..PP
.nf
351     {
352         return x\&.theta == y\&.theta;
353     }
.fi

.SS "\fBbool\fP scifir::same_direction (\fBconst\fP \fBvector_unit_3d\fP & x, \fBconst\fP \fBvector_unit_3d\fP & y)"

.PP
Definition at line \fB477\fP of file \fBvector_unit_3d\&.cpp\fP\&..PP
.nf
478     {
479         if (x\&.theta == y\&.theta and x\&.phi == y\&.phi)
480         {
481             return true;
482         }
483         else
484         {
485             return false;
486         }
487     }
.fi

.SS "\fBbool\fP scifir::same_direction (\fBconst\fP \fBvector_unit_nd\fP & x, \fBconst\fP \fBvector_unit_nd\fP & y)"

.PP
Definition at line \fB816\fP of file \fBvector_unit_nd\&.cpp\fP\&..PP
.nf
817     {
818         for(unsigned int i = 0; i < x\&.angles\&.size(); i++)
819         {
820             if(x\&.angles[i] != y\&.angles[i])
821             {
822                 return false;
823             }
824         }
825         return true;
826     }
.fi

.SS "\fBbool\fP scifir::same_nd (\fBconst\fP \fBvector_unit_nd\fP & x, \fBconst\fP \fBvector_unit_nd\fP & y)"

.PP
Definition at line \fB804\fP of file \fBvector_unit_nd\&.cpp\fP\&..PP
.nf
805     {
806         if(x\&.angles\&.size() == y\&.angles\&.size())
807         {
808             return true;
809         }
810         else
811         {
812             return false;
813         }
814     }
.fi

.SS "scifir::SCALAR_UNIT_CPP (\fBabsorbed_dose\fP, 'm2/\fBs3'\fP)"

.SS "scifir::SCALAR_UNIT_CPP (\fBaction\fP, 'kg*\fBm2\fP/\fBs'\fP)"

.SS "scifir::SCALAR_UNIT_CPP (\fBarea\fP, 'm2')"

.SS "scifir::SCALAR_UNIT_CPP (\fBarea_density\fP, 'g/\fBm2'\fP)"

.SS "scifir::SCALAR_UNIT_CPP (\fBcapacitance\fP, 'A2*\fBs4\fP/\fBm2\fP*\fBkg'\fP)"

.SS "scifir::SCALAR_UNIT_CPP (\fBcatalytic_activity\fP, 'kat')"

.SS "scifir::SCALAR_UNIT_CPP (\fBcatalytic_efficiency\fP, 'm3/s*\fBmol'\fP)"

.SS "scifir::SCALAR_UNIT_CPP (\fBcharge\fP, 'C')"

.SS "scifir::SCALAR_UNIT_CPP (\fBcompressibility\fP, 'm*\fBs2\fP/\fBkg'\fP)"

.SS "scifir::SCALAR_UNIT_CPP (\fBcurvature\fP, '1/m')"

.SS "scifir::SCALAR_UNIT_CPP (data, 'B')"

.SS "scifir::SCALAR_UNIT_CPP (\fBdensity\fP, 'g/\fBm3'\fP)"

.SS "scifir::SCALAR_UNIT_CPP (\fBdiffusion_coefficient\fP, 'm2/\fBs'\fP)"

.SS "scifir::SCALAR_UNIT_CPP (\fBdynamic_viscosity\fP, 'g/m*\fBs'\fP)"

.SS "scifir::SCALAR_UNIT_CPP (\fBelectric_charge_density\fP, 'A*s/\fBm3'\fP)"

.SS "scifir::SCALAR_UNIT_CPP (\fBelectric_conductance\fP, 'A2*\fBs3\fP/\fBkg\fP*\fBm2'\fP)"

.SS "scifir::SCALAR_UNIT_CPP (\fBelectric_current\fP, 'A')"

.SS "scifir::SCALAR_UNIT_CPP (\fBelectric_current_density\fP, 'A/\fBm2'\fP)"

.SS "scifir::SCALAR_UNIT_CPP (\fBelectrical_conductivity\fP, 'A2*\fBs3\fP/\fBkg\fP*\fBm3'\fP)"

.SS "scifir::SCALAR_UNIT_CPP (\fBelectron_mobility\fP, 'A*\fBs2\fP/\fBkg'\fP)"

.SS "scifir::SCALAR_UNIT_CPP (\fBenergy\fP, 'kg*\fBm2\fP/\fBs2'\fP)"

.SS "scifir::SCALAR_UNIT_CPP (\fBenergy_density\fP, 'g/m*\fBs2'\fP)"

.SS "scifir::SCALAR_UNIT_CPP (\fBenergy_flux_density\fP, 'kg/\fBs3'\fP)"

.SS "scifir::SCALAR_UNIT_CPP (\fBenthalpy\fP, 'kg*\fBm2\fP/\fBs2'\fP)"

.SS "scifir::SCALAR_UNIT_CPP (\fBentropy\fP, 'kg*\fBm2\fP/K*\fBs2'\fP)"

.SS "scifir::SCALAR_UNIT_CPP (\fBfrequency\fP, '1/s')"

.SS "scifir::SCALAR_UNIT_CPP (\fBfrequency_drift\fP, '1/s2')"

.SS "scifir::SCALAR_UNIT_CPP (\fBheat_capacity\fP, 'kg*\fBm2\fP/K*\fBs2'\fP)"

.SS "scifir::SCALAR_UNIT_CPP (\fBheat_flux_density\fP, 'kg/\fBs3'\fP)"

.SS "scifir::SCALAR_UNIT_CPP (\fBilluminance\fP, 'lx')"

.SS "scifir::SCALAR_UNIT_CPP (\fBinductance\fP, 'H')"

.SS "scifir::SCALAR_UNIT_CPP (\fBionizing_radiation\fP, 'A*s/\fBkg'\fP)"

.SS "scifir::SCALAR_UNIT_CPP (\fBlength\fP, 'm')"

.SS "scifir::SCALAR_UNIT_CPP (\fBlight\fP, 'cd')"

.SS "scifir::SCALAR_UNIT_CPP (\fBlinear_charge_density\fP, 'A*s/\fBm'\fP)"

.SS "scifir::SCALAR_UNIT_CPP (\fBlinear_mass_density\fP, 'g/\fBm'\fP)"

.SS "scifir::SCALAR_UNIT_CPP (\fBluminance\fP, 'cd/\fBm2'\fP)"

.SS "scifir::SCALAR_UNIT_CPP (\fBluminous_efficacy\fP, 'lm/\fBW'\fP)"

.SS "scifir::SCALAR_UNIT_CPP (\fBluminous_energy\fP, 'cd*\fBsr\fP*\fBs'\fP)"

.SS "scifir::SCALAR_UNIT_CPP (\fBluminous_exposure\fP, 'cd*\fBsr\fP*s/\fBm2'\fP)"

.SS "scifir::SCALAR_UNIT_CPP (\fBluminous_flux\fP, 'lm')"

.SS "scifir::SCALAR_UNIT_CPP (\fBmagnetic_flux\fP, 'Wb')"

.SS "scifir::SCALAR_UNIT_CPP (\fBmagnetic_permeability\fP, 'A2*\fBs2\fP/\fBkg\fP*\fBm'\fP)"

.SS "scifir::SCALAR_UNIT_CPP (\fBmagnetic_reluctance\fP, 'A2*\fBs2\fP/\fBkg\fP*\fBm2'\fP)"

.SS "scifir::SCALAR_UNIT_CPP (\fBmagnetic_rigidity\fP, 'kg*m/A*\fBs2'\fP)"

.SS "scifir::SCALAR_UNIT_CPP (\fBmagnetic_susceptibility\fP, 'A2*\fBs2\fP/\fBkg\fP*\fBm'\fP)"

.SS "scifir::SCALAR_UNIT_CPP (\fBmagnetization\fP, 'A/\fBm'\fP)"

.SS "scifir::SCALAR_UNIT_CPP (\fBmass\fP, 'g')"

.SS "scifir::SCALAR_UNIT_CPP (\fBmass_flow_rate\fP, 'g/\fBs'\fP)"

.SS "scifir::SCALAR_UNIT_CPP (\fBmolality\fP, 'mol/\fBg'\fP)"

.SS "scifir::SCALAR_UNIT_CPP (\fBmolar_conductivity\fP, 's3*\fBA2\fP/g*\fBmol'\fP)"

.SS "scifir::SCALAR_UNIT_CPP (\fBmolar_energy\fP, 'm2*g/\fBs2\fP*\fBmol'\fP)"

.SS "scifir::SCALAR_UNIT_CPP (\fBmolar_enthalpy\fP, 'm2*g/\fBs2\fP*\fBmol'\fP)"

.SS "scifir::SCALAR_UNIT_CPP (\fBmolar_entropy\fP, 'm2*g/\fBs2\fP*K*\fBmol'\fP)"

.SS "scifir::SCALAR_UNIT_CPP (\fBmolar_heat_capacity\fP, 'm2*g/\fBs2\fP*K*\fBmol'\fP)"

.SS "scifir::SCALAR_UNIT_CPP (\fBmolar_mass\fP, 'g/\fBmol'\fP)"

.SS "scifir::SCALAR_UNIT_CPP (\fBmolar_volume\fP, 'm3/\fBmol'\fP)"

.SS "scifir::SCALAR_UNIT_CPP (\fBmolarity\fP, 'mol/\fBm3'\fP)"

.SS "scifir::SCALAR_UNIT_CPP (\fBmole\fP, 'mol')"

.SS "scifir::SCALAR_UNIT_CPP (\fBmoment_of_inertia\fP, 'm2*\fBkg'\fP)"

.SS "scifir::SCALAR_UNIT_CPP (\fBoptical_power\fP, '1/m')"

.SS "scifir::SCALAR_UNIT_CPP (\fBpermittivity\fP, 'A2*\fBs4\fP/\fBkg\fP*\fBm3'\fP)"

.SS "scifir::SCALAR_UNIT_CPP (\fBpolarization_density\fP, 'A*s/\fBm2'\fP)"

.SS "scifir::SCALAR_UNIT_CPP (\fBpower\fP, 'kg*\fBm2\fP/\fBs3'\fP)"

.SS "scifir::SCALAR_UNIT_CPP (\fBpower_density\fP, 'kg/m*\fBs3'\fP)"

.SS "scifir::SCALAR_UNIT_CPP (\fBradiance\fP, 'kg/\fBs3'\fP)"

.SS "scifir::SCALAR_UNIT_CPP (\fBradiant_intensity\fP, 'kg*\fBm2\fP/\fBs3'\fP)"

.SS "scifir::SCALAR_UNIT_CPP (\fBradioactivity\fP, 'Bq')"

.SS "scifir::SCALAR_UNIT_CPP (\fBresistance\fP, 'kg*\fBm2\fP/\fBA2\fP*\fBs3'\fP)"

.SS "scifir::SCALAR_UNIT_CPP (\fBresistivity\fP, 'kg*\fBm3\fP/\fBA2\fP*\fBs3'\fP)"

.SS "scifir::SCALAR_UNIT_CPP (\fBspecific_energy\fP, 'm2/\fBs2'\fP)"

.SS "scifir::SCALAR_UNIT_CPP (\fBspecific_entropy\fP, 'm2/\fBs2\fP*\fBK'\fP)"

.SS "scifir::SCALAR_UNIT_CPP (\fBspecific_heat_capacity\fP, 'm2/\fBs2\fP*\fBK'\fP)"

.SS "scifir::SCALAR_UNIT_CPP (\fBspecific_volume\fP, 'm3/\fBg'\fP)"

.SS "scifir::SCALAR_UNIT_CPP (\fBspectral_intensity\fP, 'kg*m/\fBs3'\fP)"

.SS "scifir::SCALAR_UNIT_CPP (\fBspectral_radiance\fP, 'kg/m*\fBs3'\fP)"

.SS "scifir::SCALAR_UNIT_CPP (\fBstiffness\fP, 'kg/\fBs2'\fP)"

.SS "scifir::SCALAR_UNIT_CPP (\fBtemperature\fP, 'K')"

.SS "scifir::SCALAR_UNIT_CPP (\fBthermal_conductivity\fP, 'kg*m/K*\fBs3'\fP)"

.SS "scifir::SCALAR_UNIT_CPP (\fBthermal_diffusivity\fP, 'm2/\fBs'\fP)"

.SS "scifir::SCALAR_UNIT_CPP (\fBthermal_expansion_coefficient\fP, '1/K')"

.SS "scifir::SCALAR_UNIT_CPP (\fBthermal_resistance\fP, 'K*\fBs3\fP/\fBkg\fP*\fBm2'\fP)"

.SS "scifir::SCALAR_UNIT_CPP (\fBtime_duration\fP, 's')"

.SS "scifir::SCALAR_UNIT_CPP (\fBtransfer_speed\fP, 'B/\fBs'\fP)"

.SS "scifir::SCALAR_UNIT_CPP (\fBviscosity\fP, 'm2/\fBs'\fP)"

.SS "scifir::SCALAR_UNIT_CPP (\fBvoltage\fP, 'V')"

.SS "scifir::SCALAR_UNIT_CPP (\fBvolume\fP, 'm3')"

.SS "scifir::SCALAR_UNIT_CPP (\fBvolume_4d\fP, 'm4')"

.SS "scifir::SCALAR_UNIT_CPP (\fBvolumetric_flow\fP, 'm3/\fBs'\fP)"

.SS "scifir::SCALAR_UNIT_CPP (\fBwavenumber\fP, '1/m')"

.SS "scifir::SCALAR_UNIT_HPP (\fBabsorbed_dose\fP)"

.SS "scifir::SCALAR_UNIT_HPP (\fBaction\fP)"

.SS "scifir::SCALAR_UNIT_HPP (\fBarea_density\fP)"

.SS "scifir::SCALAR_UNIT_HPP (\fBcapacitance\fP)"

.SS "scifir::SCALAR_UNIT_HPP (\fBcatalytic_activity\fP)"

.SS "scifir::SCALAR_UNIT_HPP (\fBcatalytic_efficiency\fP)"

.SS "scifir::SCALAR_UNIT_HPP (\fBcharge\fP)"

.SS "scifir::SCALAR_UNIT_HPP (\fBcompressibility\fP)"

.SS "scifir::SCALAR_UNIT_HPP (\fBcurvature\fP)"

.SS "scifir::SCALAR_UNIT_HPP (data)"

.SS "scifir::SCALAR_UNIT_HPP (\fBdensity\fP)"

.SS "scifir::SCALAR_UNIT_HPP (\fBdiffusion_coefficient\fP)"

.SS "scifir::SCALAR_UNIT_HPP (\fBdynamic_viscosity\fP)"

.SS "scifir::SCALAR_UNIT_HPP (\fBelectric_charge_density\fP)"

.SS "scifir::SCALAR_UNIT_HPP (\fBelectric_conductance\fP)"

.SS "scifir::SCALAR_UNIT_HPP (\fBelectric_current\fP)"

.SS "scifir::SCALAR_UNIT_HPP (\fBelectric_current_density\fP)"

.SS "scifir::SCALAR_UNIT_HPP (\fBelectrical_conductivity\fP)"

.SS "scifir::SCALAR_UNIT_HPP (\fBelectron_mobility\fP)"

.SS "scifir::SCALAR_UNIT_HPP (\fBenergy\fP)"

.SS "scifir::SCALAR_UNIT_HPP (\fBenergy_density\fP)"

.SS "scifir::SCALAR_UNIT_HPP (\fBenergy_flux_density\fP)"

.SS "scifir::SCALAR_UNIT_HPP (\fBenthalpy\fP)"

.SS "scifir::SCALAR_UNIT_HPP (\fBentropy\fP)"

.SS "scifir::SCALAR_UNIT_HPP (\fBfrequency\fP)"

.SS "scifir::SCALAR_UNIT_HPP (\fBfrequency_drift\fP)"

.SS "scifir::SCALAR_UNIT_HPP (\fBheat_capacity\fP)"

.SS "scifir::SCALAR_UNIT_HPP (\fBheat_flux_density\fP)"

.SS "scifir::SCALAR_UNIT_HPP (\fBilluminance\fP)"

.SS "scifir::SCALAR_UNIT_HPP (\fBinductance\fP)"

.SS "scifir::SCALAR_UNIT_HPP (\fBionizing_radiation\fP)"

.SS "scifir::SCALAR_UNIT_HPP (\fBlength\fP)"

.SS "scifir::SCALAR_UNIT_HPP (\fBlight\fP)"

.SS "scifir::SCALAR_UNIT_HPP (\fBlinear_charge_density\fP)"

.SS "scifir::SCALAR_UNIT_HPP (\fBlinear_mass_density\fP)"

.SS "scifir::SCALAR_UNIT_HPP (\fBluminance\fP)"

.SS "scifir::SCALAR_UNIT_HPP (\fBluminous_efficacy\fP)"

.SS "scifir::SCALAR_UNIT_HPP (\fBluminous_energy\fP)"

.SS "scifir::SCALAR_UNIT_HPP (\fBluminous_exposure\fP)"

.SS "scifir::SCALAR_UNIT_HPP (\fBluminous_flux\fP)"

.SS "scifir::SCALAR_UNIT_HPP (\fBmagnetic_flux\fP)"

.SS "scifir::SCALAR_UNIT_HPP (\fBmagnetic_permeability\fP)"

.SS "scifir::SCALAR_UNIT_HPP (\fBmagnetic_reluctance\fP)"

.SS "scifir::SCALAR_UNIT_HPP (\fBmagnetic_rigidity\fP)"

.SS "scifir::SCALAR_UNIT_HPP (\fBmagnetic_susceptibility\fP)"

.SS "scifir::SCALAR_UNIT_HPP (\fBmagnetization\fP)"

.SS "scifir::SCALAR_UNIT_HPP (\fBmass_flow_rate\fP)"

.SS "scifir::SCALAR_UNIT_HPP (\fBmolality\fP)"

.SS "scifir::SCALAR_UNIT_HPP (\fBmolar_conductivity\fP)"

.SS "scifir::SCALAR_UNIT_HPP (\fBmolar_energy\fP)"

.SS "scifir::SCALAR_UNIT_HPP (\fBmolar_enthalpy\fP)"

.SS "scifir::SCALAR_UNIT_HPP (\fBmolar_entropy\fP)"

.SS "scifir::SCALAR_UNIT_HPP (\fBmolar_heat_capacity\fP)"

.SS "scifir::SCALAR_UNIT_HPP (\fBmolar_mass\fP)"

.SS "scifir::SCALAR_UNIT_HPP (\fBmolar_volume\fP)"

.SS "scifir::SCALAR_UNIT_HPP (\fBmolarity\fP)"

.SS "scifir::SCALAR_UNIT_HPP (\fBmoment_of_inertia\fP)"

.SS "scifir::SCALAR_UNIT_HPP (\fBoptical_power\fP)"

.SS "scifir::SCALAR_UNIT_HPP (\fBpermittivity\fP)"

.SS "scifir::SCALAR_UNIT_HPP (\fBpolarization_density\fP)"

.SS "scifir::SCALAR_UNIT_HPP (\fBpower\fP)"

.SS "scifir::SCALAR_UNIT_HPP (\fBpower_density\fP)"

.SS "scifir::SCALAR_UNIT_HPP (\fBradiance\fP)"

.SS "scifir::SCALAR_UNIT_HPP (\fBradiant_intensity\fP)"

.SS "scifir::SCALAR_UNIT_HPP (\fBradioactivity\fP)"

.SS "scifir::SCALAR_UNIT_HPP (\fBresistance\fP)"

.SS "scifir::SCALAR_UNIT_HPP (\fBresistivity\fP)"

.SS "scifir::SCALAR_UNIT_HPP (\fBspecific_energy\fP)"

.SS "scifir::SCALAR_UNIT_HPP (\fBspecific_entropy\fP)"

.SS "scifir::SCALAR_UNIT_HPP (\fBspecific_heat_capacity\fP)"

.SS "scifir::SCALAR_UNIT_HPP (\fBspecific_volume\fP)"

.SS "scifir::SCALAR_UNIT_HPP (\fBspectral_intensity\fP)"

.SS "scifir::SCALAR_UNIT_HPP (\fBspectral_radiance\fP)"

.SS "scifir::SCALAR_UNIT_HPP (\fBstiffness\fP)"

.SS "scifir::SCALAR_UNIT_HPP (\fBtemperature\fP)"

.SS "scifir::SCALAR_UNIT_HPP (\fBthermal_conductivity\fP)"

.SS "scifir::SCALAR_UNIT_HPP (\fBthermal_diffusivity\fP)"

.SS "scifir::SCALAR_UNIT_HPP (\fBthermal_expansion_coefficient\fP)"

.SS "scifir::SCALAR_UNIT_HPP (\fBthermal_resistance\fP)"

.SS "scifir::SCALAR_UNIT_HPP (\fBtransfer_speed\fP)"

.SS "scifir::SCALAR_UNIT_HPP (\fBviscosity\fP)"

.SS "scifir::SCALAR_UNIT_HPP (\fBvoltage\fP)"

.SS "scifir::SCALAR_UNIT_HPP (\fBvolume_4d\fP)"

.SS "scifir::SCALAR_UNIT_HPP (\fBvolumetric_flow\fP)"

.SS "scifir::SCALAR_UNIT_HPP (\fBwavenumber\fP)"

.SS "scifir::SCALAR_UNIT_HPP_BEGIN (\fBarea\fP)"

.SS "scifir::SCALAR_UNIT_HPP_BEGIN (\fBmass\fP)"

.SS "scifir::SCALAR_UNIT_HPP_BEGIN (\fBmole\fP)"

.SS "scifir::SCALAR_UNIT_HPP_BEGIN (\fBtime_duration\fP)"

.SS "scifir::SCALAR_UNIT_HPP_BEGIN (\fBvolume\fP)"

.SS "scifir::SCALAR_UNIT_HPP_END ()"

.SS "\fBfloat\fP scifir::sin (\fBconst\fP \fBangle\fP & x)"

.PP
Definition at line \fB314\fP of file \fBangle\&.cpp\fP\&..PP
.nf
315     {
316         return std::sin(x\&.get_radian());
317     }
.fi

.SS "\fBfloat\fP scifir::sinh (\fBconst\fP \fBangle\fP & x)"

.PP
Definition at line \fB344\fP of file \fBangle\&.cpp\fP\&..PP
.nf
345     {
346         return std::sinh(x\&.get_radian());
347     }
.fi

.SS "\fBscalar_unit\fP scifir::spherical_to_cartesian_3d_x (\fBconst\fP \fBscalar_unit\fP & r, \fBconst\fP \fBangle\fP & theta, \fBconst\fP \fBangle\fP & phi)\fC [inline]\fP"

.PP
Definition at line \fB653\fP of file \fBcoordinates_3d\&.hpp\fP\&..PP
.nf
654     {
655         return r * scifir::cos(theta) * scifir::sin(phi);
656     }
.fi

.SS "\fBfloat\fP scifir::spherical_to_cartesian_3d_x (\fBfloat\fP r, \fBconst\fP \fBangle\fP & theta, \fBconst\fP \fBangle\fP & phi)\fC [inline]\fP"

.PP
Definition at line \fB745\fP of file \fBcoordinates_3d\&.hpp\fP\&..PP
.nf
746     {
747         return r * scifir::cos(theta) * scifir::sin(phi);
748     }
.fi

.SS "\fBscalar_unit\fP scifir::spherical_to_cartesian_3d_y (\fBconst\fP \fBscalar_unit\fP & r, \fBconst\fP \fBangle\fP & theta, \fBconst\fP \fBangle\fP & phi)\fC [inline]\fP"

.PP
Definition at line \fB658\fP of file \fBcoordinates_3d\&.hpp\fP\&..PP
.nf
659     {
660         return r * scifir::sin(theta) * scifir::sin(phi);
661     }
.fi

.SS "\fBfloat\fP scifir::spherical_to_cartesian_3d_y (\fBfloat\fP r, \fBconst\fP \fBangle\fP & theta, \fBconst\fP \fBangle\fP & phi)\fC [inline]\fP"

.PP
Definition at line \fB750\fP of file \fBcoordinates_3d\&.hpp\fP\&..PP
.nf
751     {
752         return r * scifir::sin(theta) * scifir::sin(phi);
753     }
.fi

.SS "\fBscalar_unit\fP scifir::spherical_to_cartesian_3d_z (\fBconst\fP \fBscalar_unit\fP & r, \fBconst\fP \fBangle\fP & theta, \fBconst\fP \fBangle\fP & phi)\fC [inline]\fP"

.PP
Definition at line \fB663\fP of file \fBcoordinates_3d\&.hpp\fP\&..PP
.nf
664     {
665         return r * scifir::cos(phi);
666     }
.fi

.SS "\fBfloat\fP scifir::spherical_to_cartesian_3d_z (\fBfloat\fP r, \fBconst\fP \fBangle\fP & theta, \fBconst\fP \fBangle\fP & phi)\fC [inline]\fP"

.PP
Definition at line \fB755\fP of file \fBcoordinates_3d\&.hpp\fP\&..PP
.nf
756     {
757         return r * scifir::cos(phi);
758     }
.fi

.SS "\fBscalar_unit\fP scifir::spherical_to_cylindrical_p (\fBconst\fP \fBscalar_unit\fP & r, \fBconst\fP \fBangle\fP & theta, \fBconst\fP \fBangle\fP & phi)\fC [inline]\fP"

.PP
Definition at line \fB668\fP of file \fBcoordinates_3d\&.hpp\fP\&..PP
.nf
669     {
670         return r * scifir::sin(phi);
671     }
.fi

.SS "\fBfloat\fP scifir::spherical_to_cylindrical_p (\fBfloat\fP r, \fBconst\fP \fBangle\fP & theta, \fBconst\fP \fBangle\fP & phi)\fC [inline]\fP"

.PP
Definition at line \fB760\fP of file \fBcoordinates_3d\&.hpp\fP\&..PP
.nf
761     {
762         return r * scifir::sin(phi);
763     }
.fi

.SS "\fBangle\fP scifir::spherical_to_cylindrical_theta (\fBconst\fP \fBscalar_unit\fP & r, \fBconst\fP \fBangle\fP & theta, \fBconst\fP \fBangle\fP & phi)\fC [inline]\fP"

.PP
Definition at line \fB673\fP of file \fBcoordinates_3d\&.hpp\fP\&..PP
.nf
674     {
675         return theta;
676     }
.fi

.SS "\fBangle\fP scifir::spherical_to_cylindrical_theta (\fBfloat\fP r, \fBconst\fP \fBangle\fP & theta, \fBconst\fP \fBangle\fP & phi)\fC [inline]\fP"

.PP
Definition at line \fB765\fP of file \fBcoordinates_3d\&.hpp\fP\&..PP
.nf
766     {
767         return theta;
768     }
.fi

.SS "\fBscalar_unit\fP scifir::spherical_to_cylindrical_z (\fBconst\fP \fBscalar_unit\fP & r, \fBconst\fP \fBangle\fP & theta, \fBconst\fP \fBangle\fP & phi)\fC [inline]\fP"

.PP
Definition at line \fB678\fP of file \fBcoordinates_3d\&.hpp\fP\&..PP
.nf
679     {
680         return r * scifir::cos(phi);
681     }
.fi

.SS "\fBfloat\fP scifir::spherical_to_cylindrical_z (\fBfloat\fP r, \fBconst\fP \fBangle\fP & theta, \fBconst\fP \fBangle\fP & phi)\fC [inline]\fP"

.PP
Definition at line \fB770\fP of file \fBcoordinates_3d\&.hpp\fP\&..PP
.nf
771     {
772         return r * scifir::cos(phi);
773     }
.fi

.SS "\fBangle\fP scifir::sqrt (\fBconst\fP \fBangle\fP & x)"

.PP
Definition at line \fB304\fP of file \fBangle\&.cpp\fP\&..PP
.nf
305     {
306         return angle(std::sqrt(x\&.get_value()));
307     }
.fi

.SS "template<\fBtypename\fP T > \fBcomplex_number\fP< \fBscalar_unit\fP > scifir::sqrt (\fBconst\fP \fBcomplex_number\fP< T > & x)"

.PP
Definition at line \fB188\fP of file \fBcomplex_number\&.hpp\fP\&..PP
.nf
189     {
190         int sgn_value;
191         if (x\&.imaginary > 0)
192         {
193             sgn_value = 1;
194         }
195         else if (x\&.imaginary < 0)
196         {
197             sgn_value = \-1;
198         }
199         else
200         {
201             sgn_value = 0;
202         }
203         scalar_unit new_real = scifir::sqrt(x\&.real + scifir::sqrt((x\&.real^2) + (x\&.imaginary^2)));
204         scalar_unit new_imaginary = sgn_value * scifir::sqrt(((\-1) * x\&.real + scifir::sqrt((x\&.real^2) + (x\&.imaginary^2))) / 2);
205         return complex_number<scalar_unit>(new_real,new_imaginary);
206     }
.fi

.SS "\fBpixel\fP scifir::sqrt (\fBconst\fP \fBpixel\fP & x)"

.PP
Definition at line \fB228\fP of file \fBpixel\&.cpp\fP\&..PP
.nf
229     {
230         return pixel(std::sqrt(x\&.get_value()));
231     }
.fi

.SS "\fBscalar_unit\fP scifir::sqrt (\fBconst\fP \fBscalar_unit\fP & x)"

.PP
Square root of a \fBscalar_unit\fP, it squares the dimensions too\&. 
.PP
Definition at line \fB730\fP of file \fBscalar_unit\&.cpp\fP\&..PP
.nf
731     {
732         long double new_value = x\&.get_value();
733         vector<dimension> new_dimensions = square_dimensions(x\&.get_dimensions(), new_value, 2);
734         new_value = std::sqrt(new_value);
735         return scalar_unit(new_value, new_dimensions);
736     }
.fi

.SS "\fBvector_unit_2d\fP scifir::sqrt (\fBconst\fP \fBvector_unit_2d\fP & x)"

.PP
Definition at line \fB326\fP of file \fBvector_unit_2d\&.cpp\fP\&..PP
.nf
327     {
328         scalar_unit new_value = scifir::sqrt(scalar_unit(x));
329         return vector_unit_2d(new_value, x\&.theta);
330     }
.fi

.SS "\fBvector_unit_3d\fP scifir::sqrt (\fBconst\fP \fBvector_unit_3d\fP & x)"

.PP
Definition at line \fB431\fP of file \fBvector_unit_3d\&.cpp\fP\&..PP
.nf
432     {
433         scalar_unit new_value = scifir::sqrt(scalar_unit(x));
434         return vector_unit_3d(new_value, x\&.theta, x\&.phi);
435     }
.fi

.SS "\fBvector_unit_nd\fP scifir::sqrt (\fBconst\fP \fBvector_unit_nd\fP & x)"

.PP
Definition at line \fB747\fP of file \fBvector_unit_nd\&.cpp\fP\&..PP
.nf
748     {
749         scalar_unit new_value = scifir::sqrt(scalar_unit(x));
750         return vector_unit_nd(new_value, x\&.angles);
751     }
.fi

.SS "\fBangle\fP scifir::sqrt_nth (\fBconst\fP \fBangle\fP & x, \fBint\fP index)"

.PP
Definition at line \fB309\fP of file \fBangle\&.cpp\fP\&..PP
.nf
310     {
311         return angle(std::pow(x\&.get_value(), float(1\&.0f / index)));
312     }
.fi

.SS "\fBpixel\fP scifir::sqrt_nth (\fBconst\fP \fBpixel\fP & x, \fBint\fP index)"

.PP
Definition at line \fB233\fP of file \fBpixel\&.cpp\fP\&..PP
.nf
234     {
235         return pixel(std::pow(x\&.get_value(), 1\&.0f / index));
236     }
.fi

.SS "\fBscalar_unit\fP scifir::sqrt_nth (\fBconst\fP \fBscalar_unit\fP & x, \fBint\fP index)"

.PP
Nth root of a \fBscalar_unit\fP to any numeric value, it squares the dimensions too\&. 
.PP
Definition at line \fB738\fP of file \fBscalar_unit\&.cpp\fP\&..PP
.nf
739     {
740         long double new_value = x\&.get_value();
741         vector<dimension> new_dimensions = square_dimensions(x\&.get_dimensions(), new_value, index);
742         new_value = std::pow(new_value, 1\&.0f / index);
743         return scalar_unit(new_value, new_dimensions);
744     }
.fi

.SS "\fBvector_unit_2d\fP scifir::sqrt_nth (\fBconst\fP \fBvector_unit_2d\fP & x, \fBint\fP index)"

.PP
Definition at line \fB332\fP of file \fBvector_unit_2d\&.cpp\fP\&..PP
.nf
333     {
334         scalar_unit new_value = scifir::sqrt_nth(scalar_unit(x), index);
335         return vector_unit_2d(new_value, x\&.theta);
336     }
.fi

.SS "\fBvector_unit_3d\fP scifir::sqrt_nth (\fBconst\fP \fBvector_unit_3d\fP & x, \fBint\fP index)"

.PP
Definition at line \fB437\fP of file \fBvector_unit_3d\&.cpp\fP\&..PP
.nf
438     {
439         scalar_unit new_value = scifir::sqrt_nth(scalar_unit(x), index);
440         return vector_unit_3d(new_value, x\&.theta, x\&.phi);
441     }
.fi

.SS "\fBvector_unit_nd\fP scifir::sqrt_nth (\fBconst\fP \fBvector_unit_nd\fP & x, \fBint\fP index)"

.PP
Definition at line \fB753\fP of file \fBvector_unit_nd\&.cpp\fP\&..PP
.nf
754     {
755         scalar_unit new_value = scifir::sqrt_nth(scalar_unit(x), index);
756         return vector_unit_nd(new_value, x\&.angles);
757     }
.fi

.SS "vector< \fBdimension\fP > scifir::square_dimensions (vector< \fBdimension\fP > x, \fBlong\fP \fBdouble\fP & value, \fBint\fP index)"

.PP
Definition at line \fB1408\fP of file \fBdimension\&.cpp\fP\&..PP
.nf
1409     {
1410         map<dimension::type,int> dimensions_count = map<dimension::type,int>();
1411         for (const dimension& x_dimension : x)
1412         {
1413             dimensions_count[x_dimension\&.dimension_type]++;
1414         }
1415         for (const auto& x_count : dimensions_count)
1416         {
1417             if ((x_count\&.second % index) != 0)
1418             {
1419                 return vector<dimension>();
1420             }
1421         }
1422         vector<dimension> new_dimensions = vector<dimension>();
1423         if (dimensions_count\&.size() == 1) // If there's only one type of dimension, square it and conserve its type
1424         {
1425             for (int i = 0; i < dimensions_count[x[0]\&.dimension_type]; i++)
1426             {
1427                 if (x[i]\&.dimension_sign == dimension::NUMERATOR)
1428                 {
1429                     value *= x[i]\&.get_conversion_factor();
1430                     value *= x[i]\&.prefix_math();
1431                 }
1432                 else if (x[i]\&.dimension_sign == dimension::DENOMINATOR)
1433                 {
1434                     value /= x[i]\&.get_conversion_factor();
1435                     value /= x[i]\&.prefix_math();
1436                 }
1437             }
1438             int total_dimensions = int(std::pow(dimensions_count[x[0]\&.dimension_type], 1\&.0f / index));
1439             x[0]\&.prefix\&.prefix_type = prefix::no_prefix;
1440             for (int j = 0; j < total_dimensions; j++)
1441             {
1442                 new_dimensions\&.push_back(x[0]);
1443             }
1444             return new_dimensions;
1445         }
1446         else // If there's more than one type of dimension, creates the derived dimensions of them, and squares the total\&. If there are abbreviations, they are losed
1447         {
1448             x = normalize_dimensions(x,value);
1449             vector<dimension::type> counted_dimensions = vector<dimension::type>();
1450             dimensions_count\&.clear();
1451             for (const dimension& x_dimension : x)
1452             {
1453                 dimensions_count[x_dimension\&.dimension_type]++;
1454             }
1455             for (const dimension& x_dimension : x)
1456             {
1457                 bool counted = false;
1458                 for (const dimension::type& counted_dimension : counted_dimensions)
1459                 {
1460                     if (counted_dimension == x_dimension\&.dimension_type)
1461                     {
1462                         counted = true;
1463                     }
1464                 }
1465                 if (counted == true)
1466                 {
1467                     continue;
1468                 }
1469                 int total_dimensions = int(std::pow(dimensions_count[x_dimension\&.dimension_type], 1\&.0f / index));
1470                 for (int j = 0; j < total_dimensions; j++)
1471                 {
1472                     new_dimensions\&.push_back(x_dimension);
1473                 }
1474                 counted_dimensions\&.push_back(x_dimension\&.dimension_type);
1475             }
1476         }
1477         return new_dimensions;
1478     }
.fi

.SS "\fBfloat\fP scifir::tan (\fBconst\fP \fBangle\fP & x)"

.PP
Definition at line \fB324\fP of file \fBangle\&.cpp\fP\&..PP
.nf
325     {
326         return std::tan(x\&.get_radian());
327     }
.fi

.SS "\fBfloat\fP scifir::tanh (\fBconst\fP \fBangle\fP & x)"

.PP
Definition at line \fB354\fP of file \fBangle\&.cpp\fP\&..PP
.nf
355     {
356         return std::tanh(x\&.get_radian());
357     }
.fi

.SS "scifir::time_duration::time_duration (\fBconst\fP \fBstring\fP & init_time)"

.PP
Definition at line \fB25\fP of file \fBunit_basic\&.cpp\fP\&..PP
.nf
25                                                         : scalar_unit()
26     {
27         if(!isdigit(init_time[0]))
28         {
29             return;
30         }
31         else
32         {
33             vector<string> init_values;
34             boost::split(init_values,init_time,boost::is_any_of(" "));
35             value = 0;
36             for (unsigned int i = 0; i < init_values\&.size(); i++)
37             {
38                 int j = 0;
39                 while(isdigit(init_values[i][j]) || init_values[i][j] == '\&.' || init_values[i][j] == ' ' || init_values[i][j] == '*' || init_values[i][j] == '^' || init_values[i][j] == 'e' || init_values[i][j] == 'E')
40                 {
41                     if (init_values[i][j] == ' ')
42                     {
43                         break;
44                     }
45                     j++;
46                 }
47                 string string_value = init_values[i]\&.substr(0, j);
48                 boost::algorithm::erase_all(string_value, " ");
49                 size_t search_e = string_value\&.find("E");
50                 if (search_e != string::npos)
51                 {
52                     string_value\&.replace(search_e,1,"e");
53                 }
54                 size_t search_10 = string_value\&.find("*10^");
55                 if (search_10 != string::npos)
56                 {
57                     string_value\&.replace(search_10,4,"e");
58                 }
59                 stringstream ss(string_value);
60                 float init_value_float;
61                 ss >> init_value_float;
62                 string init_value_dimension = init_values[i]\&.substr(j);
63                 float init_value_dimension_quantity = 0\&.0f;
64                 if (init_value_dimension == "d")
65                 {
66                     init_value_dimension_quantity = 86400\&.0f;
67                 }
68                 else if(init_value_dimension == "h")
69                 {
70                     init_value_dimension_quantity = 3600\&.0f;
71                 }
72                 else if(init_value_dimension == "min")
73                 {
74                     init_value_dimension_quantity = 60\&.0f;
75                 }
76                 else if(init_value_dimension == "s")
77                 {
78                     init_value_dimension_quantity = 1\&.0f;
79                 }
80                 value += init_value_float * init_value_dimension_quantity;
81             }
82             dimensions = create_dimensions("s");
83         }
84     }
.fi

.SS "\fBstring\fP scifir::to_string (\fBconst\fP \fBaid\fP & x)"

.PP
Definition at line \fB470\fP of file \fBaid\&.cpp\fP\&..PP
.nf
471     {
472         return x\&.display();
473     }
.fi

.SS "\fBstring\fP scifir::to_string (\fBconst\fP \fBaid::type\fP & x)"

.PP
Definition at line \fB475\fP of file \fBaid\&.cpp\fP\&..PP
.nf
476     {
477         switch (x)
478         {
479             case aid::UNIVERSE:
480                 return "U";
481             case aid::GALAXY:
482                 return "G";
483             case aid::SOLAR_SYSTEM:
484                 return "SS";
485             case aid::PLANET:
486                 return "P";
487             case aid::STAR:
488                 return "ST";
489             case aid::ASTEROID:
490                 return "A";
491             case aid::MOON:
492                 return "MN";
493             case aid::METEOR:
494                 return "MT";
495             case aid::NONE:
496                 return "";
497         }
498         return "";
499     }
.fi

.SS "\fBstring\fP scifir::to_string (\fBconst\fP \fBangle\fP & x)"

.PP
Definition at line \fB241\fP of file \fBangle\&.cpp\fP\&..PP
.nf
242     {
243         return x\&.display(2);
244     }
.fi

.SS "template<\fBtypename\fP T > \fBstring\fP scifir::to_string (\fBconst\fP \fBcomplex_number\fP< T > & x)"

.PP
Definition at line \fB174\fP of file \fBcomplex_number\&.hpp\fP\&..PP
.nf
175     {
176         return x\&.display(2);
177     }
.fi

.SS "\fBstring\fP scifir::to_string (\fBconst\fP \fBcoordinates_1d\fP< \fBfloat\fP > & x)"

.PP
Definition at line \fB8\fP of file \fBcoordinates_1d\&.cpp\fP\&..PP
.nf
9     {
10         return x\&.display_cartesian();
11     }
.fi

.SS "template<\fBtypename\fP T > \fBstring\fP scifir::to_string (\fBconst\fP \fBcoordinates_1d\fP< T > & x)"

.PP
Definition at line \fB209\fP of file \fBcoordinates_1d\&.hpp\fP\&..PP
.nf
210     {
211         return x\&.display_cartesian();
212     }
.fi

.SS "\fBstring\fP scifir::to_string (\fBconst\fP \fBcoordinates_2d\fP< \fBfloat\fP > & x)"

.PP
Definition at line \fB9\fP of file \fBcoordinates_2d\&.cpp\fP\&..PP
.nf
10     {
11         return x\&.display_cartesian();
12     }
.fi

.SS "template<\fBtypename\fP T > \fBstring\fP scifir::to_string (\fBconst\fP \fBcoordinates_2d\fP< T > & x)"

.PP
Definition at line \fB343\fP of file \fBcoordinates_2d\&.hpp\fP\&..PP
.nf
344     {
345         return x\&.display_cartesian();
346     }
.fi

.SS "\fBstring\fP scifir::to_string (\fBconst\fP \fBcoordinates_2dr\fP< \fBfloat\fP > & x)"

.PP
Definition at line \fB7\fP of file \fBcoordinates_2dr\&.cpp\fP\&..PP
.nf
8     {
9         return x\&.display_cartesian();
10     }
.fi

.SS "template<\fBtypename\fP T > \fBstring\fP scifir::to_string (\fBconst\fP \fBcoordinates_2dr\fP< T > & x)"

.PP
Definition at line \fB484\fP of file \fBcoordinates_2dr\&.hpp\fP\&..PP
.nf
485     {
486         return x\&.display_cartesian();
487     }
.fi

.SS "\fBstring\fP scifir::to_string (\fBconst\fP \fBcoordinates_3d\fP< \fBfloat\fP > & x)"

.PP
Definition at line \fB7\fP of file \fBcoordinates_3d\&.cpp\fP\&..PP
.nf
8     {
9         return x\&.display_cartesian();
10     }
.fi

.SS "template<\fBtypename\fP T > \fBstring\fP scifir::to_string (\fBconst\fP \fBcoordinates_3d\fP< T > & x)"

.PP
Definition at line \fB585\fP of file \fBcoordinates_3d\&.hpp\fP\&..PP
.nf
586     {
587         return x\&.display_cartesian();
588     }
.fi

.SS "\fBstring\fP scifir::to_string (\fBconst\fP \fBcoordinates_3dr\fP< \fBfloat\fP > & x)"

.PP
Definition at line \fB7\fP of file \fBcoordinates_3dr\&.cpp\fP\&..PP
.nf
8     {
9         return x\&.display_cartesian();
10     }
.fi

.SS "template<\fBtypename\fP T > \fBstring\fP scifir::to_string (\fBconst\fP \fBcoordinates_3dr\fP< T > & x)"

.PP
Definition at line \fB932\fP of file \fBcoordinates_3dr\&.hpp\fP\&..PP
.nf
933     {
934         return x\&.display_cartesian();
935     }
.fi

.SS "\fBstring\fP scifir::to_string (\fBconst\fP \fBcoordinates_nd\fP< \fBfloat\fP > & x)"

.PP
Definition at line \fB7\fP of file \fBcoordinates_nd\&.cpp\fP\&..PP
.nf
8     {
9         if (x\&.values\&.size() > 0)
10         {
11             ostringstream out;
12             out << "(";
13             for (int i = 0; i < x\&.values\&.size(); i++)
14             {
15                 out << display_float(x\&.values[i]);
16                 if ((i + 1) != x\&.values\&.size())
17                 {
18                     out << ",";
19                 }
20             }
21             out << ")";
22             return out\&.str();
23         }
24         else
25         {
26             return "[empty]";
27         }
28     }
.fi

.SS "template<\fBtypename\fP T > \fBstring\fP scifir::to_string (\fBconst\fP \fBcoordinates_nd\fP< T > & x)"

.PP
Definition at line \fB1062\fP of file \fBcoordinates_nd\&.hpp\fP\&..PP
.nf
1063     {
1064         if (x\&.values\&.size() > 0)
1065         {
1066             ostringstream out;
1067             out << "(";
1068             for (int i = 0; i < x\&.values\&.size(); i++)
1069             {
1070                 out << x\&.values[i];
1071                 if ((i + 1) != x\&.values\&.size())
1072                 {
1073                     out << ",";
1074                 }
1075             }
1076             out << ")";
1077             return out\&.str();
1078         }
1079         else
1080         {
1081             return "[empty]";
1082         }
1083     }
.fi

.SS "\fBstring\fP scifir::to_string (\fBconst\fP \fBcoordinates_ndr\fP< \fBfloat\fP > & x)"

.PP
Definition at line \fB10\fP of file \fBcoordinates_ndr\&.cpp\fP\&..PP
.nf
11     {
12         if (x\&.get_values()\&.size() > 0)
13         {
14             ostringstream out;
15             out << "(";
16             if (x\&.get_values()\&.size() > 0)
17             {
18                 for (int i = 0; i < x\&.get_values()\&.size(); i++)
19                 {
20                     out << display_float(x\&.get_value(i));
21                     if ((i + 1) != x\&.get_values()\&.size())
22                     {
23                         out << ",";
24                     }
25                 }
26             }
27             if (x\&.get_angles()\&.size() > 0)
28             {
29                 out << ";";
30                 for (int i = 0; i < x\&.get_angles()\&.size(); i++)
31                 {
32                     out << x\&.get_angle(i);
33                     if ((i + 1) != x\&.get_angles()\&.size())
34                     {
35                         out << ",";
36                     }
37                 }
38             }
39             out << ")";
40             return out\&.str();
41         }
42         else
43         {
44             return "[empty]";
45         }
46     }
.fi

.SS "template<\fBtypename\fP T > \fBstring\fP scifir::to_string (\fBconst\fP \fBcoordinates_ndr\fP< T > & x)"

.PP
Definition at line \fB2145\fP of file \fBcoordinates_ndr\&.hpp\fP\&..PP
.nf
2146     {
2147         if (x\&.get_values()\&.size() > 0)
2148         {
2149             ostringstream out;
2150             out << "(";
2151             if (x\&.get_values()\&.size() > 0)
2152             {
2153                 for (int i = 0; i < x\&.get_values()\&.size(); i++)
2154                 {
2155                     out << x\&.get_value(i);
2156                     if ((i + 1) != x\&.get_values()\&.size())
2157                     {
2158                         out << ",";
2159                     }
2160                 }
2161             }
2162             if (x\&.get_angles()\&.size() > 0)
2163             {
2164                 out << ";";
2165                 for (int i = 0; i < x\&.get_angles()\&.size(); i++)
2166                 {
2167                     out << x\&.get_angle(i);
2168                     if ((i + 1) != x\&.get_angles()\&.size())
2169                     {
2170                         out << ",";
2171                     }
2172                 }
2173             }
2174             out << ")";
2175             return out\&.str();
2176         }
2177         else
2178         {
2179             return "[empty]";
2180         }
2181     }
.fi

.SS "\fBstring\fP scifir::to_string (\fBconst\fP \fBdimension\fP & x)"

.PP
Definition at line \fB1154\fP of file \fBdimension\&.cpp\fP\&..PP
.nf
1155     {
1156         ostringstream out;
1157         out << x\&.prefix << x\&.get_symbol();
1158         return out\&.str();
1159     }
.fi

.SS "\fBstring\fP scifir::to_string (\fBconst\fP \fBdirection\fP & x)"

.PP
Definition at line \fB341\fP of file \fBdirection\&.cpp\fP\&..PP
.nf
342     {
343         return to_string(x\&.value);
344     }
.fi

.SS "\fBstring\fP scifir::to_string (\fBconst\fP \fBemotion\fP &)"

.SS "\fBstring\fP scifir::to_string (\fBconst\fP \fBfeeling\fP &)"

.SS "template<\fBtypename\fP T > \fBstring\fP scifir::to_string (\fBconst\fP \fBlab_number\fP< T > & x)"

.PP
Definition at line \fB110\fP of file \fBlab_number\&.hpp\fP\&..PP
.nf
111     {
112         return x\&.display(2);
113     }
.fi

.SS "template<\fBtypename\fP T , \fBtypename\fP \fBU\fP > \fBstring\fP scifir::to_string (\fBconst\fP \fBmaterial_vector_unit_2d\fP< T, \fBU\fP > & x)"

.PP
Definition at line \fB93\fP of file \fBmaterial_vector_unit_2d\&.hpp\fP\&..PP
.nf
94     {
95         return x\&.vectorial_display(2);
96     }
.fi

.SS "\fBstring\fP scifir::to_string (\fBconst\fP \fBpercentage\fP & x)"

.PP
Definition at line \fB419\fP of file \fBpercentage\&.cpp\fP\&..PP
.nf
420     {
421         return x\&.display_percentage();
422     }
.fi

.SS "\fBstring\fP scifir::to_string (\fBconst\fP \fBpH\fP & x)"

.PP
Definition at line \fB200\fP of file \fBpH\&.cpp\fP\&..PP
.nf
201     {
202         return x\&.display(2);
203     }
.fi

.SS "\fBstring\fP scifir::to_string (\fBconst\fP \fBpixel\fP & x)"

.PP
Definition at line \fB184\fP of file \fBpixel\&.cpp\fP\&..PP
.nf
185     {
186         ostringstream output;
187         output << display_float(x\&.get_value()) << " px";
188         return output\&.str();
189     }
.fi

.SS "\fBstring\fP scifir::to_string (\fBconst\fP \fBpOH\fP & x)"

.PP
Definition at line \fB198\fP of file \fBpOH\&.cpp\fP\&..PP
.nf
199     {
200         return x\&.display(2);
201     }
.fi

.SS "\fBstring\fP scifir::to_string (\fBconst\fP \fBpoint_1d\fP< \fBfloat\fP > & x)"

.PP
Definition at line \fB28\fP of file \fBpoint_1d\&.cpp\fP\&..PP
.nf
29     {
30         return x\&.display_cartesian();
31     }
.fi

.SS "template<\fBtypename\fP T > \fBstring\fP scifir::to_string (\fBconst\fP \fBpoint_1d\fP< T > & x)"

.PP
Definition at line \fB191\fP of file \fBpoint_1d\&.hpp\fP\&..PP
.nf
192     {
193         return x\&.display_cartesian();
194     }
.fi

.SS "\fBstring\fP scifir::to_string (\fBconst\fP \fBpoint_2d\fP< \fBfloat\fP > & x)"

.PP
Definition at line \fB30\fP of file \fBpoint_2d\&.cpp\fP\&..PP
.nf
31     {
32         return x\&.display_cartesian();
33     }
.fi

.SS "template<\fBtypename\fP T > \fBstring\fP scifir::to_string (\fBconst\fP \fBpoint_2d\fP< T > & x)"

.PP
Definition at line \fB320\fP of file \fBpoint_2d\&.hpp\fP\&..PP
.nf
321     {
322         return x\&.display_cartesian();
323     }
.fi

.SS "\fBstring\fP scifir::to_string (\fBconst\fP \fBpoint_3d\fP< \fBfloat\fP > & x)"

.PP
Definition at line \fB32\fP of file \fBpoint_3d\&.cpp\fP\&..PP
.nf
33     {
34         return x\&.display_cartesian();
35     }
.fi

.SS "template<\fBtypename\fP T > \fBstring\fP scifir::to_string (\fBconst\fP \fBpoint_3d\fP< T > & x)"

.PP
Definition at line \fB557\fP of file \fBpoint_3d\&.hpp\fP\&..PP
.nf
558     {
559         return x\&.display_cartesian();
560     }
.fi

.SS "\fBstring\fP scifir::to_string (\fBconst\fP \fBpoint_nd\fP< \fBfloat\fP > & x)"

.PP
Definition at line \fB28\fP of file \fBpoint_nd\&.cpp\fP\&..PP
.nf
29     {
30         if (x\&.values\&.size() > 0)
31         {
32             ostringstream out;
33             out << "(";
34             for (int i = 0; i < x\&.values\&.size(); i++)
35             {
36                 out << display_float(x\&.values[i]);
37                 if ((i + 1) != x\&.values\&.size())
38                 {
39                     out << ",";
40                 }
41             }
42             out << ")";
43             return out\&.str();
44         }
45         else
46         {
47             return "[empty]";
48         }
49     }
.fi

.SS "template<\fBtypename\fP T > \fBstring\fP scifir::to_string (\fBconst\fP \fBpoint_nd\fP< T > & x)"

.PP
Definition at line \fB1046\fP of file \fBpoint_nd\&.hpp\fP\&..PP
.nf
1047     {
1048         if (x\&.values\&.size() > 0)
1049         {
1050             ostringstream out;
1051             out << "(";
1052             for (int i = 0; i < x\&.values\&.size(); i++)
1053             {
1054                 out << x\&.values[i];
1055                 if ((i + 1) != x\&.values\&.size())
1056                 {
1057                     out << ",";
1058                 }
1059             }
1060             out << ")";
1061             return out\&.str();
1062         }
1063         else
1064         {
1065             return "[empty]";
1066         }
1067     }
.fi

.SS "\fBstring\fP scifir::to_string (\fBconst\fP \fBscalar_unit\fP & x)"

.PP
Generates an string from the \fBscalar_unit\fP, it uses the display of the \fBscalar_unit\fP with 2 decimals, without brackets and without a close prefix\&. 
.PP
\fBParameters\fP
.RS 4
\fIx\fP \fBscalar_unit\fP to generate the string\&. 
.RE
.PP

.PP
Definition at line \fB537\fP of file \fBscalar_unit\&.cpp\fP\&..PP
.nf
538     {
539         return x\&.display(2);
540     }
.fi

.SS "\fBstring\fP scifir::to_string (\fBconst\fP \fBsensation\fP &)"

.SS "\fBstring\fP scifir::to_string (\fBconst\fP \fBsize_2d\fP< \fBfloat\fP > & x)"

.PP
Definition at line \fB7\fP of file \fBsize_2d\&.cpp\fP\&..PP
.nf
8     {
9         return x\&.display();
10     }
.fi

.SS "template<\fBtypename\fP T > \fBstring\fP scifir::to_string (\fBconst\fP \fBsize_2d\fP< T > & x)"

.PP
Definition at line \fB208\fP of file \fBsize_2d\&.hpp\fP\&..PP
.nf
209     {
210         return x\&.display();
211     }
.fi

.SS "\fBstring\fP scifir::to_string (\fBconst\fP \fBsize_3d\fP< \fBfloat\fP > & x)"

.PP
Definition at line \fB7\fP of file \fBsize_3d\&.cpp\fP\&..PP
.nf
8     {
9         return x\&.display();
10     }
.fi

.SS "template<\fBtypename\fP T > \fBstring\fP scifir::to_string (\fBconst\fP \fBsize_3d\fP< T > & x)"

.PP
Definition at line \fB222\fP of file \fBsize_3d\&.hpp\fP\&..PP
.nf
223     {
224         return x\&.display();
225     }
.fi

.SS "\fBstring\fP scifir::to_string (\fBconst\fP \fBsize_nd\fP< \fBfloat\fP > & x)"

.PP
Definition at line \fB7\fP of file \fBsize_nd\&.cpp\fP\&..PP
.nf
8     {
9         return x\&.display();
10     }
.fi

.SS "template<\fBtypename\fP T > \fBstring\fP scifir::to_string (\fBconst\fP \fBsize_nd\fP< T > & x)"

.PP
Definition at line \fB332\fP of file \fBsize_nd\&.hpp\fP\&..PP
.nf
333     {
334         return x\&.display();
335     }
.fi

.SS "\fBstring\fP scifir::to_string (\fBconst\fP vector< \fBdimension\fP > & x_dimensions, \fBbool\fP with_brackets)"

.PP
Definition at line \fB1161\fP of file \fBdimension\&.cpp\fP\&..PP
.nf
1162     {
1163         ostringstream out;
1164         if (x_dimensions\&.size() > 0)
1165         {
1166             if (with_brackets)
1167             {
1168                 out << "[";
1169             }
1170             vector<dimension::type> printed_dimensions = vector<dimension::type>();
1171             map<prefix,int> counted_prefixes = map<prefix,int>();
1172             bool first_print = true;
1173             for (const dimension& x_dimension : x_dimensions)
1174             {
1175                 if (x_dimension\&.dimension_sign == dimension::NUMERATOR)
1176                 {
1177                     bool printed = false;
1178                     for (const dimension::type& print_dimension : printed_dimensions)
1179                     {
1180                         if (print_dimension == x_dimension\&.dimension_type)
1181                         {
1182                             printed = true;
1183                         }
1184                     }
1185                     if (printed == true)
1186                     {
1187                         continue;
1188                     }
1189                     counted_prefixes = map<prefix,int>();
1190                     for (const dimension& y_dimension : x_dimensions)
1191                     {
1192                         if (x_dimension\&.dimension_type == y_dimension\&.dimension_type)
1193                         {
1194                             counted_prefixes[y_dimension\&.prefix]++;
1195                         }
1196                     }
1197                     for (const auto& x_prefix : counted_prefixes)
1198                     {
1199                         if (!first_print)
1200                         {
1201                             out << "*";
1202                         }
1203                         out << x_prefix\&.first << x_dimension\&.get_symbol();
1204                         if (x_prefix\&.second > 1)
1205                         {
1206                             out << x_prefix\&.second;
1207                         }
1208                         first_print = false;
1209                     }
1210                     printed_dimensions\&.push_back(x_dimension\&.dimension_type);
1211                 }
1212             }
1213             printed_dimensions\&.clear();
1214             bool first_negative_iteration = true;
1215             bool first_negative_prefix = true;
1216             for (const dimension& x_dimension : x_dimensions)
1217             {
1218                 if (x_dimension\&.dimension_sign == dimension::DENOMINATOR)
1219                 {
1220                     if (first_negative_iteration == true)
1221                     {
1222                         if (first_print)
1223                         {
1224                             out << "1";
1225                         }
1226                         out << "/";
1227                         first_negative_iteration = false;
1228                     }
1229                     bool printed = false;
1230                     for (const dimension::type& print_dimension : printed_dimensions)
1231                     {
1232                         if (print_dimension == x_dimension\&.dimension_type)
1233                         {
1234                             printed = true;
1235                         }
1236                     }
1237                     if (printed == true)
1238                     {
1239                         continue;
1240                     }
1241                     counted_prefixes = map<prefix,int>();
1242                     for (const dimension& y_dimension : x_dimensions)
1243                     {
1244                         if (x_dimension\&.dimension_type == y_dimension\&.dimension_type)
1245                         {
1246                             counted_prefixes[y_dimension\&.prefix]++;
1247                         }
1248                     }
1249                     for (const auto& x_prefix : counted_prefixes)
1250                     {
1251                         if (first_negative_prefix == false)
1252                         {
1253                             out << "*";
1254                         }
1255                         out << x_prefix\&.first << x_dimension\&.get_symbol();
1256                         if (x_prefix\&.second > 1)
1257                         {
1258                             out << x_prefix\&.second;
1259                         }
1260                         first_negative_prefix = false;
1261                     }
1262                     printed_dimensions\&.push_back(x_dimension\&.dimension_type);
1263                 }
1264             }
1265             if (with_brackets)
1266             {
1267                 out << "]";
1268             }
1269         }
1270         else
1271         {
1272             out << "[empty]";
1273         }
1274         return out\&.str();
1275     }
.fi

.SS "\fBstring\fP scifir::to_string (\fBconst\fP \fBvector_unit_2d\fP & x)"

.SS "\fBstring\fP scifir::to_string (\fBconst\fP \fBvector_unit_3d\fP & x)"

.SS "\fBstring\fP scifir::to_string (\fBconst\fP \fBvector_unit_nd\fP & x)"

.PP
Definition at line \fB737\fP of file \fBvector_unit_nd\&.cpp\fP\&..PP
.nf
738     {
739         return x\&.vectorial_display(2);
740     }
.fi

.SS "\fBstring\fP scifir::to_string (\fBconst\fP \fBzid\fP & x)"

.PP
Definition at line \fB171\fP of file \fBzid\&.cpp\fP\&..PP
.nf
172     {
173         return x\&.display();
174     }
.fi

.SS "\fBstring\fP scifir::to_string (\fBdirection::name\fP x)"

.PP
Definition at line \fB279\fP of file \fBdirection\&.cpp\fP\&..PP
.nf
280     {
281         switch (x)
282         {
283             case direction::NONE:
284                 return "";
285             case direction::LEFT:
286                 return "left";
287             case direction::RIGHT:
288                 return "right";
289             case direction::TOP:
290                 return "top";
291             case direction::BOTTOM:
292                 return "bottom";
293             case direction::FRONT:
294                 return "front";
295             case direction::BACK:
296                 return "back";
297             case direction::LEFT_TOP:
298                 return "left\-top";
299             case direction::LEFT_BOTTOM:
300                 return "left\-bottom";
301             case direction::RIGHT_TOP:
302                 return "right\-top";
303             case direction::RIGHT_BOTTOM:
304                 return "right\-bottom";
305             case direction::LEFT_FRONT:
306                 return "left\-front";
307             case direction::LEFT_BACK:
308                 return "left\-back";
309             case direction::RIGHT_FRONT:
310                 return "right\-front";
311             case direction::RIGHT_BACK:
312                 return "right\-back";
313             case direction::TOP_FRONT:
314                 return "top\-front";
315             case direction::TOP_BACK:
316                 return "top\-back";
317             case direction::BOTTOM_FRONT:
318                 return "bottom\-front";
319             case direction::BOTTOM_BACK:
320                 return "bottom\-back";
321             case direction::LEFT_TOP_FRONT:
322                 return "left\-top\-front";
323             case direction::LEFT_TOP_BACK:
324                 return "left\-top\-back";
325             case direction::LEFT_BOTTOM_FRONT:
326                 return "left\-bottom\-front";
327             case direction::LEFT_BOTTOM_BACK:
328                 return "left\-bottom\-back";
329             case direction::RIGHT_TOP_FRONT:
330                 return "right\-top\-front";
331             case direction::RIGHT_TOP_BACK:
332                 return "right\-top\-back";
333             case direction::RIGHT_BOTTOM_FRONT:
334                 return "right\-bottom\-front";
335             case direction::RIGHT_BOTTOM_BACK:
336                 return "right\-bottom\-back";
337         }
338         return "";
339     }
.fi

.SS "scifir::VECTOR_UNIT_2D_CPP (\fBdisplacement\fP, 'm')"

.SS "scifir::VECTOR_UNIT_2D_HPP (\fBdisplacement\fP)"

.SS "scifir::VECTOR_UNIT_3D_CPP (\fBdisplacement\fP, 'm')"

.SS "scifir::VECTOR_UNIT_3D_HPP (\fBdisplacement\fP)"

.SS "scifir::VECTOR_UNIT_CPP (\fBacceleration\fP, 'm/\fBs2'\fP)"

.SS "scifir::VECTOR_UNIT_CPP (\fBangular_acceleration\fP, 'rad/\fBs2'\fP)"

.SS "scifir::VECTOR_UNIT_CPP (\fBangular_momentum\fP, 'm2*\fBkg\fP/\fBs'\fP)"

.SS "scifir::VECTOR_UNIT_CPP (\fBangular_velocity\fP, 'rad/\fBs'\fP)"

.SS "scifir::VECTOR_UNIT_CPP (\fBelectric_displacement_field\fP, 'A*s/\fBm2'\fP)"

.SS "scifir::VECTOR_UNIT_CPP (\fBelectric_field_strength\fP, 'kg*m/A*\fBs3'\fP)"

.SS "scifir::VECTOR_UNIT_CPP (\fBforce\fP, 'kg*m/\fBs2'\fP)"

.SS "scifir::VECTOR_UNIT_CPP (\fBimpulse\fP, 'm*\fBkg\fP/\fBs'\fP)"

.SS "scifir::VECTOR_UNIT_CPP (\fBirradiance\fP, 'kg/\fBs3'\fP)"

.SS "scifir::VECTOR_UNIT_CPP (\fBjerk\fP, 'm/\fBs3'\fP)"

.SS "scifir::VECTOR_UNIT_CPP (\fBmagnetic_moment\fP, 'A*\fBm2'\fP)"

.SS "scifir::VECTOR_UNIT_CPP (\fBmagnetic_strength\fP, 'Wb/\fBm2'\fP)"

.SS "scifir::VECTOR_UNIT_CPP (\fBmagnetic_vector_potential\fP, 'kg*m/A*\fBs2'\fP)"

.SS "scifir::VECTOR_UNIT_CPP (\fBmagnetomotive_force\fP, 'A')"

.SS "scifir::VECTOR_UNIT_CPP (\fBpressure\fP, 'kg/m*\fBs2'\fP)"

.SS "scifir::VECTOR_UNIT_CPP (\fBradiant_exposure\fP, 'kg/\fBs2'\fP)"

.SS "scifir::VECTOR_UNIT_CPP (\fBradiant_flux\fP, 'kg*\fBm2\fP/\fBs3'\fP)"

.SS "scifir::VECTOR_UNIT_CPP (\fBsnap\fP, 'm/\fBs4'\fP)"

.SS "scifir::VECTOR_UNIT_CPP (\fBspecific_angular_momentum\fP, 'm2/\fBs'\fP)"

.SS "scifir::VECTOR_UNIT_CPP (\fBspectral_flux\fP, 'kg*m/\fBs3'\fP)"

.SS "scifir::VECTOR_UNIT_CPP (\fBsurface_tension\fP, 'kg/\fBs2'\fP)"

.SS "scifir::VECTOR_UNIT_CPP (\fBtemperature_gradient\fP, 'K/\fBm'\fP)"

.SS "scifir::VECTOR_UNIT_CPP (\fBtorque\fP, 'kg*\fBm2\fP/\fBs2'\fP)"

.SS "scifir::VECTOR_UNIT_CPP (\fBvelocity\fP, 'm/\fBs'\fP)"

.SS "scifir::VECTOR_UNIT_HPP (\fBacceleration\fP)"

.SS "scifir::VECTOR_UNIT_HPP (\fBangular_acceleration\fP)"

.SS "scifir::VECTOR_UNIT_HPP (\fBangular_momentum\fP)"

.SS "scifir::VECTOR_UNIT_HPP (\fBangular_velocity\fP)"

.SS "scifir::VECTOR_UNIT_HPP (\fBelectric_displacement_field\fP)"

.SS "scifir::VECTOR_UNIT_HPP (\fBelectric_field_strength\fP)"

.SS "scifir::VECTOR_UNIT_HPP (\fBforce\fP)"

.SS "scifir::VECTOR_UNIT_HPP (\fBimpulse\fP)"

.SS "scifir::VECTOR_UNIT_HPP (\fBirradiance\fP)"

.SS "scifir::VECTOR_UNIT_HPP (\fBjerk\fP)"

.SS "scifir::VECTOR_UNIT_HPP (\fBmagnetic_moment\fP)"

.SS "scifir::VECTOR_UNIT_HPP (\fBmagnetic_strength\fP)"

.SS "scifir::VECTOR_UNIT_HPP (\fBmagnetic_vector_potential\fP)"

.SS "scifir::VECTOR_UNIT_HPP (\fBmagnetomotive_force\fP)"

.SS "scifir::VECTOR_UNIT_HPP (\fBpressure\fP)"

.SS "scifir::VECTOR_UNIT_HPP (\fBradiant_exposure\fP)"

.SS "scifir::VECTOR_UNIT_HPP (\fBradiant_flux\fP)"

.SS "scifir::VECTOR_UNIT_HPP (\fBsnap\fP)"

.SS "scifir::VECTOR_UNIT_HPP (\fBspecific_angular_momentum\fP)"

.SS "scifir::VECTOR_UNIT_HPP (\fBspectral_flux\fP)"

.SS "scifir::VECTOR_UNIT_HPP (\fBsurface_tension\fP)"

.SS "scifir::VECTOR_UNIT_HPP (\fBtemperature_gradient\fP)"

.SS "scifir::VECTOR_UNIT_HPP (\fBtorque\fP)"

.SS "scifir::VECTOR_UNIT_HPP (\fBvelocity\fP)"

.SS "scifir::VECTOR_UNIT_ND_CPP (\fBdisplacement\fP, 'm')"

.SS "scifir::VECTOR_UNIT_ND_HPP (\fBdisplacement\fP)"

.SS "scifir::volume::volume (\fBconst\fP \fBsize_3d\fP< \fBlength\fP > & x)\fC [explicit]\fP"

.PP
Definition at line \fB22\fP of file \fBspace_units\&.cpp\fP\&..PP
.nf
22                                            : scalar_unit()
23     {
24         length x_height = x\&.height;
25         length x_depth = x\&.depth;
26         x_height\&.change_dimensions(x\&.width);
27         x_depth\&.change_dimensions(x\&.width);
28         *this = x\&.width * x_height * x_depth;
29     }
.fi

.SH "Variable Documentation"
.PP 
.SS "\fBconst\fP \fBlong\fP \fBdouble\fP scifir::AVOGADRO_CONSTANT = 6\&.02214076\fBe23\fP\fC [static]\fP"

.PP
Definition at line \fB11\fP of file \fBconstants\&.hpp\fP\&.
.SS "\fBangle\fP scifir::coordinates_ndr_no_angle = \fBangle\fP()"

.PP
Definition at line \fB7\fP of file \fBcoordinates_ndr\&.cpp\fP\&.
.SS "\fBmap\fP< \fBstring\fP, \fBconversion\fP > scifir::get_conversion"

.PP
Definition at line \fB22\fP of file \fBconversion\&.cpp\fP\&..PP
.nf
23     {
24         // Common units
25         {"ha", conversion("hm2", 1\&.0L)}, // Hectare
26         {"ly", conversion("AU", 63241\&.0L)}, // Light\-year
27         {"dyn", conversion("N", 0\&.00001L)}, // Dyne
28         {"Ba", conversion("Pa", 0\&.1L)}, // Barye
29         {"bar", conversion("Pa", 100000\&.0L)}, // Bar
30         {"atm", conversion("Pa", 101325\&.0L)}, // Atmosphere
31         {"mmHg", conversion("Pa", 133\&.322387415L)}, // mmHg
32         {"Torr", conversion("Pa", 101325\&.0L / 760\&.0L)}, // Torricelli
33         // England units
34         {"in", conversion("mm", 25\&.4L)},
35         {"inch", conversion("mm", 25\&.4L)},
36         {"ft", conversion("m", 0\&.3048L)},
37         {"foot", conversion("m", 0\&.3048L)},
38         {"yd", conversion("m", 0\&.9144L)},
39         {"yard", conversion("m", 0\&.9144L)},
40         {"mi", conversion("km", 1\&.609L)},
41         {"mile", conversion("km", 1\&.609L)},
42         {"acre", conversion("hm2", 0\&.4047L)},
43         {"gal(us)", conversion("", 3\&.785L)},
44         {"gallon(us)", conversion("", 3\&.785L)},
45         {"fluid_ounce(us)", conversion("m", 29\&.5735295641119L)},
46         {"quart(us)", conversion("", 0\&.94635294605158L)},
47         {"pint(us)", conversion("", 0\&.47317647302579L)},
48         {"gal(imperial)", conversion("", 4\&.54609000011111L)},
49         {"gallon(imperial)", conversion("", 4\&.54609000011111L)},
50         {"fluid_ounce(imperial)", conversion("m", 28\&.4130625006944L)},
51         {"quart(imperial)", conversion("", 1\&.13652250002778L)},
52         {"pint(imperial)", conversion("", 0\&.568261250013888L)},
53         {"cup(us)", conversion("m", 236\&.588236512895L)},
54         {"tablespoon(us)", conversion("m", 14\&.7867647820559L)},
55         {"teaspoon(us)", conversion("m", 4\&.92892159401865L)},
56         {"cup(imperial)", conversion("m", 284\&.130625014338L)},
57         {"tablespoon(imperial)", conversion("m", 17\&.7581640707895L)},
58         {"teaspoon(imperial)", conversion("m", 5\&.91938802359649L)},
59         {"cup", conversion("m", 250\&.0L)},
60         {"tablespoon", conversion("m", 15\&.0000000147868L)},
61         {"teaspoon", conversion("m", 5\&.00000000027252L)},
62         {"barrel(us)", conversion("", 119\&.240471202499L)},
63         {"barrel(imperial)", conversion("", 163\&.659240008909L)},
64         {"barrel(us_fed)", conversion("", 117\&.347765310396L)},
65         {"gill(us)", conversion("m", 118\&.294118256447L)},
66         {"gill(imperial)", conversion("m", 142\&.065312507169L)},
67         {"shot", conversion("m", 44\&.3602943461678L)},
68         {"oz", conversion("g", 28\&.35L)},
69         {"ounce", conversion("g", 28\&.35L)},
70         {"lb", conversion("kg", 0\&.4536L)},
71         {"pound", conversion("kg", 0\&.4536L)},
72         {"quarter(us)",conversion("kg",11\&.3398092595095L)},
73         {"quarter(imperial)",conversion("kg",12\&.7005863706506L)},
74         {"ton", conversion("kg", 1000\&.0L)},
75         {"ton(us)", conversion("kg", 907\&.184740760757L)},
76         {"ton(imperial)", conversion("kg", 1016\&.04690965205L)},
77         {"stone(us)", conversion("kg", 5\&.66990462975473L)},
78         {"stone(imperial)", conversion("kg", 6\&.3502931853253L)},
79         {"quintal", conversion("kg", 100\&.000000083915L)},
80         {"carat", conversion("g", 0\&.2L)},
81         {"grain", conversion("g", 0\&.0647989100543398L)},
82         {"lbf", conversion("N", 4\&.448L)},
83         {"pound_force", conversion("N", 4\&.448L)},
84         {"tnf", conversion("kN", 8\&.896L)},
85         {"ton_force", conversion("kN", 8\&.896L)},
86         {"psi", conversion("Pa", 6894\&.76L)},
87         {"Btu", conversion("J", 1055\&.0L)},
88         {"ft\-lbf", conversion("J", 1356\&.0L)},
89         {"foot_pound_force", conversion("J", 1356\&.0L)},
90         {"Wh", conversion("J", 3600\&.0L)},
91         {"kWh", conversion("J", 3600000\&.0L)},
92         {"HP", conversion("kW", 0\&.7355L)},
93         {"hp", conversion("kW", 0\&.7457L)},
94         {"C", conversion("K", 1\&.0L)},
95         {"F", conversion("K", 5\&.0L / 9\&.0L)},
96         {"bit", conversion("B", 1\&.0L / 8\&.0L)},
97         {"kbit", conversion("B", 125\&.0L)},
98         {"Mbit", conversion("kB", 125\&.0L)},
99         {"Gbit", conversion("MB", 125\&.0L)},
100         {"Tbit", conversion("GB", 125\&.0L)},
101         {"Pbit", conversion("TB", 125\&.0L)},
102         {"Ebit", conversion("PB", 125\&.0L)},
103         {"Zbit", conversion("EB", 125\&.0L)},
104         {"Ybit", conversion("ZB", 125\&.0L)},
105     };
.fi

.SS "\fBconstexpr\fP \fBfloat\fP scifir::PI = boost::math::constants::pi<\fBfloat\fP>()\fC [constexpr]\fP"

.PP
Definition at line \fB10\fP of file \fBconstants\&.hpp\fP\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for scifir-units from the source code\&.
