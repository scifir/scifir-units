.TH "scifir::dimension" 3 "Sat Jul 13 2024" "Version 2.0.0" "scifir-units" \" -*- nroff -*-
.ad l
.nh
.SH NAME
scifir::dimension \- Class that represents dimensions of the SI system of units\&. Each prefix sizes 6 bytes, 1 byte for the dimension type, 1 byte for the prefix, 1 byte for the position (which can be the NUMERATOR or the DENOMINATOR), and 3 bytes for the custom dimension (in case it's used one)\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <dimension\&.hpp>\fP
.SS "Public Types"

.in +1c
.ti -1c
.RI "enum \fBtype\fP : int8_t { \fBNONE\fP, \fBMETRE\fP, \fBDEGREE\fP, \fBRADIAN\fP, \fBSTERADIAN\fP, \fBSECOND\fP, \fBGRAM\fP, \fBCOULOMB\fP, \fBKELVIN\fP, \fBMOLE\fP, \fBCANDELA\fP, \fBBYTE\fP, \fBHERTZ\fP, \fBNEWTON\fP, \fBPASCAL\fP, \fBJOULE\fP, \fBWATT\fP, \fBAMPERE\fP, \fBVOLT\fP, \fBFARADAY\fP, \fBOHM\fP, \fBSIEMENS\fP, \fBWEBER\fP, \fBTESLA\fP, \fBHENRY\fP, \fBLUMEN\fP, \fBLUX\fP, \fBBECQUEREL\fP, \fBGRAY\fP, \fBSIEVERT\fP, \fBKATAL\fP, \fBANGSTROM\fP, \fBLITRE\fP, \fBMINUTE\fP, \fBHOUR\fP, \fBDAY\fP, \fBLIGHT_YEAR\fP, \fBASTRONOMICAL_UNIT\fP, \fBPARSEC\fP, \fBELECTRON_VOLT\fP, \fBDALTON\fP, \fBATOMIC_MASS_UNIT\fP, \fBBARN\fP, \fBMOLARITY\fP, \fBPARTICLES\fP, \fBCUSTOM\fP, \fBCUSTOM_BASIC\fP, \fBCUSTOM_FULL_SYMBOL\fP, \fBMONEY\fP, \fBPIXEL\fP, \fBMEMO\fP }"
.br
.RI "Represents a dimension of the SI system of units\&. All the dimensions of the SI system of units are supported\&. There are also dimensions supported that aren't considered yet part of the SI system of units, but that are widely used\&. "
.ti -1c
.RI "enum \fBposition\fP : int8_t { \fBNO_POSITION\fP, \fBNUMERATOR\fP, \fBDENOMINATOR\fP }"
.br
.RI "Represents the position of the dimension, which can be at the numerator or at the denominator\&. The value NO_POSITION is used when there's no position specified\&. "
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBdimension\fP ()"
.br
.RI "Default constructor\&. The dimension_type is NONE, the dimension_position is NO_POSITION, and the prefix is NONE, the symbol is empty\&. "
.ti -1c
.RI "\fBdimension\fP (const \fBdimension\fP &x)"
.br
.RI "Copy constructor\&. The dimension is initialized to be a copy of the dimension x\&. "
.ti -1c
.RI "\fBdimension\fP (\fBdimension\fP &&x)"
.br
.RI "Move constructor\&. The dimension is initialized with a move of the dimension x\&. "
.ti -1c
.RI "\fBdimension\fP (\fBdimension::type\fP new_dimension_type, \fBscifir::prefix::type\fP new_prefix, \fBdimension::position\fP new_position)"
.br
.ti -1c
.RI "\fBdimension\fP (\fBdimension::type\fP new_dimension_type, const \fBscifir::prefix\fP &new_prefix, \fBdimension::position\fP new_position)"
.br
.ti -1c
.RI "\fBdimension\fP (const string &init_dimension, \fBdimension::position\fP new_position)"
.br
.ti -1c
.RI "\fBdimension\fP & \fBoperator=\fP (const \fBdimension\fP &x)"
.br
.RI "Copy assignment\&. The dimension copies the dimension x\&. "
.ti -1c
.RI "\fBdimension\fP & \fBoperator=\fP (\fBdimension\fP &&x)"
.br
.RI "Move assignment\&. The dimension values are all moved from the dimension x\&. "
.ti -1c
.RI "string \fBget_name\fP () const"
.br
.RI "Returns the name of the dimension\&. "
.ti -1c
.RI "string \fBget_symbol\fP () const"
.br
.RI "Returns the symbol of the dimension\&. In the case of a custom dimension, it returns the custom dimension defined\&. "
.ti -1c
.RI "long double \fBget_conversion_factor\fP () const"
.br
.RI "Returns the conversion factor of the dimension\&. "
.ti -1c
.RI "long double \fBprefix_math\fP () const"
.br
.RI "Returns the math between the prefix and the dimension, which varies if the dimension is a B or another\&. In the case of bytes the math with the prefix is different, it's done with 1024 instead of multiples of 10\&. It doesn't includes the conversion factor of dimensions\&. "
.ti -1c
.RI "long double \fBprefix_math\fP (const \fBprefix\fP &x_prefix) const"
.br
.RI "Returns the math between some prefix and the dimension\&. The difference with the other \fBprefix_math()\fP function is that the prefix is given as parameter\&. "
.ti -1c
.RI "bool \fBis_simple_dimension\fP () const"
.br
.RI "If the dimension doesn't has more derived dimensions, it's considered a simple dimension\&. "
.ti -1c
.RI "bool \fBis_basic_dimension\fP () const"
.br
.RI "If the dimension is an SI basic dimension, it's considered a basic dimension\&. "
.ti -1c
.RI "bool \fBis_derived_dimension\fP () const"
.br
.RI "If the dimension is not a basic dimension, it's considered a derived dimension\&. "
.ti -1c
.RI "vector< \fBdimension\fP > \fBget_basic_dimensions\fP () const"
.br
.RI "Returns the basic dimensions of the dimension, which are different than the dimension, and possible more than one, if the dimension is not basic\&. "
.ti -1c
.RI "void \fBinvert\fP ()"
.br
.RI "Changes the position of the dimension to the reverse, from the NUMERATOR to the DENOMINATOR, or from the DENOMINATOR to the NUMERATOR\&. "
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static void \fBcreate_custom_dimension\fP (const string &new_symbol, const string &init_dimensions)"
.br
.RI "Creates a new custom dimension, that's stored with its symbol, which is given as an string, and the dimensions it can be derived to, if this custom dimension is not a new basic dimension\&. "
.ti -1c
.RI "static char * \fBcreate_full_symbol\fP (const string &full_symbol)"
.br
.RI "Creates a new dimension that's stored in the private static map \fBdimension::full_symbols\fP\&. "
.ti -1c
.RI "static string \fBget_full_symbol\fP (const char *x_symbol)"
.br
.RI "Returns the symbol of a custom_full_symbol dimension stored in the private static map \fBdimension::full_symbols\fP\&. "
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "\fBscifir::prefix\fP \fBprefix\fP"
.br
.RI "The prefix of the dimension\&. It's used along with the symbol of the dimension when printing it\&. "
.ti -1c
.RI "\fBdimension::type\fP \fBdimension_type\fP"
.br
.RI "The type of the dimension\&. "
.ti -1c
.RI "\fBdimension::position\fP \fBdimension_position\fP"
.br
.RI "The position of the dimension, which can be the NUMERATOR, the DENOMINATOR or NO_POSITION\&. NO_POSITION means that the dimension is not ready to be used, and must be changed if the dimension is intended to be used\&. "
.ti -1c
.RI "char \fBsymbol\fP [3]"
.br
.RI "The value of the position of the character of a custom dimension in the map of full_symbols\&. "
.in -1c
.SS "Static Private Attributes"

.in +1c
.ti -1c
.RI "static map< string, vector< \fBdimension\fP > > \fBbase_dimensions\fP = map<string,vector<\fBdimension\fP>>()"
.br
.ti -1c
.RI "static map< int, string > \fBfull_symbols\fP = map<int,string>()"
.br
.ti -1c
.RI "static int \fBtotal_full_symbols\fP = 0"
.br
.ti -1c
.RI "static set< string > \fBprefixes_options\fP {'Y', 'Z', 'E', 'P', 'T', 'G', 'M', 'k', 'h', 'd', 'c', 'm', '\\u00B5', 'u', 'n', 'p', 'f', 'a', 'z', 'y'}"
.br
.in -1c
.SH "Detailed Description"
.PP 
Class that represents dimensions of the SI system of units\&. Each prefix sizes 6 bytes, 1 byte for the dimension type, 1 byte for the prefix, 1 byte for the position (which can be the NUMERATOR or the DENOMINATOR), and 3 bytes for the custom dimension (in case it's used one)\&. 
.PP
Definition at line 28 of file dimension\&.hpp\&.
.SH "Member Enumeration Documentation"
.PP 
.SS "enum \fBscifir::dimension::position\fP : int8_t"

.PP
Represents the position of the dimension, which can be at the numerator or at the denominator\&. The value NO_POSITION is used when there's no position specified\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fINO_POSITION \fP\fP
The dimension is not ready and yet being used\&. 
.TP
\fB\fINUMERATOR \fP\fP
The dimension is at the numerator\&. 
.TP
\fB\fIDENOMINATOR \fP\fP
The dimension is at the denominator\&. 
.PP
Definition at line 36 of file dimension\&.hpp\&.
.PP
.nf
36 : int8_t {NO_POSITION, NUMERATOR, DENOMINATOR};
.fi
.SS "enum \fBscifir::dimension::type\fP : int8_t"

.PP
Represents a dimension of the SI system of units\&. All the dimensions of the SI system of units are supported\&. There are also dimensions supported that aren't considered yet part of the SI system of units, but that are widely used\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fINONE \fP\fP
No dimension\&. Default value for the default constructor\&. 
.TP
\fB\fIMETRE \fP\fP
Meter\&. \fBSI dimension\fP of length\&. 
.TP
\fB\fIDEGREE \fP\fP
Degree\&. Dimension of angle\&. 
.TP
\fB\fIRADIAN \fP\fP
Radian\&. Dimension of angle\&. 
.TP
\fB\fISTERADIAN \fP\fP
Steradian\&. Dimension of solid angle\&. A solid angle is an angle in volume\&. 
.TP
\fB\fISECOND \fP\fP
Second\&. \fBSI dimension\fP of time\&. 
.TP
\fB\fIGRAM \fP\fP
Gram\&. \fBSI dimension\fP of mass\&. 
.TP
\fB\fICOULOMB \fP\fP
Coulomb\&. \fBSI dimension\fP of charge\&. 
.TP
\fB\fIKELVIN \fP\fP
Kelvin\&. \fBSI dimension\fP of temperature\&. 
.TP
\fB\fIMOLE \fP\fP
Mole\&. \fBSI dimension\fP of quantity\&. 
.TP
\fB\fICANDELA \fP\fP
Candela\&. \fBSI dimension\fP of luminous intensity\&. 
.TP
\fB\fIBYTE \fP\fP
Byte\&. Dimension of amount of information\&. 
.TP
\fB\fIHERTZ \fP\fP
Hertz\&. Dimension of frequency\&. 
.TP
\fB\fINEWTON \fP\fP
Newton\&. Dimension of force\&. 
.TP
\fB\fIPASCAL \fP\fP
Pascal\&. Dimension of pressure\&. 
.TP
\fB\fIJOULE \fP\fP
Joule\&. Dimension of energy\&. 
.TP
\fB\fIWATT \fP\fP
Watt\&. Dimension of power\&. 
.TP
\fB\fIAMPERE \fP\fP
Ampere\&. Dimension of electric current\&. 
.TP
\fB\fIVOLT \fP\fP
Volt\&. Dimension of voltage\&. 
.TP
\fB\fIFARADAY \fP\fP
Faraday\&. Dimension of electric capacitance\&. 
.TP
\fB\fIOHM \fP\fP
Ohm\&. Dimension of electric resistance\&. 
.TP
\fB\fISIEMENS \fP\fP
Siemens\&. Dimension of electric conductance\&. 
.TP
\fB\fIWEBER \fP\fP
Weber\&. Dimension of magnetic flux\&. 
.TP
\fB\fITESLA \fP\fP
Tesla\&. Dimension of magnetic strength\&. 
.TP
\fB\fIHENRY \fP\fP
Henry\&. Dimension of electric inductance\&. 
.TP
\fB\fILUMEN \fP\fP
Lumen\&. Dimension of luminous flux\&. 
.TP
\fB\fILUX \fP\fP
Lux\&. Dimension of illuminance\&. 
.TP
\fB\fIBECQUEREL \fP\fP
Becquerel\&. Dimension of radioactivity\&. 
.TP
\fB\fIGRAY \fP\fP
Gray\&. Dimension of ionising radiation (absorbed dose)\&. 
.TP
\fB\fISIEVERT \fP\fP
Sievert\&. Dimension of ionising radiation (equivalent dose)\&. 
.TP
\fB\fIKATAL \fP\fP
Katal\&. Dimension of catalytic activity\&. 
.TP
\fB\fIANGSTROM \fP\fP
Ãngstrom\&. Dimension of length, used mainly for wavelengths\&. 
.TP
\fB\fILITRE \fP\fP
Litre\&. Dimension of volume\&. 
.TP
\fB\fIMINUTE \fP\fP
Minute\&. Dimension of time\&. 
.TP
\fB\fIHOUR \fP\fP
Hour\&. Dimension of time\&. 
.TP
\fB\fIDAY \fP\fP
Day\&. Dimension of time\&. 
.TP
\fB\fILIGHT_YEAR \fP\fP
Light year\&. Dimension of length\&. Defined as all the distance travelled by light in one year\&. 
.TP
\fB\fIASTRONOMICAL_UNIT \fP\fP
Astronomical Unit\&. Dimension of length\&. Defined as the distance from the Sun to the Earth\&. 
.TP
\fB\fIPARSEC \fP\fP
Parsec\&. Dimension of length\&. Defined as the distance where 1 AU subtends an angle of 1 second of arc\&. Equivalent to 3\&.26156 light years\&. 
.TP
\fB\fIELECTRON_VOLT \fP\fP
Electron volt\&. Dimension of energy\&. 
.TP
\fB\fIDALTON \fP\fP
Dalton\&. Dimension of mass\&. Used to measure the mass of atoms and molecules\&. Defined as 1/12 of a C-12\&. 
.TP
\fB\fIATOMIC_MASS_UNIT \fP\fP
Atomic mass unit\&. Equivalent to the Dalton\&. Dimension of mass\&. Used to measure the mass of atoms and molecules\&. 
.TP
\fB\fIBARN \fP\fP
Barn\&. Dimension of area\&. It's used inside nuclear physics to express the transversal section of nucleus and nuclear reactions\&. 
.TP
\fB\fIMOLARITY \fP\fP
Molarity\&. Dimension of concentration of a chemical species\&. 
.TP
\fB\fIPARTICLES \fP\fP
Particles\&. It's not exactly a dimension, it corresponds to the brute amount of particles, as opposed to the mole\&. 
.TP
\fB\fICUSTOM \fP\fP
Custom dimension\&. It means the dimension is a custom dimension, which can have any value and meaning, defined freely by the programmer\&. Each custom dimension is unique to where it's defined and used\&. 
.TP
\fB\fICUSTOM_BASIC \fP\fP
.TP
\fB\fICUSTOM_FULL_SYMBOL \fP\fP
.TP
\fB\fIMONEY \fP\fP
Money\&. The money is not specified in a specific currency, you must use the ISO 4217 of currencies for that purpose\&. Don't mistake mixing different currencies\&. 
.TP
\fB\fIPIXEL \fP\fP
Amount of pixels\&. Used for screen sizes\&. It can also be used as distance, in replacement of length dimensions, if in a virtual space it's thinked in pixels instead of normal dimensions of length\&. 
.TP
\fB\fIMEMO \fP\fP
Invented unit inside Scifir, it's not part of the SI system of units\&. It represents a unit of human or animal memory\&. Each memory of the brain has some size hypothetically measurable in memos\&. 
.PP
Definition at line 31 of file dimension\&.hpp\&.
.PP
.nf
32             {
33                 NONE, METRE, DEGREE, RADIAN, STERADIAN, SECOND, GRAM, COULOMB, KELVIN, MOLE, CANDELA, BYTE, HERTZ, NEWTON, PASCAL, JOULE, WATT, AMPERE, VOLT, FARADAY, OHM, SIEMENS, WEBER, TESLA, HENRY, LUMEN, LUX, BECQUEREL, GRAY, SIEVERT, KATAL, ANGSTROM, LITRE, MINUTE, HOUR, DAY, LIGHT_YEAR, ASTRONOMICAL_UNIT, PARSEC, ELECTRON_VOLT, DALTON, ATOMIC_MASS_UNIT, BARN, MOLARITY, PARTICLES, CUSTOM, CUSTOM_BASIC, CUSTOM_FULL_SYMBOL, MONEY, PIXEL, MEMO
34             };
.fi
.SH "Constructor & Destructor Documentation"
.PP 
.SS "dimension::dimension ()"

.PP
Default constructor\&. The dimension_type is NONE, the dimension_position is NO_POSITION, and the prefix is NONE, the symbol is empty\&. 
.PP
Definition at line 23 of file dimension\&.cpp\&.
.PP
.nf
23                          : prefix(),dimension_type(dimension::NONE),dimension_position(dimension::NO_POSITION),symbol()
24     {}
.fi
.SS "dimension::dimension (const \fBdimension\fP & x)"

.PP
Copy constructor\&. The dimension is initialized to be a copy of the dimension x\&. 
.SS "dimension::dimension (\fBdimension\fP && x)"

.PP
Move constructor\&. The dimension is initialized with a move of the dimension x\&. 
.SS "scifir::dimension::dimension (\fBdimension::type\fP new_dimension_type, \fBscifir::prefix::type\fP new_prefix, \fBdimension::position\fP new_position)\fC [explicit]\fP"

.PP
Definition at line 48 of file dimension\&.cpp\&.
.PP
.nf
48                                                                                                                     : prefix(new_prefix),dimension_type(new_dimension_type),dimension_position(new_position),symbol()
49     {}
.fi
.SS "scifir::dimension::dimension (\fBdimension::type\fP new_dimension_type, const \fBscifir::prefix\fP & new_prefix, \fBdimension::position\fP new_position)\fC [explicit]\fP"

.PP
Definition at line 51 of file dimension\&.cpp\&.
.PP
.nf
51                                                                                                                        : prefix(new_prefix),dimension_type(new_dimension_type),dimension_position(new_position),symbol()
52     {}
.fi
.SS "scifir::dimension::dimension (const string & init_dimension, \fBdimension::position\fP new_position)\fC [explicit]\fP"

.PP
Definition at line 54 of file dimension\&.cpp\&.
.PP
.nf
54                                                                                     : prefix(),dimension_type(dimension::NONE),dimension_position(new_position),symbol()
55     {
56         string dimension_name;
57         string prefix_name;
58         if(dimension::prefixes_options\&.count(init_dimension\&.substr(0,1)) and init_dimension != "degree" and init_dimension != "rad" and init_dimension != "sr" and init_dimension != "m" and init_dimension != "Pa" and init_dimension\&.substr(0,2) != "da" and init_dimension\&.substr(0,3) != "mol" and init_dimension != "cd" and init_dimension != "T" and init_dimension != "Gy" and init_dimension != "kat" and init_dimension != "angstrom" and init_dimension != "min" and init_dimension != "h" and init_dimension != "d" and init_dimension != "pc" and init_dimension != "amu" and init_dimension != "M" and init_dimension != "particles" and init_dimension != "money" and init_dimension != "px" and init_dimension != "memo")
59         {
60             prefix_name = init_dimension\&.substr(0,1);
61             dimension_name = init_dimension\&.substr(1);
62         }
63         else if(init_dimension\&.substr(0,2) == "da")
64         {
65             prefix_name = "da";
66             dimension_name = init_dimension\&.substr(2);
67         }
68         else
69         {
70             prefix_name = "";
71             dimension_name = init_dimension;
72         }
73         prefix = scifir::prefix(prefix_name);
74         if(dimension_name == "m")
75         {
76             dimension_type = dimension::METRE;
77         }
78         else if(dimension_name == "degree")
79         {
80             dimension_type = dimension::DEGREE;
81         }
82         else if(dimension_name == "rad")
83         {
84             dimension_type = dimension::RADIAN;
85         }
86         else if(dimension_name == "sr")
87         {
88             dimension_type = dimension::STERADIAN;
89         }
90         else if(dimension_name == "s")
91         {
92             dimension_type = dimension::SECOND;
93         }
94         else if(dimension_name == "g")
95         {
96             dimension_type = dimension::GRAM;
97         }
98         else if(dimension_name == "C")
99         {
100             dimension_type = dimension::COULOMB;
101         }
102         else if(dimension_name == "K")
103         {
104             dimension_type = dimension::KELVIN;
105         }
106         else if(dimension_name == "mol")
107         {
108             dimension_type = dimension::MOLE;
109         }
110         else if(dimension_name == "cd")
111         {
112             dimension_type = dimension::CANDELA;
113         }
114         else if(dimension_name == "B")
115         {
116             dimension_type = dimension::BYTE;
117         }
118         else if(dimension_name == "Hz")
119         {
120             dimension_type = dimension::HERTZ;
121         }
122         else if(dimension_name == "N")
123         {
124             dimension_type = dimension::NEWTON;
125         }
126         else if(dimension_name == "Pa")
127         {
128             dimension_type = dimension::PASCAL;
129         }
130         else if(dimension_name == "J")
131         {
132             dimension_type = dimension::JOULE;
133         }
134         else if(dimension_name == "W")
135         {
136             dimension_type = dimension::WATT;
137         }
138         else if(dimension_name == "A")
139         {
140             dimension_type = dimension::AMPERE;
141         }
142         else if(dimension_name == "V")
143         {
144             dimension_type = dimension::VOLT;
145         }
146         else if(dimension_name == "F")
147         {
148             dimension_type = dimension::FARADAY;
149         }
150         else if(dimension_name == "ohm" or dimension_name == "Ohm"/* or dimension_name == U"\U000003A9"*/)
151         {
152             dimension_type = dimension::OHM;
153         }
154         else if(dimension_name == "S")
155         {
156             dimension_type = dimension::SIEMENS;
157         }
158         else if(dimension_name == "Wb")
159         {
160             dimension_type = dimension::WEBER;
161         }
162         else if(dimension_name == "T")
163         {
164             dimension_type = dimension::TESLA;
165         }
166         else if(dimension_name == "H")
167         {
168             dimension_type = dimension::HENRY;
169         }
170         else if(dimension_name == "lm")
171         {
172             dimension_type = dimension::LUMEN;
173         }
174         else if(dimension_name == "lx")
175         {
176             dimension_type = dimension::LUX;
177         }
178         else if(dimension_name == "Bq")
179         {
180             dimension_type = dimension::BECQUEREL;
181         }
182         else if(dimension_name == "Gy")
183         {
184             dimension_type = dimension::GRAY;
185         }
186         else if(dimension_name == "Sv")
187         {
188             dimension_type = dimension::SIEVERT;
189         }
190         else if(dimension_name == "kat")
191         {
192             dimension_type = dimension::KATAL;
193         }
194         else if(dimension_name == "angstrom" or u32string(dimension_name\&.begin(),dimension_name\&.end()) == U"\U0000212B")
195         {
196             dimension_type = dimension::ANGSTROM;
197         }
198         else if(dimension_name == "L")
199         {
200             dimension_type = dimension::LITRE;
201         }
202         else if(dimension_name == "min")
203         {
204             dimension_type = dimension::MINUTE;
205         }
206         else if(dimension_name == "h")
207         {
208             dimension_type = dimension::HOUR;
209         }
210         else if(dimension_name == "d")
211         {
212             dimension_type = dimension::DAY;
213         }
214         else if(dimension_name == "ly")
215         {
216             dimension_type = dimension::LIGHT_YEAR;
217         }
218         else if(dimension_name == "AU")
219         {
220             dimension_type = dimension::ASTRONOMICAL_UNIT;
221         }
222         else if(dimension_name == "pc")
223         {
224             dimension_type = dimension::PARSEC;
225         }
226         else if(dimension_name == "eV")
227         {
228             dimension_type = dimension::ELECTRON_VOLT;
229         }
230         else if(dimension_name == "Da")
231         {
232             dimension_type = dimension::DALTON;
233         }
234         else if(dimension_name == "amu")
235         {
236             dimension_type = dimension::ATOMIC_MASS_UNIT;
237         }
238         else if(dimension_name == "barn")
239         {
240             dimension_type = dimension::BARN;
241         }
242         else if(dimension_name == "M")
243         {
244             dimension_type = dimension::MOLARITY;
245         }
246         else if(dimension_name == "particles")
247         {
248             dimension_type = dimension::PARTICLES;
249         }
250         else if(dimension_name == "money")
251         {
252             dimension_type = dimension::MONEY;
253         }
254         else if(dimension_name == "px")
255         {
256             dimension_type = dimension::PIXEL;
257         }
258         else if(dimension_name == "memo")
259         {
260             dimension_type = dimension::MEMO;
261         }
262         else if(dimension_name == "")
263         {
264             dimension_type = dimension::NONE;
265         }
266         else
267         {
268             prefix = scifir::prefix(prefix::NONE);
269             if (init_dimension\&.size() > 3)
270             {
271                 string symbol_abreviation = dimension::create_full_symbol(init_dimension);
272                 symbol_abreviation\&.copy(symbol, init_dimension\&.length());
273                 dimension_type = dimension::CUSTOM_FULL_SYMBOL;
274             }
275             else
276             {
277                 init_dimension\&.copy(symbol, init_dimension\&.length());
278                 dimension_type = dimension::CUSTOM;
279             }
280         }
281     }
.fi
.SH "Member Function Documentation"
.PP 
.SS "static void dimension::create_custom_dimension (const string & new_symbol, const string & init_dimensions)\fC [inline]\fP, \fC [static]\fP"

.PP
Creates a new custom dimension, that's stored with its symbol, which is given as an string, and the dimensions it can be derived to, if this custom dimension is not a new basic dimension\&. 
.PP
Definition at line 67 of file dimension\&.hpp\&.
.PP
.nf
68             {
69                 if (dimension::base_dimensions\&.count(new_symbol) == 0)
70                 {
71                     dimension::base_dimensions[new_symbol] = create_derived_dimensions(init_dimensions);
72                 }
73             }
.fi
.SS "static char * dimension::create_full_symbol (const string & full_symbol)\fC [inline]\fP, \fC [static]\fP"

.PP
Creates a new dimension that's stored in the private static map \fBdimension::full_symbols\fP\&. 
.PP
Definition at line 75 of file dimension\&.hpp\&.
.PP
.nf
76             {
77                 char symbol_abbreviation[3] = "";
78                 total_full_symbols++;
79                 if (total_full_symbols <= 255)
80                 {
81                     if (total_full_symbols <= 32)
82                     {
83                         total_full_symbols = 33;
84                     }
85                     symbol_abbreviation[0] = char(total_full_symbols);
86                     symbol_abbreviation[1] = '\n';
87                     symbol_abbreviation[2] = '\n';
88                 }
89                 else if (total_full_symbols <= 65535)
90                 {
91                     int char_code1 = (total_full_symbols / 256);
92                     if (char_code1 <= 32)
93                     {
94                         char_code1 = 33;
95                     }
96                     symbol_abbreviation[0] += char(char_code1);
97                     int closest_number = int(floor(total_full_symbols / 256\&.0)) * 256;
98                     int char_code2 = total_full_symbols - closest_number;
99                     if (char_code2 <= 32)
100                     {
101                         char_code2 = 33;
102                     }
103                     symbol_abbreviation[1] += char(char_code2);
104                     symbol_abbreviation[2] = '\n';
105                 }
106                 else
107                 {
108                     int char_code1 = (total_full_symbols / 65536);
109                     if (char_code1 <= 32)
110                     {
111                         char_code1 = 33;
112                     }
113                     symbol_abbreviation[0] += char(char_code1);
114                     int closest_number = int(floor(total_full_symbols / 65536\&.0)) * 65536;
115                     int char_code2 = total_full_symbols - closest_number;
116                     if (char_code2 <= 32)
117                     {
118                         char_code2 = 33;
119                     }
120                     symbol_abbreviation[1] += char(char_code2);
121                     int closest_number2 = int(floor(total_full_symbols / 256\&.0)) * 256;
122                     int char_code3 = total_full_symbols - closest_number2;
123                     if (char_code3 <= 32)
124                     {
125                         char_code3 = 33;
126                     }
127                     symbol_abbreviation[2] += char(char_code3);
128                 }
129                 full_symbols[total_full_symbols] = full_symbol;
130                 return new char[3]{symbol_abbreviation[0],symbol_abbreviation[1],symbol_abbreviation[2]};
131             }
.fi
.SS "vector< \fBdimension\fP > dimension::get_basic_dimensions () const"

.PP
Returns the basic dimensions of the dimension, which are different than the dimension, and possible more than one, if the dimension is not basic\&. 
.PP
Definition at line 908 of file dimension\&.cpp\&.
.PP
.nf
909     {
910         vector<dimension> basic_dimensions = vector<dimension>();
911         switch (dimension_type)
912         {
913             case dimension::NONE:
914                 basic_dimensions\&.push_back(dimension(dimension::NONE,prefix::NONE,dimension::NUMERATOR));
915                 break;
916             case dimension::METRE:
917                 basic_dimensions\&.push_back(dimension(dimension::METRE,prefix::NONE,dimension::NUMERATOR));
918                 break;
919             case dimension::DEGREE:
920                 basic_dimensions\&.push_back(dimension(dimension::RADIAN,prefix::NONE,dimension::NUMERATOR));
921                 break;
922             case dimension::RADIAN:
923                 basic_dimensions\&.push_back(dimension(dimension::RADIAN,prefix::NONE,dimension::NUMERATOR));
924                 break;
925             case dimension::STERADIAN:
926                 basic_dimensions\&.push_back(dimension(dimension::STERADIAN,prefix::NONE,dimension::NUMERATOR));
927                 break;
928             case dimension::SECOND:
929                 basic_dimensions\&.push_back(dimension(dimension::SECOND,prefix::NONE,dimension::NUMERATOR));
930                 break;
931             case dimension::GRAM:
932                 basic_dimensions\&.push_back(dimension(dimension::GRAM,prefix::NONE,dimension::NUMERATOR));
933                 break;
934             case dimension::COULOMB:
935                 basic_dimensions\&.push_back(dimension(dimension::COULOMB,prefix::NONE,dimension::NUMERATOR));
936                 break;
937             case dimension::KELVIN:
938                 basic_dimensions\&.push_back(dimension(dimension::KELVIN,prefix::NONE,dimension::NUMERATOR));
939                 break;
940             case dimension::MOLE:
941                 basic_dimensions\&.push_back(dimension(dimension::MOLE,prefix::NONE,dimension::NUMERATOR));
942                 break;
943             case dimension::CANDELA:
944                 basic_dimensions\&.push_back(dimension(dimension::CANDELA,prefix::NONE,dimension::NUMERATOR));
945                 break;
946             case dimension::BYTE:
947                 basic_dimensions\&.push_back(dimension(dimension::BYTE,prefix::NONE,dimension::NUMERATOR));
948                 break;
949             case dimension::HERTZ:
950                 basic_dimensions\&.push_back(dimension(dimension::SECOND,prefix::NONE,dimension::DENOMINATOR));
951                 break;
952             case dimension::NEWTON:
953                 basic_dimensions\&.push_back(dimension(dimension::GRAM,prefix::KILO,dimension::NUMERATOR));
954                 basic_dimensions\&.push_back(dimension(dimension::METRE,prefix::NONE,dimension::NUMERATOR));
955                 basic_dimensions\&.push_back(dimension(dimension::SECOND,prefix::NONE,dimension::DENOMINATOR));
956                 basic_dimensions\&.push_back(dimension(dimension::SECOND,prefix::NONE,dimension::DENOMINATOR));
957                 break;
958             case dimension::PASCAL:
959                 basic_dimensions\&.push_back(dimension(dimension::GRAM,prefix::KILO,dimension::NUMERATOR));
960                 basic_dimensions\&.push_back(dimension(dimension::SECOND,prefix::NONE,dimension::DENOMINATOR));
961                 basic_dimensions\&.push_back(dimension(dimension::SECOND,prefix::NONE,dimension::DENOMINATOR));
962                 basic_dimensions\&.push_back(dimension(dimension::METRE,prefix::NONE,dimension::DENOMINATOR));
963                 break;
964             case dimension::JOULE:
965                 basic_dimensions\&.push_back(dimension(dimension::GRAM,prefix::KILO,dimension::NUMERATOR));
966                 basic_dimensions\&.push_back(dimension(dimension::METRE,prefix::NONE,dimension::NUMERATOR));
967                 basic_dimensions\&.push_back(dimension(dimension::METRE,prefix::NONE,dimension::NUMERATOR));
968                 basic_dimensions\&.push_back(dimension(dimension::SECOND,prefix::NONE,dimension::DENOMINATOR));
969                 basic_dimensions\&.push_back(dimension(dimension::SECOND,prefix::NONE,dimension::DENOMINATOR));
970                 break;
971             case dimension::WATT:
972                 basic_dimensions\&.push_back(dimension(dimension::GRAM,prefix::KILO,dimension::NUMERATOR));
973                 basic_dimensions\&.push_back(dimension(dimension::METRE,prefix::NONE,dimension::NUMERATOR));
974                 basic_dimensions\&.push_back(dimension(dimension::METRE,prefix::NONE,dimension::NUMERATOR));
975                 basic_dimensions\&.push_back(dimension(dimension::SECOND,prefix::NONE,dimension::DENOMINATOR));
976                 basic_dimensions\&.push_back(dimension(dimension::SECOND,prefix::NONE,dimension::DENOMINATOR));
977                 basic_dimensions\&.push_back(dimension(dimension::SECOND,prefix::NONE,dimension::DENOMINATOR));
978                 break;
979             case dimension::AMPERE:
980                 basic_dimensions\&.push_back(dimension(dimension::COULOMB,prefix::NONE,dimension::NUMERATOR));
981                 basic_dimensions\&.push_back(dimension(dimension::SECOND,prefix::NONE,dimension::DENOMINATOR));
982                 break;
983             case dimension::VOLT:
984                 basic_dimensions\&.push_back(dimension(dimension::GRAM,prefix::KILO,dimension::NUMERATOR));
985                 basic_dimensions\&.push_back(dimension(dimension::METRE,prefix::NONE,dimension::NUMERATOR));
986                 basic_dimensions\&.push_back(dimension(dimension::METRE,prefix::NONE,dimension::NUMERATOR));
987                 basic_dimensions\&.push_back(dimension(dimension::COULOMB,prefix::NONE,dimension::NUMERATOR));
988                 basic_dimensions\&.push_back(dimension(dimension::SECOND,prefix::NONE,dimension::DENOMINATOR));
989                 basic_dimensions\&.push_back(dimension(dimension::SECOND,prefix::NONE,dimension::DENOMINATOR));
990                 break;
991             case dimension::FARADAY:
992                 basic_dimensions\&.push_back(dimension(dimension::GRAM,prefix::KILO,dimension::DENOMINATOR));
993                 basic_dimensions\&.push_back(dimension(dimension::METRE,prefix::NONE,dimension::DENOMINATOR));
994                 basic_dimensions\&.push_back(dimension(dimension::METRE,prefix::NONE,dimension::DENOMINATOR));
995                 basic_dimensions\&.push_back(dimension(dimension::COULOMB,prefix::NONE,dimension::NUMERATOR));
996                 basic_dimensions\&.push_back(dimension(dimension::COULOMB,prefix::NONE,dimension::NUMERATOR));
997                 basic_dimensions\&.push_back(dimension(dimension::SECOND,prefix::NONE,dimension::NUMERATOR));
998                 basic_dimensions\&.push_back(dimension(dimension::SECOND,prefix::NONE,dimension::NUMERATOR));
999                 break;
1000             case dimension::OHM:
1001                 basic_dimensions\&.push_back(dimension(dimension::GRAM,prefix::KILO,dimension::NUMERATOR));
1002                 basic_dimensions\&.push_back(dimension(dimension::METRE,prefix::NONE,dimension::NUMERATOR));
1003                 basic_dimensions\&.push_back(dimension(dimension::METRE,prefix::NONE,dimension::NUMERATOR));
1004                 basic_dimensions\&.push_back(dimension(dimension::COULOMB,prefix::NONE,dimension::NUMERATOR));
1005                 basic_dimensions\&.push_back(dimension(dimension::COULOMB,prefix::NONE,dimension::NUMERATOR));
1006                 basic_dimensions\&.push_back(dimension(dimension::SECOND,prefix::NONE,dimension::DENOMINATOR));
1007                 break;
1008             case dimension::SIEMENS:
1009                 basic_dimensions\&.push_back(dimension(dimension::COULOMB,prefix::NONE,dimension::NUMERATOR));
1010                 basic_dimensions\&.push_back(dimension(dimension::COULOMB,prefix::NONE,dimension::NUMERATOR));
1011                 basic_dimensions\&.push_back(dimension(dimension::SECOND,prefix::NONE,dimension::NUMERATOR));
1012                 basic_dimensions\&.push_back(dimension(dimension::GRAM,prefix::KILO,dimension::DENOMINATOR));
1013                 basic_dimensions\&.push_back(dimension(dimension::METRE,prefix::NONE,dimension::DENOMINATOR));
1014                 basic_dimensions\&.push_back(dimension(dimension::METRE,prefix::NONE,dimension::DENOMINATOR));
1015                 break;
1016             case dimension::WEBER:
1017                 basic_dimensions\&.push_back(dimension(dimension::GRAM,prefix::KILO,dimension::NUMERATOR));
1018                 basic_dimensions\&.push_back(dimension(dimension::METRE,prefix::NONE,dimension::NUMERATOR));
1019                 basic_dimensions\&.push_back(dimension(dimension::METRE,prefix::NONE,dimension::NUMERATOR));
1020                 basic_dimensions\&.push_back(dimension(dimension::COULOMB,prefix::NONE,dimension::NUMERATOR));
1021                 basic_dimensions\&.push_back(dimension(dimension::SECOND,prefix::NONE,dimension::DENOMINATOR));
1022                 break;
1023             case dimension::TESLA:
1024                 basic_dimensions\&.push_back(dimension(dimension::GRAM,prefix::KILO,dimension::NUMERATOR));
1025                 basic_dimensions\&.push_back(dimension(dimension::COULOMB,prefix::NONE,dimension::NUMERATOR));
1026                 basic_dimensions\&.push_back(dimension(dimension::SECOND,prefix::NONE,dimension::DENOMINATOR));
1027                 break;
1028             case dimension::HENRY:
1029                 basic_dimensions\&.push_back(dimension(dimension::GRAM,prefix::KILO,dimension::NUMERATOR));
1030                 basic_dimensions\&.push_back(dimension(dimension::METRE,prefix::NONE,dimension::NUMERATOR));
1031                 basic_dimensions\&.push_back(dimension(dimension::METRE,prefix::NONE,dimension::NUMERATOR));
1032                 basic_dimensions\&.push_back(dimension(dimension::COULOMB,prefix::NONE,dimension::NUMERATOR));
1033                 basic_dimensions\&.push_back(dimension(dimension::COULOMB,prefix::NONE,dimension::NUMERATOR));
1034                 break;
1035             case dimension::LUMEN:
1036                 basic_dimensions\&.push_back(dimension(dimension::CANDELA,prefix::NONE,dimension::NUMERATOR));
1037                 basic_dimensions\&.push_back(dimension(dimension::STERADIAN,prefix::NONE,dimension::NUMERATOR));
1038                 break;
1039             case dimension::LUX:
1040                 basic_dimensions\&.push_back(dimension(dimension::CANDELA,prefix::NONE,dimension::NUMERATOR));
1041                 basic_dimensions\&.push_back(dimension(dimension::STERADIAN,prefix::NONE,dimension::NUMERATOR));
1042                 basic_dimensions\&.push_back(dimension(dimension::METRE,prefix::NONE,dimension::DENOMINATOR));
1043                 basic_dimensions\&.push_back(dimension(dimension::METRE,prefix::NONE,dimension::DENOMINATOR));
1044                 break;
1045             case dimension::BECQUEREL:
1046                 basic_dimensions\&.push_back(dimension(dimension::SECOND,prefix::NONE,dimension::DENOMINATOR));
1047                 break;
1048             case dimension::GRAY:
1049                 basic_dimensions\&.push_back(dimension(dimension::METRE,prefix::NONE,dimension::NUMERATOR));
1050                 basic_dimensions\&.push_back(dimension(dimension::METRE,prefix::NONE,dimension::NUMERATOR));
1051                 basic_dimensions\&.push_back(dimension(dimension::SECOND,prefix::NONE,dimension::DENOMINATOR));
1052                 basic_dimensions\&.push_back(dimension(dimension::SECOND,prefix::NONE,dimension::DENOMINATOR));
1053                 break;
1054             case dimension::SIEVERT:
1055                 basic_dimensions\&.push_back(dimension(dimension::METRE,prefix::NONE,dimension::NUMERATOR));
1056                 basic_dimensions\&.push_back(dimension(dimension::METRE,prefix::NONE,dimension::NUMERATOR));
1057                 basic_dimensions\&.push_back(dimension(dimension::SECOND,prefix::NONE,dimension::DENOMINATOR));
1058                 basic_dimensions\&.push_back(dimension(dimension::SECOND,prefix::NONE,dimension::DENOMINATOR));
1059                 break;
1060             case dimension::KATAL:
1061                 basic_dimensions\&.push_back(dimension(dimension::MOLE,prefix::NONE,dimension::NUMERATOR));
1062                 basic_dimensions\&.push_back(dimension(dimension::SECOND,prefix::NONE,dimension::DENOMINATOR));
1063                 break;
1064             case dimension::ANGSTROM:
1065                 basic_dimensions\&.push_back(dimension(dimension::METRE,prefix::NONE,dimension::NUMERATOR));
1066                 break;
1067             case dimension::LITRE:
1068                 basic_dimensions\&.push_back(dimension(dimension::METRE,prefix::NONE,dimension::NUMERATOR));
1069                 basic_dimensions\&.push_back(dimension(dimension::METRE,prefix::NONE,dimension::NUMERATOR));
1070                 basic_dimensions\&.push_back(dimension(dimension::METRE,prefix::NONE,dimension::NUMERATOR));
1071                 break;
1072             case dimension::MINUTE:
1073                 basic_dimensions\&.push_back(dimension(dimension::SECOND,prefix::NONE,dimension::NUMERATOR));
1074                 break;
1075             case dimension::HOUR:
1076                 basic_dimensions\&.push_back(dimension(dimension::SECOND,prefix::NONE,dimension::NUMERATOR));
1077                 break;
1078             case dimension::DAY:
1079                 basic_dimensions\&.push_back(dimension(dimension::SECOND,prefix::NONE,dimension::NUMERATOR));
1080                 break;
1081             case dimension::LIGHT_YEAR:
1082                 basic_dimensions\&.push_back(dimension(dimension::METRE,prefix::NONE,dimension::NUMERATOR));
1083                 break;
1084             case dimension::ASTRONOMICAL_UNIT:
1085                 basic_dimensions\&.push_back(dimension(dimension::METRE,prefix::NONE,dimension::NUMERATOR));
1086                 break;
1087             case dimension::PARSEC:
1088                 basic_dimensions\&.push_back(dimension(dimension::METRE,prefix::NONE,dimension::NUMERATOR));
1089                 break;
1090             case dimension::ELECTRON_VOLT:
1091                 basic_dimensions\&.push_back(dimension(dimension::METRE,prefix::NONE,dimension::NUMERATOR));
1092                 basic_dimensions\&.push_back(dimension(dimension::METRE,prefix::NONE,dimension::NUMERATOR));
1093                 basic_dimensions\&.push_back(dimension(dimension::GRAM,prefix::KILO,dimension::NUMERATOR));
1094                 basic_dimensions\&.push_back(dimension(dimension::SECOND,prefix::NONE,dimension::DENOMINATOR));
1095                 basic_dimensions\&.push_back(dimension(dimension::SECOND,prefix::NONE,dimension::DENOMINATOR));
1096                 break;
1097             case dimension::DALTON:
1098                 basic_dimensions\&.push_back(dimension(dimension::GRAM,prefix::KILO,dimension::NUMERATOR));
1099                 break;
1100             case dimension::ATOMIC_MASS_UNIT:
1101                 basic_dimensions\&.push_back(dimension(dimension::GRAM,prefix::NONE,dimension::NUMERATOR));
1102                 break;
1103             case dimension::BARN:
1104                 basic_dimensions\&.push_back(dimension(dimension::METRE,prefix::NONE,dimension::NUMERATOR));
1105                 basic_dimensions\&.push_back(dimension(dimension::METRE,prefix::NONE,dimension::NUMERATOR));
1106                 break;
1107             case dimension::MOLARITY:
1108                 basic_dimensions\&.push_back(dimension(dimension::MOLE,prefix::NONE,dimension::NUMERATOR));
1109                 basic_dimensions\&.push_back(dimension(dimension::METRE,prefix::NONE,dimension::DENOMINATOR));
1110                 basic_dimensions\&.push_back(dimension(dimension::METRE,prefix::NONE,dimension::DENOMINATOR));
1111                 basic_dimensions\&.push_back(dimension(dimension::METRE,prefix::NONE,dimension::DENOMINATOR));
1112                 break;
1113             case dimension::PARTICLES:
1114                 basic_dimensions\&.push_back(dimension(dimension::MOLE,prefix::NONE,dimension::NUMERATOR));
1115                 break;
1116             case dimension::CUSTOM:
1117             {
1118                 return dimension::base_dimensions[symbol];
1119             }
1120             case dimension::CUSTOM_BASIC:
1121             {
1122                 basic_dimensions\&.push_back(*this);
1123                 break;
1124             }
1125             case dimension::CUSTOM_FULL_SYMBOL:
1126             {
1127                 return dimension::base_dimensions[dimension::get_full_symbol(symbol)];
1128             }
1129             case dimension::MONEY:
1130                 basic_dimensions\&.push_back(dimension(dimension::MONEY,prefix::NONE,dimension::NUMERATOR));
1131                 break;
1132             case dimension::PIXEL:
1133                 basic_dimensions\&.push_back(dimension(dimension::METRE,prefix::NONE,dimension::NUMERATOR));
1134                 break;
1135             case dimension::MEMO:
1136                 basic_dimensions\&.push_back(dimension(dimension::MEMO,prefix::NONE,dimension::NUMERATOR));
1137                 break;
1138         }
1139         return basic_dimensions;
1140     }
.fi
.SS "long double dimension::get_conversion_factor () const"

.PP
Returns the conversion factor of the dimension\&. 
.PP
Definition at line 556 of file dimension\&.cpp\&.
.PP
.nf
557     {
558         switch(dimension_type)
559         {
560             case dimension::NONE:
561                 return 1\&.0l;
562             case dimension::METRE:
563                 return 1\&.0l;
564             case dimension::DEGREE:
565                 return PI / 180\&.0l;
566             case dimension::RADIAN:
567                 return 1\&.0l;
568             case dimension::STERADIAN:
569                 return 1\&.0l;
570             case dimension::GRAM:
571                 return 1\&.0l;
572             case dimension::SECOND:
573                 return 1\&.0l;
574             case dimension::COULOMB:
575                 return 1\&.0l;
576             case dimension::KELVIN:
577                 return 1\&.0l;
578             case dimension::MOLE:
579                 return 1\&.0l;
580             case dimension::CANDELA:
581                 return 1\&.0l;
582             case dimension::BYTE:
583                 return 1\&.0l;
584             case dimension::HERTZ:
585                 return 1\&.0l;
586             case dimension::NEWTON:
587                 return 1\&.0l;
588             case dimension::PASCAL:
589                 return 1\&.0l;
590             case dimension::JOULE:
591                 return 1\&.0l;
592             case dimension::WATT:
593                 return 1\&.0l;
594             case dimension::AMPERE:
595                 return 1\&.0l;
596             case dimension::VOLT:
597                 return 1\&.0l;
598             case dimension::FARADAY:
599                 return 1;
600             case dimension::OHM:
601                 return 1\&.0l;
602             case dimension::SIEMENS:
603                 return 1\&.0l;
604             case dimension::WEBER:
605                 return 1\&.0l;
606             case dimension::TESLA:
607                 return 1\&.0l;
608             case dimension::HENRY:
609                 return 1\&.0l;
610             case dimension::LUMEN:
611                 return 1\&.0l;
612             case dimension::LUX:
613                 return 1\&.0l;
614             case dimension::BECQUEREL:
615                 return 1\&.0l;
616             case dimension::GRAY:
617                 return 1\&.0l;
618             case dimension::SIEVERT:
619                 return 1\&.0l;
620             case dimension::KATAL:
621                 return 1\&.0l;
622             case dimension::ANGSTROM:
623                 return 1\&.0l;
624             case dimension::LITRE:
625                 return 1\&.0l;
626             case dimension::MINUTE:
627                 return 60l;
628             case dimension::HOUR:
629                 return 3600l;
630             case dimension::DAY:
631                 return 86400l;
632             case dimension::LIGHT_YEAR:
633                 return 9\&.4607379375591e15;
634             case dimension::ASTRONOMICAL_UNIT:
635                 return 149597870700\&.0l;
636             case dimension::PARSEC:
637                 return 30856775814913673\&.0l;
638             case dimension::ELECTRON_VOLT:
639                 return 0\&.0000000000000000001602176634l;
640             case dimension::DALTON:
641                 return 0\&.00000000000000000000000000166053886l;
642             case dimension::ATOMIC_MASS_UNIT:
643                 return 0\&.00000000000000000000000000166053886l;
644             case dimension::BARN:
645                 return 0\&.0000000000000000000000000001l;
646             case dimension::MOLARITY:
647                 return 1\&.0l;
648             case dimension::PARTICLES:
649                 return 1\&.0l/AVOGADRO_CONSTANT;
650             case dimension::CUSTOM:
651                 return 1\&.0l;
652             case dimension::CUSTOM_BASIC:
653                 return 1\&.0l;
654             case dimension::CUSTOM_FULL_SYMBOL:
655                 return 1\&.0l;
656             case dimension::MONEY:
657                 return 1\&.0l;
658             case dimension::PIXEL:
659                 return 0\&.00026l;
660             case dimension::MEMO:
661                 return 1\&.0l;
662         }
663         return 1\&.0l;
664     }
.fi
.SS "static string dimension::get_full_symbol (const char * x_symbol)\fC [inline]\fP, \fC [static]\fP"

.PP
Returns the symbol of a custom_full_symbol dimension stored in the private static map \fBdimension::full_symbols\fP\&. 
.PP
Definition at line 133 of file dimension\&.hpp\&.
.PP
.nf
134             {
135                 int symbol_code;
136                 if (x_symbol[1] == '\n')
137                 {
138                     symbol_code = int(x_symbol[0]);
139                 }
140                 else if (x_symbol[2] == '\n')
141                 {
142                     symbol_code = int(x_symbol[0]) * 256;
143                     symbol_code += int(x_symbol[1]);
144                 }
145                 else
146                 {
147                     symbol_code = int(x_symbol[0]) * 65536;
148                     symbol_code += int(x_symbol[1]) * 256;
149                     symbol_code += int(x_symbol[2]);
150                 }
151                 return full_symbols[symbol_code];
152             }
.fi
.SS "string dimension::get_name () const"

.PP
Returns the name of the dimension\&. 
.PP
Definition at line 321 of file dimension\&.cpp\&.
.PP
.nf
322     {
323         switch(dimension_type)
324         {
325             case dimension::NONE:
326                 return "empty";
327             case dimension::METRE:
328                 return "metre";
329             case dimension::DEGREE:
330                 return "degree";
331             case dimension::RADIAN:
332                 return "radian";
333             case dimension::STERADIAN:
334                 return "steradian";
335             case dimension::SECOND:
336                 return "second";
337             case dimension::GRAM:
338                 return "gram";
339             case dimension::COULOMB:
340                 return "coulomb";
341             case dimension::KELVIN:
342                 return "kelvin";
343             case dimension::MOLE:
344                 return "mole";
345             case dimension::CANDELA:
346                 return "candela";
347             case dimension::BYTE:
348                 return "byte";
349             case dimension::HERTZ:
350                 return "hertz";
351             case dimension::NEWTON:
352                 return "newton";
353             case dimension::PASCAL:
354                 return "pascal";
355             case dimension::JOULE:
356                 return "joule";
357             case dimension::WATT:
358                 return "watt";
359             case dimension::AMPERE:
360                 return "ampere";
361             case dimension::VOLT:
362                 return "volt";
363             case dimension::FARADAY:
364                 return "faraday";
365             case dimension::OHM:
366                 return "ohm";
367             case dimension::SIEMENS:
368                 return "siemens";
369             case dimension::WEBER:
370                 return "weber";
371             case dimension::TESLA:
372                 return "tesla";
373             case dimension::HENRY:
374                 return "henry";
375             case dimension::LUMEN:
376                 return "lumen";
377             case dimension::LUX:
378                 return "lux";
379             case dimension::BECQUEREL:
380                 return "becquerel";
381             case dimension::GRAY:
382                 return "gray";
383             case dimension::SIEVERT:
384                 return "sievert";
385             case dimension::KATAL:
386                 return "katal";
387             case dimension::ANGSTROM:
388                 return "angstrom";
389             case dimension::LITRE:
390                 return "litre";
391             case dimension::MINUTE:
392                 return "minute";
393             case dimension::HOUR:
394                 return "hour";
395             case dimension::DAY:
396                 return "day";
397             case dimension::LIGHT_YEAR:
398                 return "light year";
399             case dimension::ASTRONOMICAL_UNIT:
400                 return "astronomical unit";
401             case dimension::PARSEC:
402                 return "parsec";
403             case dimension::ELECTRON_VOLT:
404                 return "electronvolt";
405             case dimension::DALTON:
406                 return "dalton";
407             case dimension::ATOMIC_MASS_UNIT:
408                 return "atomic mass unit";
409             case dimension::BARN:
410                 return "barn";
411             case dimension::MOLARITY:
412                 return "molarity";
413             case dimension::PARTICLES:
414                 return "particles";
415             case dimension::CUSTOM:
416                 return "custom-dimension";
417             case dimension::CUSTOM_BASIC:
418                 return "custom-basic";
419             case dimension::CUSTOM_FULL_SYMBOL:
420                 return "custom-full-symbol";
421             case dimension::MONEY:
422                 return "money";
423             case dimension::PIXEL:
424                 return "pixel";
425             case dimension::MEMO:
426                 return "memo";
427         }
428         return "";
429     }
.fi
.SS "string dimension::get_symbol () const"

.PP
Returns the symbol of the dimension\&. In the case of a custom dimension, it returns the custom dimension defined\&. 
.PP
Definition at line 431 of file dimension\&.cpp\&.
.PP
.nf
432     {
433         switch(dimension_type)
434         {
435             case dimension::NONE:
436                 return "empty";
437             case dimension::METRE:
438                 return "m";
439 #ifdef IS_UNIX
440             case dimension::DEGREE:
441                 return "\U000003B8";
442 #elif IS_WINDOWS
443             case dimension::DEGREE:
444                 return "\U03B8";
445 #endif
446             case dimension::RADIAN:
447                 return "rad";
448             case dimension::STERADIAN:
449                 return "sr";
450             case dimension::SECOND:
451                 return "s";
452             case dimension::GRAM:
453                 return "g";
454             case dimension::COULOMB:
455                 return "C";
456             case dimension::KELVIN:
457                 return "K";
458             case dimension::MOLE:
459                 return "mol";
460             case dimension::CANDELA:
461                 return "cd";
462             case dimension::BYTE:
463                 return "B";
464             case dimension::HERTZ:
465                 return "Hz";
466             case dimension::NEWTON:
467                 return "N";
468             case dimension::PASCAL:
469                 return "Pa";
470             case dimension::JOULE:
471                 return "J";
472             case dimension::WATT:
473                 return "W";
474             case dimension::AMPERE:
475                 return "A";
476             case dimension::VOLT:
477                 return "V";
478             case dimension::FARADAY:
479                 return "F";
480 #ifdef IS_UNIX
481             case dimension::OHM:
482                 return "\U000003A9";
483 #elif IS_WINDOWS
484             case dimension::OHM:
485                 return "\U03A9";
486 #endif
487             case dimension::SIEMENS:
488                 return "S";
489             case dimension::WEBER:
490                 return "Wb";
491             case dimension::TESLA:
492                 return "T";
493             case dimension::HENRY:
494                 return "H";
495             case dimension::LUMEN:
496                 return "lm";
497             case dimension::LUX:
498                 return "lx";
499             case dimension::BECQUEREL:
500                 return "Bq";
501             case dimension::GRAY:
502                 return "Gy";
503             case dimension::SIEVERT:
504                 return "Sv";
505             case dimension::KATAL:
506                 return "kat";
507 #ifdef IS_UNIX
508             case dimension::ANGSTROM:
509                 return "\U0000212B";
510 #elif IS_WINDOWS
511             case dimension::ANGSTROM:
512                 return "\U212B";
513 #endif
514             case dimension::LITRE:
515                 return "L";
516             case dimension::MINUTE:
517                 return "min";
518             case dimension::HOUR:
519                 return "h";
520             case dimension::DAY:
521                 return "d";
522             case dimension::LIGHT_YEAR:
523                 return "ly";
524             case dimension::ASTRONOMICAL_UNIT:
525                 return "AU";
526             case dimension::PARSEC:
527                 return "pc";
528             case dimension::ELECTRON_VOLT:
529                 return "eV";
530             case dimension::DALTON:
531                 return "Da";
532             case dimension::ATOMIC_MASS_UNIT:
533                 return "amu";
534             case dimension::BARN:
535                 return "barn";
536             case dimension::MOLARITY:
537                 return "M";
538             case dimension::PARTICLES:
539                 return "particles";
540             case dimension::CUSTOM:
541                 return string("")\&.assign(symbol, symbol + 3);
542             case dimension::CUSTOM_BASIC:
543                 return "custom-basic";
544             case dimension::CUSTOM_FULL_SYMBOL:
545                 return dimension::get_full_symbol(symbol);
546             case dimension::MONEY:
547                 return "money";
548             case dimension::PIXEL:
549                 return "px";
550             case dimension::MEMO:
551                 return "memo";
552         }
553         return "";
554     }
.fi
.SS "void dimension::invert ()"

.PP
Changes the position of the dimension to the reverse, from the NUMERATOR to the DENOMINATOR, or from the DENOMINATOR to the NUMERATOR\&. 
.PP
Definition at line 1142 of file dimension\&.cpp\&.
.PP
.nf
1143     {
1144         if (dimension_position == dimension::NUMERATOR)
1145         {
1146             dimension_position = dimension::DENOMINATOR;
1147         }
1148         else
1149         {
1150             dimension_position = dimension::NUMERATOR;
1151         }
1152     }
.fi
.SS "bool dimension::is_basic_dimension () const"

.PP
If the dimension is an SI basic dimension, it's considered a basic dimension\&. 
.PP
Definition at line 793 of file dimension\&.cpp\&.
.PP
.nf
794     {
795         switch(dimension_type)
796         {
797             case dimension::NONE:
798                 return true;
799             case dimension::METRE:
800                 return true;
801             case dimension::DEGREE:
802                 return true;
803             case dimension::RADIAN:
804                 return true;
805             case dimension::STERADIAN:
806                 return true;
807             case dimension::GRAM:
808                 return true;
809             case dimension::SECOND:
810                 return true;
811             case dimension::COULOMB:
812                 return true;
813             case dimension::KELVIN:
814                 return true;
815             case dimension::MOLE:
816                 return true;
817             case dimension::CANDELA:
818                 return true;
819             case dimension::BYTE:
820                 return true;
821             case dimension::HERTZ:
822                 return false;
823             case dimension::NEWTON:
824                 return false;
825             case dimension::PASCAL:
826                 return false;
827             case dimension::JOULE:
828                 return false;
829             case dimension::WATT:
830                 return false;
831             case dimension::AMPERE:
832                 return false;
833             case dimension::VOLT:
834                 return false;
835             case dimension::FARADAY:
836                 return false;
837             case dimension::OHM:
838                 return false;
839             case dimension::SIEMENS:
840                 return false;
841             case dimension::WEBER:
842                 return false;
843             case dimension::TESLA:
844                 return false;
845             case dimension::HENRY:
846                 return false;
847             case dimension::LUMEN:
848                 return false;
849             case dimension::LUX:
850                 return false;
851             case dimension::BECQUEREL:
852                 return false;
853             case dimension::GRAY:
854                 return false;
855             case dimension::SIEVERT:
856                 return false;
857             case dimension::KATAL:
858                 return false;
859             case dimension::ANGSTROM:
860                 return false;
861             case dimension::LITRE:
862                 return false;
863             case dimension::MINUTE:
864                 return false;
865             case dimension::HOUR:
866                 return false;
867             case dimension::DAY:
868                 return false;
869             case dimension::LIGHT_YEAR:
870                 return false;
871             case dimension::ASTRONOMICAL_UNIT:
872                 return false;
873             case dimension::PARSEC:
874                 return false;
875             case dimension::ELECTRON_VOLT:
876                 return false;
877             case dimension::DALTON:
878                 return false;
879             case dimension::ATOMIC_MASS_UNIT:
880                 return false;
881             case dimension::BARN:
882                 return false;
883             case dimension::MOLARITY:
884                 return false;
885             case dimension::PARTICLES:
886                 return false;
887             case dimension::CUSTOM:
888                 return false;
889             case dimension::CUSTOM_BASIC:
890                 return true;
891             case dimension::CUSTOM_FULL_SYMBOL:
892                 return false;
893             case dimension::MONEY:
894                 return true;
895             case dimension::PIXEL:
896                 return false;
897             case dimension::MEMO:
898                 return true;
899         }
900         return true;
901     }
.fi
.SS "bool dimension::is_derived_dimension () const"

.PP
If the dimension is not a basic dimension, it's considered a derived dimension\&. 
.PP
Definition at line 903 of file dimension\&.cpp\&.
.PP
.nf
904     {
905         return !is_basic_dimension();
906     }
.fi
.SS "bool dimension::is_simple_dimension () const"

.PP
If the dimension doesn't has more derived dimensions, it's considered a simple dimension\&. 
.PP
Definition at line 683 of file dimension\&.cpp\&.
.PP
.nf
684     {
685         switch(dimension_type)
686         {
687             case dimension::NONE:
688                 return true;
689             case dimension::METRE:
690                 return true;
691             case dimension::DEGREE:
692                 return true;
693             case dimension::RADIAN:
694                 return true;
695             case dimension::STERADIAN:
696                 return true;
697             case dimension::GRAM:
698                 return true;
699             case dimension::SECOND:
700                 return true;
701             case dimension::COULOMB:
702                 return true;
703             case dimension::KELVIN:
704                 return true;
705             case dimension::MOLE:
706                 return true;
707             case dimension::CANDELA:
708                 return true;
709             case dimension::BYTE:
710                 return true;
711             case dimension::HERTZ:
712                 return true;
713             case dimension::NEWTON:
714                 return false;
715             case dimension::PASCAL:
716                 return false;
717             case dimension::JOULE:
718                 return false;
719             case dimension::WATT:
720                 return false;
721             case dimension::AMPERE:
722                 return true;
723             case dimension::VOLT:
724                 return false;
725             case dimension::FARADAY:
726                 return false;
727             case dimension::OHM:
728                 return false;
729             case dimension::SIEMENS:
730                 return false;
731             case dimension::WEBER:
732                 return false;
733             case dimension::TESLA:
734                 return false;
735             case dimension::HENRY:
736                 return false;
737             case dimension::LUMEN:
738                 return false;
739             case dimension::LUX:
740                 return false;
741             case dimension::BECQUEREL:
742                 return true;
743             case dimension::GRAY:
744                 return false;
745             case dimension::SIEVERT:
746                 return false;
747             case dimension::KATAL:
748                 return false;
749             case dimension::ANGSTROM:
750                 return true;
751             case dimension::LITRE:
752                 return false;
753             case dimension::MINUTE:
754                 return true;
755             case dimension::HOUR:
756                 return true;
757             case dimension::DAY:
758                 return true;
759             case dimension::LIGHT_YEAR:
760                 return true;
761             case dimension::ASTRONOMICAL_UNIT:
762                 return true;
763             case dimension::PARSEC:
764                 return true;
765             case dimension::ELECTRON_VOLT:
766                 return false;
767             case dimension::DALTON:
768                 return true;
769             case dimension::ATOMIC_MASS_UNIT:
770                 return true;
771             case dimension::BARN:
772                 return false;
773             case dimension::MOLARITY:
774                 return false;
775             case dimension::PARTICLES:
776                 return true;
777             case dimension::CUSTOM:
778                 return false;
779             case dimension::CUSTOM_BASIC:
780                 return true;
781             case dimension::CUSTOM_FULL_SYMBOL:
782                 return false;
783             case dimension::MONEY:
784                 return true;
785             case dimension::PIXEL:
786                 return true;
787             case dimension::MEMO:
788                 return true;
789         }
790         return false;
791     }
.fi
.SS "\fBdimension\fP & dimension::operator= (const \fBdimension\fP & x)"

.PP
Copy assignment\&. The dimension copies the dimension x\&. 
.SS "\fBdimension\fP & dimension::operator= (\fBdimension\fP && x)"

.PP
Move assignment\&. The dimension values are all moved from the dimension x\&. 
.SS "long double dimension::prefix_math () const"

.PP
Returns the math between the prefix and the dimension, which varies if the dimension is a B or another\&. In the case of bytes the math with the prefix is different, it's done with 1024 instead of multiples of 10\&. It doesn't includes the conversion factor of dimensions\&. 
.PP
Definition at line 666 of file dimension\&.cpp\&.
.PP
.nf
667     {
668         return prefix_math(prefix);
669     }
.fi
.SS "long double dimension::prefix_math (const \fBprefix\fP & x_prefix) const"

.PP
Returns the math between some prefix and the dimension\&. The difference with the other \fBprefix_math()\fP function is that the prefix is given as parameter\&. 
.PP
Definition at line 671 of file dimension\&.cpp\&.
.PP
.nf
672     {
673         if (dimension_type == dimension::BYTE)
674         {
675             return std::pow(1024, x_prefix\&.get_conversion_factor() / 3);
676         }
677         else
678         {
679             return std::pow(10, x_prefix\&.get_conversion_factor());
680         }
681     }
.fi
.SH "Member Data Documentation"
.PP 
.SS "map< string, vector< \fBdimension\fP > > scifir::dimension::base_dimensions = map<string,vector<\fBdimension\fP>>()\fC [static]\fP, \fC [private]\fP"

.PP
Definition at line 155 of file dimension\&.hpp\&.
.SS "\fBdimension::position\fP dimension::dimension_position"

.PP
The position of the dimension, which can be the NUMERATOR, the DENOMINATOR or NO_POSITION\&. NO_POSITION means that the dimension is not ready to be used, and must be changed if the dimension is intended to be used\&. 
.PP
Definition at line 64 of file dimension\&.hpp\&.
.SS "\fBdimension::type\fP dimension::dimension_type"

.PP
The type of the dimension\&. 
.PP
Definition at line 63 of file dimension\&.hpp\&.
.SS "map< int, string > scifir::dimension::full_symbols = map<int,string>()\fC [static]\fP, \fC [private]\fP"

.PP
Definition at line 156 of file dimension\&.hpp\&.
.SS "\fBscifir::prefix\fP dimension::prefix"

.PP
The prefix of the dimension\&. It's used along with the symbol of the dimension when printing it\&. 
.PP
Definition at line 62 of file dimension\&.hpp\&.
.SS "set< string > scifir::dimension::prefixes_options {'Y', 'Z', 'E', 'P', 'T', 'G', 'M', 'k', 'h', 'd', 'c', 'm', '\\u00B5', 'u', 'n', 'p', 'f', 'a', 'z', 'y'}\fC [static]\fP, \fC [private]\fP"

.PP
Definition at line 158 of file dimension\&.hpp\&.
.SS "char dimension::symbol[3]"

.PP
The value of the position of the character of a custom dimension in the map of full_symbols\&. 
.PP
Definition at line 65 of file dimension\&.hpp\&.
.SS "int scifir::dimension::total_full_symbols = 0\fC [static]\fP, \fC [private]\fP"

.PP
Definition at line 157 of file dimension\&.hpp\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for scifir-units from the source code\&.
